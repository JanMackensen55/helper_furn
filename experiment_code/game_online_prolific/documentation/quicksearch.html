<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"AiDialogue.js.html":{"id":"AiDialogue.js.html","title":"Source: AiDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: AiDialogue.js import {ON_LOCAL_MACHINE, TEXTDIALOGUE_WIDTH, TEXTDIALOGUE_HEIGHT, MINIMUM_TEXT_SIZE} from './Constants.js'; import FormUtil from './formUtil.js'; import Button from './Button.js'; import LikertScale from './LikertScale.js'; import {writeAssessment} from './SosciWriter.js'; import InteractionScene from './InteractionScene.js'; /** * @classdesc * This class provides dialogue scene to get a user text input. * In order to create this dialogue the values required by the DialogueScene must be provided on creation. * Therefore, see {@link DialogueScene#init}. * @calss TextDialouge * In order to run this scene, it can be launched with phaser's scene plugin. * Additionaly, a title and a question text should be provided. * @example * // go to the place, where the scene should be started and insert the following line * this.scene.launch('textDialogue', {mainScene: this, title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION questionNumber: NUMBER}); * // \"this\" must be a scene, because this.scene points at the scene manager of the specific scene. * */ class AiDialogue extends InteractionScene { constructor() { super('aiDialogue'); } create() { /** * This is the title of the dialogue. * @type {String} */ this.title = this.data.title; /** * The profit of the items in the scenario that the character describes. The item entries of this object have the properties * profit and solution. * @type {Object} * @property {Object} chair the properties of the chair * @property {Object} table the table item * @property {Object} bookcase the bookcase item * @property {Object} bed the bed item * @property {Object} material the material which can be accessed with wood and metal. */ this.aiData = this.data.aiData; /** * The question number specifies in what sosci survey item the value is stored. * This is important, if there are multiple text dialogues to keep track of the different questions. * @type {number} */ this.questionNumber = this.data.questionNumber; /** * The question that is displayed to the user above the input field, where the player can * type in the answer. * @type {String} */ this.question = this.data.question; this.height = 1.5* TEXTDIALOGUE_HEIGHT; this.width = 1.3 * TEXTDIALOGUE_WIDTH; this.createDialogue('Nachricht von Mike'); let questionElem = new Phaser.GameObjects.Text(this, -270,-190, 'Hi, \\nich habe letzten Monat, parallel zu dir, versucht eine Lösung zu \\nfinden, aber ich bin mir nicht sicher, ob sie gut ist. \\nKannst du mir Feedback geben?', {fontSize:14,color: '#000'}).setOrigin(0,0.5); let ownText = new Phaser.GameObjects.Text(this, -270,-140, '', {fontSize:14,color: '#000'}).setOrigin(0,0.5); // Player Values let ownProfitText = new Phaser.GameObjects.Text(this, ownText.x+150,ownText.y, 'Profit pro Möbelstück:', {fontSize:14,color: '#000'}).setOrigin(0,0.5); let priceBeds = this.createFurnitureEntry(ownProfitText.x+10,ownProfitText.y+30,'bed',0.09,this.aiData.bed.profit,true); let priceBookcases = this.createFurnitureEntry(ownProfitText.x+10,priceBeds[0].y+30,'bookcase',0.2,this.aiData.bookcase.profit,true); let priceTables = this.createFurnitureEntry(priceBeds[0].x+80,priceBeds[0].y,'table',0.03,this.aiData.table.profit,true); let priceChairs = this.createFurnitureEntry(priceBeds[0].x+80,priceBeds[0].y+30,'chair',0.12,this.aiData.chair.profit,true); let ownResourceText = new Phaser.GameObjects.Text(this, ownText.x,ownText.y, 'Material:', {fontSize:14,color: '#000'}).setOrigin(0,0.5); let woodSprite = new Phaser.GameObjects.Sprite(this, ownResourceText.x+10, ownResourceText.y+30,'wood').setScale(0.05); let wood = new Phaser.GameObjects.Text(this, woodSprite.x+20, ownResourceText.y+30, this.aiData.material.wood, {fontSize:14,color: '#000'}).setOrigin(0,0.5); let metalSprite = new Phaser.GameObjects.Sprite(this, woodSprite.x, wood.y+30,'metal').setScale(0.05); let metal = new Phaser.GameObjects.Text(this, woodSprite.x+20, wood.y+30, this.aiData.material.metal, {fontSize:14,color: '#000'}).setOrigin(0,0.5); // Optimal Values let arrowRight = new Phaser.GameObjects.Sprite(this, ownProfitText.x+200, ownText.y+45,'arrow-right').setOrigin(0.5).setScale(0.8).setTintFill('0xf0f0f0'); let optimalText = new Phaser.GameObjects.Text(this, ownProfitText.x+270,ownText.y, 'Hergestellt:', {fontSize:14,color: '#000'}).setOrigin(0,0.5); let optimalBeds = this.createFurnitureEntry(optimalText.x+10, priceBeds[0].y,'bed',0.09,this.aiData.bed.solution); let optimalBookcases = this.createFurnitureEntry(optimalText.x+10, priceBookcases[0].y,'bookcase',0.2,this.aiData.bookcase.solution); let optimalTables = this.createFurnitureEntry(optimalText.x+80, priceTables[0].y,'table',0.03,this.aiData.table.solution); let optimalChairs = this.createFurnitureEntry(optimalText.x+80, priceChairs[0].y,'chair',0.12,this.aiData.chair.solution); let questionHow = new Phaser.GameObjects.Text(this, -270,-40,'Wie gut ist meine Lösung?', {fontSize:14,color: '#000'}).setOrigin(0,0.5); let feedbackText = new Phaser.GameObjects.Text(this, ownProfitText.x, priceChairs.y+30, '', {fontSize:14,color: '#000'}).setOrigin(0,0.5); //let bad = new Phaser.GameObjects.Text(this, -240, -20, 'schlecht', {fontSize:14,color: '#000'}).setOrigin(0,0.5); //let good = new Phaser.GameObjects.Text(this, 160, -20, 'optimal', {fontSize:14,color: '#000'}).setOrigin(0,0.5); let questionWhy = new Phaser.GameObjects.Text(this, -270,30, 'Was habe ich richtig/falsch gemacht?', {fontSize:14,color: '#000'}).setOrigin(0,0.5); this.panel.add(questionElem); //this.panel.add(bad); //this.panel.add(good); this.panel.add(ownText); this.panel.add([woodSprite,metalSprite,arrowRight]); this.panel.add(ownProfitText); this.panel.add(priceChairs); this.panel.add(priceTables); this.panel.add(priceBookcases); this.panel.add(priceBeds); this.panel.add(ownResourceText); this.panel.add(wood); this.panel.add(metal); this.panel.add(optimalText); this.panel.add(optimalBeds); this.panel.add(optimalBookcases); this.panel.add(optimalTables) this.panel.add(optimalChairs); this.panel.add(questionHow); this.panel.add(questionWhy); this.panel.disableCloseButton(); let sendButton = new Button(this,200,250,'button-long', 'button-long-pressed','Absenden',this.sendText,this); sendButton.setButtonScale(0.75); this.likertScale = new LikertScale({scene: this, x: 0, y: 0}); this.panel.add(this.likertScale); this.sendButton = sendButton; this.panel.add(sendButton); /** * The form util takes care of the setup of the text area. * @type {FormUtil} */ this.formUtil = new FormUtil({ scene: this }); // Set up the assesrange to be displayed at the right place //this.formUtil.scaleToGameW('asses', .3); //this.formUtil.scaleToGameH('asses',.1); //this.formUtil.placeElementAt(400,400, 'asses', true, true); //this.formUtil.disableResize('asses'); // Set up the textarea to be displayed at the right place this.formUtil.scaleToGameW('textarea', .65); this.formUtil.scaleToGameH('textarea',.25); this.formUtil.placeElementAt(400,540, 'textarea', true, true); this.formUtil.disableResize('textarea'); this.fadeIn(this.showTextArea); } showTextArea() { //this.formUtil.showTextArea('asses'); this.formUtil.showTextArea('textarea'); } /** * This function sends the text that has been typed in by the player * via the Sosci Writer. * If [ON_LOCAL_MACHINE]{@link module:Constants#ON_LOCAL_MACHINE} is set to true, * the value is just being printed. */ sendText() { //let asses = document.getElementById('asses'); let textarea = document.getElementById('textarea'); if (!this.likertScale.getValue()) { this.sendButton.showMessage(\"Bitte wähle eine der fünf Antworten.\",alert=true,10,1000); return; } if (textarea.value.length &lt; MINIMUM_TEXT_SIZE) { this.sendButton.showMessage(\"Bitte schreibe etwas mehr.\", alert=true, 10,1000); return; } if (ON_LOCAL_MACHINE) { console.log(this.likertScale.getValue()); console.log(textarea.value); } else writeAssessment(this.questionNumber, this.likertScale.getValue(),textarea.value,true); textarea.value = ''; this.formUtil.hideTextArea('textarea'); this.close(); } /** * Adjust the size of the question text. * @param {number} size the desired fontsize for the question */ setQuestionFontSize(size) { this.questionElem.setFontSize(size); } /** * Creates an image and a text element. This can be used to create entries for furniture inside the table. * @param {number} x x-position of the sprite * @param {number} y y-position of the sprite * @param {String} picture the image key of the furniture that should be displayed. * @param {number} [scale=1] the scale of the image. * @param {*} value the value that should be displayed beneath the sprite * @param {boolean} [gold=false] defines whether a money symbol should be displayed additionally. * @returns {Array} a list containing the image and the text object to be added to the scene */ createFurnitureEntry(x, y, picture, scale=1, value, gold=false) { let sprite = new Phaser.GameObjects.Sprite(this,x,y, picture).setScale(scale); let text = new Phaser.GameObjects.Text(this, sprite.x+20, y, value, {fontSize:14,color: '#000'}).setOrigin(0,0.5); if (gold) { let goldSprite = new Phaser.GameObjects.Sprite(this,text.x+25, y, 'gold').setScale(1.3); return [sprite,text,goldSprite] } return [sprite,text]; } } export default AiDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"AssesmentDialogue.js.html":{"id":"AssesmentDialogue.js.html","title":"Source: AssesmentDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: AssesmentDialogue.js import {ON_LOCAL_MACHINE, TEXTDIALOGUE_WIDTH, TEXTDIALOGUE_HEIGHT, MINIMUM_TEXT_SIZE} from './Constants.js'; import DialogueScene from './DialogueScene.js'; import FormUtil from './formUtil.js'; import Button from './Button.js'; import {writeAnswer,writeAssessment} from './SosciWriter.js'; import InteractionScene from './InteractionScene.js'; import LikertScale from './LikertScale.js'; /** * @classdesc * This class provides dialogue scene to get a user text input. * In order to create this dialogue the values required by the DialogueScene must be provided on creation. * Therefore, see {@link DialogueScene#init}. * @calss TextDialouge * In order to run this scene, it can be launched with phaser's scene plugin. * Additionaly, a title and a question text should be provided. * @example * // go to the place, where the scene should be started and insert the following line * this.scene.launch('textDialogue', {mainScene: this, title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION questionNumber: NUMBER}); * // \"this\" must be a scene, because this.scene points at the scene manager of the specific scene. * */ class AssesmentDialogue extends InteractionScene { constructor() { super('assesmentDialogue'); } create() { /** * This is the title of the dialogue. * @type {String} */ this.title = this.data.title; /** * The question number specifies in what sosci survey item the value is stored. * This is important, if there are multiple text dialogues to keep track of the different questions. * @type {number} */ this.questionNumber = this.data.questionNumber; /** * The question that is displayed to the user above the input field, where the player can * type in the answer. * @type {String} */ this.question = this.data.question; this.height = 1.3 * TEXTDIALOGUE_HEIGHT; this.width = 1.25 * TEXTDIALOGUE_WIDTH; this.createDialogue('Selbsteinschätzung'); let questionElem = new Phaser.GameObjects.Text(this, -190,-150, 'Wie gut schätzt du deine Lösung ein?', {color: \"#000\", fontSize: 18}).setOrigin(0,0.5); let questionWhy = new Phaser.GameObjects.Text(this, -190,-50,'Warum schätzt du deine Leistung so ein?', {fontSize: 18, color: \"#000\"}).setOrigin(0,0.5); this.panel.add(questionElem); //this.panel.add(bad); //this.panel.add(good); this.panel.add(questionWhy); this.panel.disableCloseButton(); let sendButton = new Button(this,90,200,'button-long', 'button-long-pressed','Absenden',this.sendText,this); sendButton.setButtonScale(0.75); this.sendButton = sendButton; this.panel.add(sendButton); this.likertScale = new LikertScale({scene: this, x: 0, y: -85}); this.panel.add(this.likertScale); /** * The form util takes care of the setup of the text area. * @type {FormUtil} */ this.formUtil = new FormUtil({ scene: this }); // Set up the assesrange to be displayed at the right place //this.formUtil.scaleToGameW('asses', .3); //this.formUtil.scaleToGameH('asses',.1); //this.formUtil.placeElementAt(400,320, 'asses', true, true); // this.formUtil.disableResize('asses'); // Set up the textarea to be displayed at the right place this.formUtil.scaleToGameW('textarea', .5); this.formUtil.scaleToGameH('textarea',.3); this.formUtil.placeElementAt(400,480, 'textarea', true, true); this.formUtil.disableResize('textarea'); this.fadeIn(this.showTextArea); } showTextArea() { //this.formUtil.showTextArea('asses'); this.formUtil.showTextArea('textarea'); } /** * This function sends the text that has been typed in by the player * via the Sosci Writer. * If [ON_LOCAL_MACHINE]{@link module:Constants#ON_LOCAL_MACHINE} is set to true, * the value is just being printed. */ sendText() { let textarea = document.getElementById('textarea'); // If the user didn't choose any response on the likert scale // we will infrom about that as a button alert. if (!this.likertScale.getValue()) { this.sendButton.showMessage(\"Bitte wähle eine der fünf Antworten.\",alert=true, 10,1000); return; } if (textarea.value.length &lt; MINIMUM_TEXT_SIZE) { this.sendButton.showMessage(\"Bitte schreibe etwas mehr.\", alert=true, 10,1000); return; } if (ON_LOCAL_MACHINE) { console.log(this.likertScale.getValue()); console.log(textarea.value); } else writeAssessment(this.questionNumber, this.likertScale.getValue(),textarea.value); textarea.value = ''; this.formUtil.hideTextArea('textarea'); this.close(); } /** * Adjust the size of the question text. * @param {number} size the desired fontsize for the question */ setQuestionFontSize(size) { this.questionElem.setFontSize(size); } } export default AssesmentDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Building.js.html":{"id":"Building.js.html","title":"Source: Building.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Building.js import EventDispatcher from './EventDispatcher.js'; import {ON_LOCAL_MACHINE} from './Constants.js'; /** * @classdesc * This class implements a superclass for implementing different buildings. * It handels renders an image of a building, takes care of the positioning * and implements a click listener. * * @class Building * @extends Phaser.GameObjects.Container * @see [Phaser.GameObjects.Container]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Container.html} * @constructor * @param {object} data an object that stores the information needed to build this class. * @param {Phaser.Scene} data.scene the scene where the management building should be built in. See [Phaser.Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html} * @param {Number} data.x the x coordinate where the building should be placed. * @param {Number} data.y the y coordinate for the building. * @param {String} data.image the image key of the building. * @param {String} data.name the name of the building. */ class Building extends Phaser.GameObjects.Container { constructor(data) { let {scene, image, x, y, name} = data; // We need the camera to scale the gameobjects with the zoom amound of the camera object. let camera = scene.cameras.main; let buildingSprite = new Phaser.GameObjects.Sprite(scene, 0/camera.zoom, 0/camera.zoom, image); buildingSprite.setScale(1.3); let tooltip = new Phaser.GameObjects.Sprite(scene,buildingSprite.x,buildingSprite.y-buildingSprite.height,'tooltip').setScale(1.5); tooltip.displayWidth = 200; tooltip.alpha = 0; let tooltipText = new Phaser.GameObjects.Text(scene, tooltip.x,tooltip.y, name,{fontSize:22,color: '#fff'}).setOrigin(0.5,0.5); tooltipText.alpha = 0; let sign = new Phaser.GameObjects.Sprite(scene,0,0,''); sign.alpha = 0; super(scene, x / camera.zoom, y / camera.zoom, [sign,tooltip, tooltipText, buildingSprite]); /** * The name of the Building. This is also the name that is displayed in the [tooltip]{@link Building#tooltip}. * @type {String} */ this.name = name; /** * A sign that can be placed beneath a building */ this.sign = sign; /** * The sprite that renders the building. See [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html}. * * @type {Phaser.GameObjects.Sprite} */ this.buildingSprite = buildingSprite; /** * The Scene where the building should be rendered in. * In this case this is usually the {@link MainScene}. * @see [Phaser.Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html} * @type {Phaser.Scene} */ this.scene = scene; /** * This is the tooltip object that is triggered if the cursor is on the building. * * @type {Phaser.GameObjects.Sprite} */ this.tooltip = tooltip; /** * The text that should be inside the tooltip. * It contains the [name]{@link Building#name} of the building. * * @type {Phaser.GameObjects.BitmapText} */ this.tooltipText = tooltipText; /** * The Emitter is an instance of the EventDispatcher and is used to record the actions * performed by the user. In the case of buildings, we always want to record which building * has been opened by the player. * @type {EventDispatcher} */ this.emitter = EventDispatcher.getInstance(); this.setSize(buildingSprite.width, buildingSprite.height); /** * The image [sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} of the building * @type {Phaser.GameObjects.Sprite} */ this.image = image; // Making the building clickable this.setInteractive(); this.addPointerListeners(); // Ensure that the building moves with the same velocity as the camera. this.setScrollFactor(camera.zoom); // Add the building to the scene. this.scene.add.existing(this); if (this.scene.tutorialPhase) this.disableInteractive(); } /** * Adds a listener that reacts on a click on the object. * This is used for triggering a dialogue if a specific building is clicked. * The function to initiate the individual dialogue must be passed by the instance. * @param {function} func the function that should be triggered, after the object as been clicked. */ addClickListener(func) { this.on('pointerdown', function(pointer){ this.once('pointerup', () =&gt; { this.emitter.emit('buildingClicked', this.name); }); this.once('pointerup', func); }); } /** * Adds pointer events to toggle the display of the [tooltip]{@link Building#tooltip} * if the pointer is hovering over a building. * It will fade in the tooltip if the cursor is above and fade it out if the cursor leaves the * building. * */ addPointerListeners() { this.on('pointerover', function() { this.scene.tweens.add({ targets: [this.tooltip, this.tooltipText], alpha: 0.9, duration: 200 }); }); this.on('pointerout', function() { this.scene.tweens.add({ targets: [this.tooltip, this.tooltipText], alpha: 0, duration: 500 }); }); } /** * Add a flash effect to the building to highlight it for the tutorial. */ addFlashEffect() { this.buildingSprite.setTint(0xffff00); this.flashEffect = this.scene.tweens.add({ targets: this.buildingSprite, scale: 1.5, ease: 'Cubic.easeOut', duration: 300, loop: -1, yoyo: true }); } /** * Stop the flash effect. */ stopFlashEffect() { this.buildingSprite.clearTint(); this.flashEffect.loop = 0 this.flashEffect.loopCounter = 0; } } export default Building; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Button.js.html":{"id":"Button.js.html","title":"Source: Button.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Button.js /** * @classdesc * This class represents a button that can be used in the game. * It provides a click animation as well as a text animation to show messages on click. * It extends a Phaser container, consider the [Phaser API page]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Container.html} for more information. * * @class Button * @extends Phaser.GameObjects.Container * @constructor * * @param {Phaser.Scene} scene The scene to display the button in. * @param {Number} x the x coordinate of the button. * @param {Number} y the y coordinate of the button. * @param {String} buttonTexture the texture of the button. * @param {String} buttonTexturePressed The Picture of the button if it is pressed. * @param {String} buttonImage the image key pointing to the image that should be shown inside the button. If no image has been * found under this key, a text element is created instead with the provided from buttonImage. * @param {Function} callback the function that should be called if * the button has been clicked. * @param {Object} context the context where the callback function should act inside. * @param {String} [tooltipText] if a tooltipText is provided it gets displayed in a tooltip above the button, if the pointer * hovers over it. If not provided, no tooltip will be shown. * */ class Button extends Phaser.GameObjects.Container { constructor(scene, x ,y, buttonTexture, buttonTexturePressed, buttonImage, callback, context ,tooltipText=undefined) { let texture = new Phaser.GameObjects.Sprite(scene,0 ,0, buttonTexture); let image = new Phaser.GameObjects.Sprite(scene,0 ,0, buttonImage); if (image.texture.key === '__MISSING') { // If no image has been found, create a text. image = new Phaser.GameObjects.Text(scene,0,0, buttonImage, {fontSize:17,color: '#fff'}).setOrigin(0.5); } let initImageY = image.y; // is used for click animation. // Pack the resources above inside a container super(scene, x, y, [texture,image]); /** * The scene where the button should be placed in. * * @type {Phaser.Scene} */ this.scene = scene; /** * The X-Coordinate for the message that is animated after button click. * By default the message emerges from the middle of the button. * * @type {Number} * @default 0 */ this.messageOffsetX = 0; /** * The callback function, that will be called after button click. * * @type {Function} */ this.callback = callback; /** * The context to run the callback function in. * It should contain all elements that the callback function needs. * Often the context is just the calling class instance. * * @type {Object} * @example * // callback function * button.callback = function() * { * console.log('Hello ' + this.str); * } * // This function can be run and in the context we can specify the str element. * // If the context was like this * button.context = {str: 'World'}; * button.callback() // ==&gt; 'Hello World' * */ this.context = context; /** * The texture of the button. * This can be seen as the background image of the button. * This is a string, pointing to a key inside the texture manager of the phaser engine. * Hence, it is the string that is defined in the {@link Preloader} class from the image path. * * @type {String} * */ this.texture = texture; /** * The image that will be located inside the button. * This is a string that can be defined in the {@link Preloader} class. * * @type {String} */ this.image = image; // We need to set a size to the conatiner in order to ensure the whole button is clickable this.setSize(texture.width, texture.height); // enabling input options and listeners on the button this.texture.setInteractive(); if (tooltipText) this.setTooltip(tooltipText); // If pressing the mouse down on the button this.texture.on('pointerdown', function() { // Make the button appear pressed. // It is accessed via the list of the container, so we must // ensure that we are targeting the button texture // we use 0, because we have initialized the button above with the // buttonTexture first, so it will be our first element, instead of // the image. texture.setTexture(buttonTexturePressed); // Move the image on the button a bit down to create the illusion // that the button has been pressed. image.y += 3; // If the mouse button is released over the button // This call must be listened only once, otherwise it will stack up its triggers after several clicks. this.texture.once('pointerup', this.callback, this.context); // If the mouse button is released anywhere. // This ensures that the texture is always reset, // even if the mouse is no longer over the button. this.scene.input.once('pointerup', function() { // reset the textures and place the image to its original position texture.setTexture(buttonTexture); image.y = initImageY; }); }, this); } /** * Scale the button texture. * This does not affect the image inside the button. * You can call the {@link Button#setImageScale} function for this sake. * @param {Number} scale the target scale of the button texture. */ setButtonScale(scale) { this.texture.setScale(scale); } /** * Scale the image inside the button. Does not affect the button scale. * @param {Number} scale the target scale of the image. */ setImageScale(scale) { this.image.setScale(scale); } /** * This function displays a message at the location of the button. * It can be used to inform the player if an item has been built successfully. * This function automatically invokes an animation of the text, gliding to the top * and triggering the closeMessage function to fade out the text object. * @param {String} text The text that should be displayed to the user. * @param {boolean} [alert=false] A boolean. By default it is false causing the text to be black. * If set to true, the text is red. In the game this is used to inform the player about an error like * missing material. * @param {number} [distance=30] specifies how far the text should travel to the top if shown. * @param {number} [duration=0] specifies how long the message should be displayed * */ showMessage(text, alert=false, distance=30, duration=500) { let message = new Phaser.GameObjects.Text(this.scene, this.messageOffsetX,0, '', {fontSize:17,color: '#000'}).setOrigin(0.5,0.5); if(alert){message.setColor('#cf3434');} message.alpha = 0; message.text = text; this.add(message); this.scene.tweens.add( { targets: [message], alpha: 1, y: message.y -distance, duration: duration/1.6, ease: Phaser.Math.Easing.Sine.Out, onCompleteScope: this, onComplete: function() { this.closeMessage(message, duration); } }); } /** * This method closes the given message by animating its fadeout. * @param {Object} message the text object to be closed * @param {Number} duration the duration of the fade-out animation. */ closeMessage(message, duration) { this.scene.tweens.add( { targets: [message], alpha: 0, y: message.y - 30, duration: duration, ease: Phaser.Math.Easing.Sine.In, onComplete: function(){message.destroy();} // delete the message object }); } /** * Sets the same origin for the button texture and the button image. * The origin indicates the offset of the game object from the given position * * @param {Number} x The origin value on the x axis. * @param {Number} [y=x] The origin value for the y axis * @example button.setOrigin(0.5) // Positions the middle of the sprite at its given x-and y coordinate. */ setOrigin(x, y) { if (!y) y = x; this.texture.setOrigin(x,y); this.image.setOrigin(x,y); } /** * Specifies the callback function to change it later. * @param {function} func the callback function which will be triggered * after a click. */ setCallbackFunction(func) { this.callback = func; } /** * Specify the context for the callback function * @param {Object} context the context as an object containing a scene, a button object and an item (part) see {@link Button#context}. */ setContext(context) { this.context = context; } /** * This function adds a tooltip to the button, that will be displayed, if the cursor hovers over it. * @param {String} text The text that should be displayed inside the tooltip. */ setTooltip(text) { this.tooltip = new Phaser.GameObjects.Sprite(this.scene, 0, -this.texture.displayHeight, 'tooltip').setOrigin(0.5, 0.7).setScale(1.5); this.tooltipText = new Phaser.GameObjects.Text(this.scene, this.tooltip.x, this.tooltip.y, text, {fontSize:17,color: '#fff'}).setOrigin(0.5,1); this.tooltip.alpha = 0; this.tooltipText.alpha = 0; this.add([this.tooltip, this.tooltipText]); this.texture.on('pointerover', function() { this.scene.tweens.add( { targets: [this.tooltip, this.tooltipText], alpha: 1, duration: 200 } ); }, this); this.texture.on('pointerout', function() { this.scene.tweens.add({ targets: [this.tooltip, this.tooltipText], alpha: 0, duration: 500 }); },this); } } export default Button; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Diagram.js.html":{"id":"Diagram.js.html","title":"Source: Diagram.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Diagram.js import * as Constants from './Constants.js'; /** * @classdesc * Implements a diagram that displays a comparison of profit on the y-axix and the month on the x-axis. * It is used to compare the player's and the optimal profit during the game. It is displayed at a [MarketDialogue]{@link MarketDialogue} as well as * in the {@link NewsScene}. * * @constructor * @param {object} data the data object that is used to create a diagram. * @param {Phaser.Scene} data.scene the scene in which the diagram should be drawn. * @param {Array} data.lpProfits a list of the optimal profits for every month. * @param {Array} data.playerProfits a list of the player's profits for every month. * @param {number} data.month the number of months. This is used to scale the x-axis. * @param {number} data.x the x position for the starting point of the diagram. * @param {number} data.y the y position for the diagram. * @param {number} [data.height] the height of the diagram. * @param {number} [data.width] the width of the diagram. */ class Diagram extends Phaser.GameObjects.Container{ constructor(data){ let {scene, lpProfits, playerProfits, months, x,y, height, width} = data; let graphics = new Phaser.GameObjects.Graphics(scene); super(scene, x,y,[graphics]); /** * The scene where this diagram is drawn. * @type {Phaser.Scene} */ this.scene = scene; /** * The x bottom left starting point of the diagram. This is initially set via the x value given by the constructor. * * @type {number} */ this.startX = x; /** * The y starting point of the diagram. * * @type {number} */ this.startY = y; /** * This is an instance of the Phaser graphics and is used to draw inside a scene. * @type {Phaser.GameObjects.Graphics} * @see [Phaser.GameObjects.Graphics]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Graphics.html} */ this.graphics = graphics; /** * The list of optimal profits for every month. The length of this array is used to * define for how many months the graph is displayed. As we only want to display the values until the * current month, the length of this array always corresponds to the actual month. * @type {Array} */ this.lpProfits = lpProfits; /** * The profits of the player for every month. The length of this array is used to * define for how many months the graph is displayed. As we only want to display the values until the * current month, the length of this array always corresponds to the actual month. * @type {Array} */ this.playerProfits = playerProfits; /** * This value defines the maximum number of months for which the diagram should be scaled. * It also has impact to the labeling and scaling of the x-axis. This is normally set to 12, * to always display the x-axis with 12 steps. * @type {number} */ this.maxMonths = months; /** * This is maximum profit that can be reached for a month in the game. * It is used to scale the y-axis of the diagram, causing the maximum profit to be the highest point. */ this.maxProfit = Math.max(...this.lpProfits); if (height &amp;&amp; width) { this.diagramHeight = height; this.diagramWidth = width; } else { /** * The height of the diagram. If the height has not been specified inside the constructor, * the default value [DIAGRAM_HEIGHT]{@link module:Constants#DIAGRAM_HEIGHT} is used. */ this.diagramHeight = Constants.DIAGRAM_HEIGHT; /** * The width of the diagram. If the width has not been specified inside the constructor, * the default value [DIAGRAM_WIDTH]{@link module:Constants#DIAGRAM_WIDTH} is used. */ this.diagramWidth = Constants.DIAGRAM_WIDTH; } // Draw the elements of the diagram this.addBorder(); this.addDescription(); this.addOptimalProfit(); this.addPlayerProfit(); } /** * Adds a border for the diagram, by drawing a rectangle taking the height and width into account. */ addBorder(){ // Define additional values to draw the diagram this.maxY = this.startY-this.diagramHeight; this.maxX = this.startX+this.diagramWidth; // Drawing the border this.graphics.lineStyle(1.5, 0x000000); this.graphics.beginPath(); this.graphics.moveTo(this.startX,this.startY); this.graphics.lineTo(this.startX,this.maxY); this.graphics.lineTo(this.maxX, this.maxY); this.graphics.lineTo(this.maxX, this.startY); this.graphics.closePath(); this.graphics.strokePath(); this.modelColor = 0x1a75ff; this.playerColor = 0xffa31a; } /** * Adds the profit of the player to the diagram */ addPlayerProfit(){ this.graphics.lineStyle(2, this.playerColor); this.graphics.beginPath(); this.graphics.moveTo(this.startX,this.startY); for (let i = 0; i &lt; this.playerProfits.length-1; i++){ this.graphics.lineTo(this.scaleWidth(i+1), this.scaleHeight(this.playerProfits[i])); } this.graphics.strokePath(); } /** * Adds the profits from the linear model for each month * to the diagram. */ addOptimalProfit(){ this.graphics.lineStyle(2, this.modelColor); this.graphics.beginPath(); this.graphics.moveTo(this.startX,this.startY); for (let i = 0; i &lt; this.playerProfits.length-1; i++){ this.graphics.lineTo(this.scaleWidth(i+1), this.scaleHeight(this.lpProfits[i])); } this.graphics.strokePath(); } /** * This function scales a profit value relative to the maximum value * and the height of the diagram. * @param {int} value The profit for a given month * @returns the scaled value to be added as y coordinate to the diagram. */ scaleHeight(value){ return Number(this.startY-(value*(this.diagramHeight/this.maxProfit))); } /** * This function scales the given month relative to the maximum * amount of months and the width of the diagram. * @param {int} value a month starting at 1. * @returns the scaled value to be added as x coordinate to the diagram. */ scaleWidth(value){ return Number((value*(this.diagramWidth/this.maxMonths))+this.startX); } /** * Adds the description for the axis */ addDescription(){ this.add(new Phaser.GameObjects.Text(this.scene, this.startX, this.startY-(Constants.DIAGRAM_HEIGHT/2), 'Profit', {fontSize:14,color: '#000'}).setOrigin(0.5,0.9).setRotation(-1.570796)); this.add(new Phaser.GameObjects.Text(this.scene, this.startX, this.maxY, this.maxProfit, {fontSize:13,color: '#000'}).setOrigin(1,0.5)); this.add(new Phaser.GameObjects.Text(this.scene, this.startX, this.startY, 0, {fontSize:13,color: '#000'})); for (let i = 0; i &lt;= this.maxMonths; i++){ this.add(new Phaser.GameObjects.Text(this.scene, this.scaleWidth(i), this.startY, i, {fontSize:13,color: '#000'})); } this.add(new Phaser.GameObjects.Text(this.scene, this.startX+(Constants.DIAGRAM_WIDTH/2), this.maxY, 'Monat', {fontSize:14,color: '#000'}).setOrigin(0,1)); this.graphics.beginPath(); this.graphics.lineStyle(1, this.modelColor); this.graphics.moveTo(this.maxX+10,this.maxY); this.graphics.lineTo(this.maxX+20,this.maxY); this.graphics.strokePath(); this.add(new Phaser.GameObjects.Text(this.scene, this.maxX+20, this.maxY, 'Opt.', {fontSize:14,color: '#000'})); this.graphics.beginPath(); this.graphics.lineStyle(1, this.playerColor); this.graphics.moveTo(this.maxX+10,this.maxY+20); this.graphics.lineTo(this.maxX+20,this.maxY+20); this.graphics.strokePath(); this.add(new Phaser.GameObjects.Text(this.scene, this.maxX+20, this.maxY+20, 'Du', {fontSize:14,color: '#000'})); } } export default Diagram; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"DialogueScene.js.html":{"id":"DialogueScene.js.html","title":"Source: DialogueScene.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: DialogueScene.js import Panel from './Panel.js'; import EventDispatcher from './EventDispatcher.js'; import {ON_LOCAL_MACHINE} from './Constants.js'; /** * @classdesc * This class implements a wrapper for dialogues. Such a dialogue usually consists of a frame where contents can be placed and a * close button. This class also handels animations and appearance of the dialogue window and my be extended by * every dialogue. As an example: this class is extended for every dialogue that is launched if a building is clicked. * @class DialogueScene * @extends Phaser.Scene * @see [Phaser.Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html} * @constructor * @param {String} sceneName The scene name is defined at creation of the scene and is used to find, launch or close the scene by the [SceneManager]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scenes.SceneManager.html}. * */ class DialogueScene extends Phaser.Scene { constructor(sceneName) { super(sceneName); this.sceneName = sceneName; } /** * The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. [launch]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scenes.ScenePlugin.html#launch__anchor} * [start]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scenes.ScenePlugin.html#start__anchor}). In this case the additional data is used to build a basic [panel]{@link DialogueScene#panel} that can be adopted by every class that is extending * this class. * @param {object} data the data object contains relevant data for this scene as well as additional data that can be used * by the child scenes of this DialogueScene. See {@DialogueScene#data}. * @param {MainScene} data.mainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. * @param {number} data.height The height of the dialogue. * @param {number} data.width The width of the dialogue. */ init(data){ /** * The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. * @type {MainScene} */ this.mainScene = data.mainScene; /** * The height of the dialogue. * @type {number} */ this.height = data.height; /** * The width of the dialogue. * @type {number} */ this.width = data.width; /** * Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way * the scene can be used more flexible. As an example: the {@link WorkshopDialogue} maintains an instance of the workshop, * to read the status and schedule building orders. The workshop can be passed as an entry in this data object. * @type {object} */ this.data = data; /** * The EventDispatcher to monitor that a dialogue has been closed by the player * @type{EventDispatcher} */ this.emitter = EventDispatcher.getInstance(); } /** * This function creates a closing effect, animating the scale of the [panel]{@link DialogueScene#panel} to zero * within 150 milliseconds. * This function also stops the scene that is calling the function and enables the inputs of the main scene. */ close() { this.mainScene.input.enabled = true; this.scene.manager.keys.ui.input.enabled = true; this.emitter.emit('dialogueClosed', this.sceneName); this.tweens.add( { targets: this.panel, scale: 0, duration: 150, callbackScope: this, onComplete: function(){ this.scene.stop(this.sceneName); this.events.emit(\"dialogueClosed\"); } }); } /** * Creates a [panel]{@link DialogueScene#panel} that can be filled with content by every class inheriting from this class. * Note that the panel initially has a scale of zero causing the object to be invisible. The function [fadeIn]{@link DialogueScene#fadeIn} * can be used to make it appear. Alternatively the scale of the panel can be set to 1 manually. * This function also disables every input for the main scene, which means that the player cannot open new buildings or navigate through the map * as long as a dialogue is opened. The [close]{@link DialogueScene#close} function re-enables the inputs of the main scene. * @param {string} header the headline which will be displayed on top of the panel. */ createDialogue(header='Header') { // disabling the inputs of the main scene. this.mainScene.input.enabled = false; /** * The panel which renders the frame and the headline. * @type {Panel} */ this.panel = new Panel( { scene: this, x: 400, y: 300, width: this.width, height: this.height, header: header }); } /** * This function is used to animate the appearance of the [panel]{@link DialogueScene#panel}, by animating its scale to 100% * within 150 milliseconds. * @param {function} [completeCallback] a function that is executed once the animation has finished. */ fadeIn(completeCallback) { this.tweens.add( { targets: this.panel, scale: 1, duration: 150, onComplete: completeCallback, onCompleteScope: this }); } } export default DialogueScene; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"DialogueSchedule.js.html":{"id":"DialogueSchedule.js.html","title":"Source: DialogueSchedule.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: DialogueSchedule.js import DialogueScene from './DialogueScene.js' /** * @classdesc * This class takes care of the dialogues that appear during the game. * Dialogues inside this structure are displayed after each other to prevent * dialogues from appearing at the same time. * The dialogues that are added to the scheduler are organized as a list, that will be * worked off item per item. * @class DialogueSchedule * @constructor * @param {Phaser.Scenes.ScenePlugin} scenePlugin the plugin that is needed to launch the dialogues. */ class DialogueSchedule { constructor(scenePlugin) { /** * The scene plugin that is used to run the dialogues. * */ this.scenePlugin = scenePlugin; /** * An array of dialogues that are scheduled. They will be launched in its order. * @type {object[]} */ this.dialogues = []; /** * The current dialogue that is opened at the moment. */ this.currentDialogue; } /** * Add a dialogue to the scheduler. The dialogue will be added to the end * of the list. * @param {string} key the key for the sceneManager * @param {object} data the data that is needed to create the scene. See {@link DialogueScene}. * @param {boolean} [addToFront=false] if set to true, the dialogue will be added to the front of the list * instead of the end. */ addDialogue(key, data, addToFront=false) { if (this.scenePlugin.manager.keys[key] instanceof DialogueScene) { if (addToFront) { this.dialogues.unshift({key:key, data:data}); } else { this.dialogues.push({key: key, data:data}); } } else throw \"The given dialogue must inherit from \\\"DialogueScene\\\"!\"; } /** * Starts the the next dialogue from the list and removes the element. */ startNextDialogue() { if (this.dialogues.length &gt; 0) { let dialogue = this.dialogues.shift(); this.scenePlugin.launch(dialogue.key, dialogue.data); this.currentDialogue = this.scenePlugin.get(dialogue.key); this.currentDialogue.events.once('dialogueClosed', () =&gt; { this.startNextDialogue(); }, this); } } /** * Runs all scheduled dialogues until the [dialogues list]{@link DialogueSchedule#dialogues} is empty. */ run() { this.startNextDialogue(); } } export default DialogueSchedule; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"EventDispatcher.js.html":{"id":"EventDispatcher.js.html","title":"Source: EventDispatcher.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: EventDispatcher.js import {ON_LOCAL_MACHINE, ACTION_MAP} from './Constants.js'; import {readTextFile} from './glpkUtility.js'; let instance = null; /** * @classdesc * This class implements a global event emitter to track the behavior of * a player by recording the clicks that are made along with timestamps. */ class EventDispatcher extends Phaser.Events.EventEmitter { constructor() { super(); this.activateListeners(); this.mainScene; /** * A list of times where an event happened the function activateListeners listens to. * The format is in seconds and should be stored together with the corresponding actions. * @type {number[]} */ this.timestamps = []; /** * A list of actions that have been taken. The index is the same as for * [timestamps]{@link EventDispatcher#timestamps}, action as index i has been performed * at timestamp i. */ this.actions = []; /** * Allows to keep track of the month in which action have been performed */ this.months = []; let actionMap; readTextFile(ACTION_MAP, (text) =&gt; { actionMap = text; }); this.action_map = JSON.parse(actionMap); } /** * Initiate listeners for the click events that * should be recorded. */ activateListeners() { this.on('buildingClicked', (building) =&gt; { this.logAction(this.getShortForm('opened '+building)); }); this.on('dialogueClosed', (dialogue) =&gt; { this.logAction(this.getShortForm('closed '+dialogue)); }); this.on('monthSkipped', () =&gt; { this.logAction(this.getShortForm('skipped to next month')); }); // Record when player tries to produce an item. If it can be afforded, just // record what has been produced. Else also provide the reason why this can't be produced. this.on('itemButtonClicked', (itemName, reason) =&gt; { if (!reason) { this.logAction(this.getShortForm('clicked on produce button: '+ itemName+' - success.')); } else this.logAction(this.getShortForm('failed to produce '+ itemName + '. Reason: '+reason)); }); this.on('openedPartsDisplay', (itemName) =&gt; { this.logAction(this.getShortForm('looked up parts for '+ itemName + '.')); }); this.on('toggledAudio', (audioSetting) =&gt; { if(!audioSetting) { this.logAction(this.getShortForm(\"sound muted\")); }else this.logAction(this.getShortForm(\"sound activated\")); }); } /** * Log an action. This function will add the message that describes the action that has been recorded * to the [actions list]{@link EventDispatcher#actions}. * If ON_LOCAL_MACHINE is false, the timestamp will also be added. * @param {string} action the text that describes what action the player has done. */ logAction(action) { if(this.mainScene.tutorialPhase) return; this.actions.push(action); if (!ON_LOCAL_MACHINE) this.logCurrentTime(); if (this.mainScene.month.value != undefined) this.months.push(this.mainScene.month.value+1); else this.months.push(12); } /** * Get the current time and append it to [timestamps]{@link EventDispatcher#timestamps}. */ logCurrentTime() { let timestamp = document.getElementById('TI01_01').value; this.timestamps.push(timestamp); } /** * Returns the instance of the EventDispatcher if any. If not, * a new instance will be created. If the EventDispatcher should be used, * make sure to call this method like shown in the example. * @returns {EventDispatcher} the event dispatcher that handels global events. * @example * // at an arbitrary point in the game * this.emitter = EventDispatcher.getInstance(); * // Then use it, for example by emitting an event: * this.emitter.emit(\"myEvent\", data); */ static getInstance() { if (instance == null) { instance = new EventDispatcher(); } return instance; } /** * Returns the actions performed by a player along with the timestamps as a list of * tuples. (As a String). It can be parsed in python via the ast.literal_eval function. * @returns {string} a string in the following fashion '[(action, timestamp), (acton,timestamp),...]'. */ getActions() { // Check if we have recorded timestamps. If not, the project does not run in SoSciSurvey. if (this.timestamps.length &lt; this.actions.length) { throw \"No Timestamps available! Make sure to run the project in SoSciSurvey.\"; } let str = '['; for (let i = 0; i&lt; this.actions.length; i++) { // Build a tuple by hand and add it to the string if (i === this.actions.length-1) str = str.concat(\"('\"+this.actions[i]+\"',\"+this.timestamps[i]+\",\"+this.months[i]+\")\"); else str = str.concat(\"('\"+this.actions[i]+\"',\"+this.timestamps[i]+\",\"+this.months[i]+\"),\"); } str = str.concat(']'); return str; } /** * Add the MainScene to the event dispatcher in order to * access the current month. * @param {MainScene} mainScene */ setMainScene(mainScene) { this.mainScene = mainScene; } /** * Returns the key corresponding to the given value of the action map. * @param {String} value the value that is used to get the corresponding key. * @returns {String} the key, representing the short form of the value. */ getShortForm(value) { return Object.keys(this.action_map).find(key =&gt; this.action_map[key] === value); } } export default EventDispatcher; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"FeedbackDialogue.js.html":{"id":"FeedbackDialogue.js.html","title":"Source: FeedbackDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: FeedbackDialogue.js import {ON_LOCAL_MACHINE, TEXTDIALOGUE_WIDTH, TEXTDIALOGUE_HEIGHT} from './Constants.js'; import DialogueScene from './DialogueScene.js'; import FormUtil from './formUtil.js'; import Button from './Button.js'; import {writeAnswer} from './SosciWriter.js'; import FeedbackSummary from \"./FeedbackSummary.js\"; import {submit} from './SosciWriter.js'; import InteractionScene from './InteractionScene.js'; /** * @classdesc * This Scene acts as a final summary for the player after he or she finishes the last month. * It will start a summary similar to a [MarketDialogue]{@link MarketDialogue} with the exception that the * values are summed up for the entire year. Furthermore this scene cannot be closed but it ends the game * and goes to the next page after ten seconds if the game runs on Soscisurvey and [ON_LOCAL_MACHINE]{@link module:Constants#ON_LOCAL_MACHINE} is set to false. * * @class FinalSummary * @extends DialogueScene */ class FeedbackDialogue extends InteractionScene { constructor() { super('feedbackDialogue'); } /** * Creates the dialogues and all related game objects that are required in this scene. * This function runs automatically after the scene has been started. */ create() { /** * The background sprite. It is a black, slightly transparent rectangle, that is used to darken the * background. * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.background = new Phaser.GameObjects.Sprite(this, 0,0,'shadow-background').setScale(9); // First the background is set to fully transparent. We will animate this value later // to create a \"fade in\" effect. this.background.alpha = 0; // adding the background to this scene. this.add.existing(this.background); // Create the dialogue for the final year. this.createDialogue('Feedback von Anna'); this.question = ''; this.height = 1.25 * TEXTDIALOGUE_HEIGHT; this.width = TEXTDIALOGUE_WIDTH; this.renderQuestion(); this.panel.disableCloseButton(); let sendButton = new Button(this,90,130,'button-long', 'button-long-pressed','Danke',this.close,this); sendButton.setButtonScale(0.75); this.panel.add(sendButton); // we do not want the player to be able to close this window, since the redirection should // happen automatically this.panel.disableCloseButton(); /** * The a summary container that is used to display the profits of the player and the optimal * solution in a clear manner. The [setFinalValues]{@link ProfitSummary#setFinalValues} function is used * to obtain the values for the entire year. * * @type {ProfitSummary} */ this.summary = new FeedbackSummary({ scene: this, x: 0, y: 0, lpSolution: this.mainScene.lpSolution, player: this.mainScene.player, month: this.mainScene.month.value } ); // manipulate the summary scene to show the summed values. //this.summary.setFinalValues(); // add the summary containeer to the panel this.panel.add(this.summary); // animate the background from alpha = 0 to alpha = 1 in one second this.tweens.add( { targets: this.background, alpha: 1, duration: 1000 } ); // fade in the dialogue. this.fadeIn(); } /** * Displays the quesiton on the dialogue. */ renderQuestion() { this.questionElem = new Phaser.GameObjects.BitmapText(this.mainScene, 0,-this.height/2+90, 'black_font', this.question, 11, Phaser.GameObjects.BitmapText.ALIGN_LEFT).setOrigin(0.5); this.panel.add(this.questionElem); } /** * Adjust the size of the question text. * @param {number} size the desired fontsize for the question */ setQuestionFontSize(size) { this.questionElem.setFontSize(size); } } export default FeedbackDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"FinalSummary.js.html":{"id":"FinalSummary.js.html","title":"Source: FinalSummary.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: FinalSummary.js import { MONTHS, ON_LOCAL_MACHINE } from './Constants.js'; import InteractionScene from \"./InteractionScene.js\"; import ProfitSummary from \"./ProfitSummary.js\"; import {submit, writeLog} from './SosciWriter.js'; /** * @classdesc * This Scene acts as a final summary for the player after he or she finishes the last month. * It will start a summary similar to a [MarketDialogue]{@link MarketDialogue} with the exception that the * values are summed up for the entire year. Furthermore this scene cannot be closed but it ends the game * and goes to the next page after ten seconds if the game runs on Soscisurvey and [ON_LOCAL_MACHINE]{@link module:Constants#ON_LOCAL_MACHINE} is set to false. * * @class FinalSummary * @extends DialogueScene */ class FinalSummary extends InteractionScene { constructor() { super('finalSummary'); } /** * Creates the dialogues and all related game objects that are required in this scene. * This function runs automatically after the scene has been started. */ create() { /** * The background sprite. It is a black, slightly transparent rectangle, that is used to darken the * background. * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.background = new Phaser.GameObjects.Sprite(this, 0,0,'shadow-background').setScale(9); // First the background is set to fully transparent. We will animate this value later // to create a \"fade in\" effect. this.background.alpha = 0; // adding the background to this scene. this.add.existing(this.background); // Create the dialogue for the final year. this.createDialogue('Jahr beendet!'); // we do not want the player to be able to close this window, since the redirection should // happen automatically this.panel.disableCloseButton(); /** * The a summary container that is used to display the profits of the player and the optimal * solution in a clear manner. The [setFinalValues]{@link ProfitSummary#setFinalValues} function is used * to obtain the values for the entire year. * * @type {ProfitSummary} */ this.summary = new ProfitSummary( { scene: this, x: 0, y: 0, lpSolution: this.mainScene.lpSolution, player: this.mainScene.player, month: MONTHS } ); // manipulate the summary scene to show the summed values. this.summary.setFinalValues(); // add the summary containeer to the panel this.panel.add(this.summary); // animate the background from alpha = 0 to alpha = 1 in one second this.tweens.add( { targets: this.background, alpha: 1, duration: 1000 } ); // fade in the dialogue. this.fadeIn(); // Adding a timer to submit the values in the end and // close the game. if (!ON_LOCAL_MACHINE) { this.continueText = new Phaser.GameObjects.BitmapText(this, 0,-220,'white_font', '', 16,Phaser.GameObjects.BitmapText.ALIGN).setOrigin(0.5); this.panel.add(this.continueText); this.endTimer = this.time.addEvent({ delay: 10000, callback: this.end, callbackScope: this }); } } /** * This function is an infinite loop that updates the seconds that are left until the values are sent * to Soscisurvey. */ update() { if (this.continueText) { this.continueText.text = 'Weiter in: ' + Math.ceil((this.endTimer.delay - this.endTimer.elapsed)/1000); } } end() { this.close(); writeLog(this.mainScene.eventEmitter.getActions()); submit(); } } export default FinalSummary; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"formUtil.js.html":{"id":"formUtil.js.html","title":"Source: formUtil.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: formUtil.js /** * A class to nest html form elements into the game. * @author William Clarkson ({@link https://williamclarkson.net/}) */ class FormUtil { constructor(config) { //super(); this.scene = config.scene; //get the game height and width this.gameWidth=this.scene.game.config.width; this.gameHeight=this.scene.game.config.height; } scaleToGameW(elName, per) { var el = document.getElementById(elName); var w = this.gameWidth * per; el.style.width = w + \"px\"; } scaleToGameH(elName, per) { var el = document.getElementById(elName); var h = this.gameHeight * per; el.style.height = h + \"px\"; } placeElementAt(x,y, elName, centerX = true, centerY = false) { //get the position from the grid //var pos = this.alignGrid.getPosByIndex(index); //extract to local vars //var x = pos.x; //var y = pos.y; //get the element var el = document.getElementById(elName); //set the position to absolute el.style.position = \"absolute\"; //get the width of the element var w = el.style.width; //convert to a number w = this.toNum(w); // // //center horizontal in square if needed if (centerX == true) { x -= w / 2; } // //get the height // var h = el.style.height; //convert to a number h = this.toNum(h); // //center verticaly in square if needed // if (centerY == true) { y -= h / 2; } //set the positions el.style.top = y + \"px\"; el.style.left = x + \"px\"; } toNum(s) { s = s.replace(\"px\", \"\"); s = parseInt(s); return s; } addChangeCallback(elName, fun, scope = null) { var el = document.getElementById(elName); if (scope == null) { el.onchange = fun; } else { el.onchange = fun.bind(scope); } } getTextAreaValue(elName) { var el = document.getElementById(elName); return el.value; } /** * Prevent the text area from being resized. * @author Eric Frodl * @param {String} elName the id of the textarea. */ disableResize(elName) { let el = document.getElementById(elName); el.style.resize = 'none'; } /** * Sets the provided textarea to visible * @author Eric Frodl * @param {String} elName the id of the textarea. */ showTextArea(elName) { let el = document.getElementById(elName); el.style.display = 'block'; } /** * Hides the text area. * @author Eric Frodl * @param {String} elName the id of the textarea to hide. */ hideTextArea(elName) { let textarea = document.getElementById(elName); textarea.style.display = 'none'; } } export default FormUtil; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"InformerBanner.js.html":{"id":"InformerBanner.js.html","title":"Source: InformerBanner.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: InformerBanner.js /** * @classdesc * A message that fades into the screen and guides the player through the tutorial * */ class InformerBanner extends Phaser.GameObjects.Container { constructor(scene, x, y, text) { let background = new Phaser.GameObjects.Sprite(scene,0,0, 'banner'); let textField = new Phaser.GameObjects.Text(scene,0,0,text,{fontSize: 17, color: '#000', wordWrap: {width: 620, useAdvancedWrap: true}}).setOrigin(0.5); super(scene,x,y,[background,textField]); this.background = background; this.textfield = textField; this.setScale(1.1); this.background.displayWidth = 750; this.setSize(background.displayWidth, background.displayHeight); } set text(text) { this.textfield.setText(text); } } export default InformerBanner; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"InteractionScene.js.html":{"id":"InteractionScene.js.html","title":"Source: InteractionScene.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: InteractionScene.js import DialogueScene from './DialogueScene.js'; /** * @classdesc * This class extends the classical DialogueScene to an interaction scene * that can be used for the story of the game. It is designed for questions or notifications * of the experiment. * If an InteractionScene is started, the game time will be stopped and also the * inputs of the {@link Ui}-scene will be blocked. * @class InteractionScene * @extends DialogueScene * @constructor * @param {String} sceneName The scene name is defined at creation of the scene and is used to find, launch or close the scene by the [SceneManager]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scenes.SceneManager.html}. * */ class InteractionScene extends DialogueScene { constructor(sceneName) { super(sceneName); } /** * Creates the dialogue like and behaves like a normal {@link DialogueScene} but additionally stops the * gametime and disables the input of the {@link Ui}. * @param {String} header the headline of the scene. */ createDialogue(header=\"Header\") { // behave like a normal DialogueScene super.createDialogue(header); // disable inputs for the ui scene this.scene.manager.keys.ui.input.enabled = false; this.mainScene.timer.paused = true; } /** * Override the close function from the [DialogueScene]{@link DialogueScene#close} to * resume the game time */ close() { super.close() this.mainScene.timer.paused = false; } } export default InteractionScene; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"LikertScale.js.html":{"id":"LikertScale.js.html","title":"Source: LikertScale.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: LikertScale.js /** * @classdesc * This class implements a labeled Likert scale, displaying * radio buttons that can be checked. Depending on the checked button * the scales returns a different score. * @class LikertScale */ class LikertScale extends Phaser.GameObjects.Container { constructor(data) { let {scene, x, y} = data; let value; let responses = ['sehr schlecht', 'eher schlecht', 'eher gut', 'sehr gut', 'keine Ahnung']; // create five radio buttons and corresponding texts let buttons = []; let texts = []; let initX = -210; for (let i=0; i &lt;5; i++) { if (i != 4){ value = i+1; } else value = -1; buttons.push(new RadioButton({scene:scene, x:initX, y:0, value}).setScale(0.8)); texts.push(new Phaser.GameObjects.Text(scene, initX, -25, responses[i], {fontSize: 12, color: \"#000\"}).setOrigin(0.5,0.5)); initX += 110; } super(scene,x,y,buttons.concat(texts)); this.activeButton; this.buttons = buttons; this.addCheckedListeners(); } /** * Uncheck the other buttons to ensure that only one radioButton is checked at the same time. * @param {RadioButton} exception the button that should not be unchecked (which is the button that was * recently clicked). */ uncheckButtons(exception) { this.activeButton = exception; this.buttons.map(x =&gt; { if(x !== exception){ x.isChecked = false; } }); } /** * Adds a checked listener for each radio button. * This helps to identify which button has been clicked. This information is used to unceck the other buttons * that might be active. With this method it is ensured, that only one radio button at a time is checked. */ addCheckedListeners() { this.buttons.forEach(button =&gt; { button.on('buttonChecked', this.uncheckButtons,this) }); } /** * Return the value of the active {@link RadioButton} which corresponds to the response of the subject. * @returns {number} the value of the subject's response. */ getValue() { if (this.activeButton){ return this.activeButton.value; } else return undefined; } } export default LikertScale; /** * @classdesc * A radio button that behaves like a html radio button: it can be checked or unchecked. If a radio button is * checked it cannot be unchecked again. */ class RadioButton extends Phaser.GameObjects.Sprite { constructor(data) { let {scene, x,y, value} = data; super(scene,x,y,'radio-button'); this.value = value; this._isChecked = false; this.setInteractive(); this.on('pointerdown', () =&gt; { this.once('pointerup', () =&gt;{ if (!this.isChecked) { this.isChecked = true; this.emit('buttonChecked', this); } },this); },this) } /** * The setter for the isChecked value. Setting this value to the desired state * also changes the texture. * @param {boolean} value true if the button is checked, false to uncheck the button. */ set isChecked(value) { this._isChecked = value; if (this._isChecked) { this.setTexture('radio-button-checked'); } else this.setTexture('radio-button'); } /** * Return the state of the button. * @returns {boolean} true if the radio button is checked. */ get isChecked() { return this._isChecked; } } × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"MainScene.js.html":{"id":"MainScene.js.html","title":"Source: MainScene.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: MainScene.js import Item from './Item.js'; import Management from './Management.js'; import Market from './Market.js'; import Player from './Player.js'; import Workshop from './Workshop.js'; import Storage from './Storage.js'; import * as Constants from './Constants.js'; import {loadSolution} from './glpkUtility.js'; import {writeProducedItems,writeProfit,writeProducingStatus,writeLog} from './SosciWriter.js'; import {getMonthOptimalProfit} from './ProfitSummary.js'; import ItemPriceTable from './ItemPriceTable.js'; import DialogueScene from './DialogueScene.js'; import DialogueSchedule from './DialogueSchedule.js'; import EventDispatcher from './EventDispatcher.js'; import Tutorial from './Tutorial.js'; /** * @classdesc * This is the main scene of the game. * Here every game object is displayed as well as the map, the [buildings]{@link Building}, the * [Player]{@link Player}. * This scene also handels the timing, the camera to enable movement and it stores the * profits of the player inside a Soci survey variable if activated. * * @class MainScene * @extends Phaser.Scene * @see [Phaser.Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html} * */ class MainScene extends Phaser.Scene { constructor() { super('main'); } /** * The init function is run before the scene itself is created. * This is useful to initialize variables that are needed at the beginning of the scene. */ init() { /** * Indicates that the tutorial is currently active. */ this.tutorialPhase = true; /** * This is an iterator that is called if a new month is started, usually after the player skips to the next * month or the time is up. * @type {iterator} */ this.monthIterator = this.createMonthIterator(undefined,12); /** * The player instance representing the player that is currently playing the game * @type {Player} */ this.player = new Player({ scene: this, availableWood: Constants.WOOD, availableMetal: Constants.METAL }); // Start the game by calling the monthiterator for the first time this.schedule = new DialogueSchedule(this.scene); this.nextMonth(); /** * The solution of the underlying linear programming problem. It is generated by * [loadSolution]{@link glpkUtility#loadSolution} and has the following structure: * @property {list} numberOfBeds the number of beds built to work optimal for every month. * @property {list} numberOfBookCases the number of bookcases built every month. * @property {list} numberOfChairs the number of chairs built to work optimal for every month. * @property {list} numberOfTables the number of tables built to work optimal for every month. * @property {number} objective the total optimal profit for the year. */ this.lpSolution = loadSolution(); // Set the volume of the audio effects to the globally defined value. this.sound.setVolume(Constants.SOUND_VOLUME); /** * The sound that is played when a new month is started. */ this.newMonthSound = this.sound.add('month_change'); /** * The sound that is played when an Item has been sold. */ this.buildSound = this.sound.add('coins'); } /** * This function is called if a scene is created hence, made visible. * It should be used to render the gameObjects that should be visible inside the scene. * The map and all buildings as well as the ui at the top are rendered here. */ create() { this.eventEmitter = EventDispatcher.getInstance(); this.eventEmitter.setMainScene(this); this.renderTilemap(); this.configureCamera(); this.createItems(); this.createWorkshops(); // launch the ui scene this.scene.launch('ui', {mainScene: this, player: this.player}); if (Constants.PRODUCE_PARTS) { // The storage is only used, if parts should be produced. this.storage = new Storage( { scene: this, x: 755, y: 1025, image: 'storage', name: 'Lager' }); } /** * The first management, responsible for chairs and tables. * @type {Management} */ this.management_one = new Management( { scene: this, x: 1090, y: 595, image: 'management_one', name: 'Management 1', branch: 0, workshops: this.workshops, items: [this.chair,this.table], storage: this.storage }); /** * The second management, responsible for bed frames and bookcases. * * @type {Management} */ this.management_two = new Management( { scene: this, x: 950, y:570, image: 'management_two', name: 'Management 2', branch: 1, workshops: this.workshops, items: [this.bed, this.bookcase], storage: this.storage }); // Pass the corresponding management to each workshop. this.workshopA.management = this.management_one; this.workshopB.management = this.management_one; this.workshopC.management = this.management_two; this.workshopD.management = this.management_two; if (Constants.ENABLE_MARKET){ /** * The market, that is used to summarize the profits of the player. * @type {Market} */ this.market = new Market( { scene: this, x: 880, y: 1030, image: 'market', name: 'Markt' }); } if (this.tutorialPhase) { this.tutorial = new Tutorial(this); this.tutorial.startTutorial(); } } /** * This function is used to create the items that are needed in the game. * That is, the [Item]{@link Item} chair, table, bed and bookcase. */ createItems() { this.chair = new Item( { name: Constants.ITEM_NAME_CHAIR, costs: Constants.CHAIR.costs, profit: Constants.CHAIR.profit, branch: 0, imageCode: 'chair', parts: [{ imageCode: 'chair-leg', name: Constants.PART_NAME_CHAIR_LEG, demand: 4, costs: {wood: 1, metal: 0, hoursA: 1, hoursB: 0,hoursC: 0,hoursD: 0} }, { imageCode: 'chair-back', name: Constants.PART_NAME_CHAIR_BACK, demand: 1, costs: {wood: 0, metal: 1, hoursA: 0, hoursB: 1, hoursC: 0, hoursD: 0} }] }); this.table = new Item( { name: Constants.ITEM_NAME_TABLE, costs: Constants.TABLE.costs, profit: Constants.TABLE.profit, branch: 0, imageCode: 'table', parts: [{ imageCode: 'table-leg', name: Constants.PART_NAME_TABLE_LEG, demand: 4, costs: {wood: 0, metal: 1, hoursA: 1, hoursB: 0, hoursC: 0, hoursD: 0} }, { imageCode: 'table-top', name: Constants.PART_NAME_TABLE_TOP, demand: 1, costs: {wood: 2, metal: 1, hoursA: 0, hoursB: 6, hoursC: 0, hoursD: 0} }] }); this.bed = new Item( { name: Constants.ITEM_NAME_BED, costs: Constants.BED.costs, profit: Constants.BED.profit, branch: 1, imageCode: 'bed', parts: [{ imageCode: 'bed-frame', name: Constants.PART_NAME_BED_FRAME, demand: 1, costs: {wood: 2, metal: 1, hoursA: 0, hoursB: 0, hoursC: 3, hoursD: 0} }, { imageCode: 'bed-top', name: Constants.PART_NAME_BED_TOP, demand: 2, costs: {wood: 1, metal: 1, hoursA: 0, hoursB: 0, hoursC: 0, hoursD: 2} }] }); this.bookcase = new Item( { name: Constants.ITEM_NAME_BOOKCASE, costs: Constants.BOOKCASE.costs, profit: Constants.BOOKCASE.profit, branch: 1, imageCode: 'bookcase', parts: [{ imageCode: 'bookcase-leg', name: Constants.PART_NAME_BOOKCASE_LEG, demand: 1, costs: {wood: 2, metal: 1, hoursA: 0, hoursB: 0, hoursC: 5, hourD: 0} }, { imageCode: 'bookcase-top', name: Constants.PART_NAME_BOOKCASE_TOP, demand: 3, costs: {wood: 1, metal: 2, hoursA: 0, hoursB: 0,hoursC: 0, hoursD: 1} }] }); this.items = [this.chair, this.table, this.bed, this.bookcase]; } /** * This function creates the four workshops that are used in the game. * @see Workshop */ createWorkshops() { // Create Workshops this.workshopA = new Workshop( { scene: this, x: 680, y: 970, availableHours: Constants.HOURS_A, image: 'workshop-a', name: 'Werkstatt A', items: [this.chair.parts[0], this.table.parts[0]], sign: \"sign-a\" }); this.workshopB = new Workshop( { scene: this, x: 940, y: 900, availableHours: Constants.HOURS_B, image: 'workshop-b', name: 'Werkstatt B', items: [this.chair.parts[1], this.table.parts[1]], sign: \"sign-b\" }); this.workshopC = new Workshop( { scene: this, x: 1040, y: 900, availableHours: Constants.HOURS_C, image: 'workshop-c', name: 'Werkstatt C', items: [this.bed.parts[0], this.bookcase.parts[0]], sign: 'sign-c' }); this.workshopD = new Workshop( { scene: this, x: 880, y: 780, availableHours: Constants.HOURS_D, image: 'workshop-d', name: 'Werkstatt D', items: [this.bed.parts[1], this.bookcase.parts[1]], sign: 'sign-d' }); this.workshops = [this.workshopA, this.workshopB, this.workshopC, this.workshopD]; } /** * This function renders all layers of the map, resulting in the final game map. * If you want to edit the map you can load the map file into tiled. * * @tutorial map_editing */ renderTilemap() { const tilemap = this.make.tilemap({ key: 'map' }); const tileset_one = tilemap.addTilesetImage('scifi_tilesheet', 'tiles-scifi'); const tileset_two = tilemap.addTilesetImage('what', 'tiles-medival'); tilemap.createStaticLayer('Background', [tileset_two, tileset_one]); tilemap.createStaticLayer('Copy of Environment', [tileset_two, tileset_one]); tilemap.createStaticLayer('Big Objects', [tileset_two, tileset_one]); tilemap.createStaticLayer('Environment', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/env1', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees1', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees2', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees3', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees4', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees5', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees6', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees7', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees8', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees9', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees10', [tileset_two, tileset_one]); tilemap.createStaticLayer('Group 1/trees11', [tileset_two, tileset_one]); } /** * This function configures the camera to show a specific part of the map. * it also enables navigation options for dragging the camera with the mouse. */ configureCamera() { this.cameras.main.setBounds(250, 250, 2048, 2048); this.cameras.main.setZoom(0.7); this.cameras.main.centerOn(2048, 1450); // centering where the buildings are this.input.on('pointermove', function (p) //if mointer is moved { if (!p.isDown) return; // do nothing if mouse is not pressed // move the map with the mouse let xDifference = (p.x - p.prevPosition.x) / this.cameras.main.zoom; let yDifference = (p.y - p.prevPosition.y) / this.cameras.main.zoom; this.cameras.main.scrollX -= xDifference; this.cameras.main.scrollY -= yDifference; }); } /** * The iterator that is used to simulate the year. * @param {number} [start=0] the number where the year should start * @param {number} [end=12] the number where the iterator should spot. */ * createMonthIterator(start=0, end=Constants.MONTHS+1) { for (let i = start; i &lt; end; i++) { yield i; } } /** * This function is triggered if the month should be switched. * it steps the [monthIterator]{@link MainScene#monthIterator} to the next month, * maintains the profits of the player, resets the available time of the workshops * and starts a new timer for the new month that expires to start a new month. * If the last month is over, this function also triggers a final summary that * informs the player that the game is over. */ nextMonth() { this.month = this.monthIterator.next(); this.player.monthlyProfit.push(0); // extend player profits by a new entry. if (!this.tutorialPhase) { if (this.month.value === 0) this.scene.launch('messageDialogue', {mainScene: this, title: \"Nachricht von Anna\", question: \"Hallo,\\nich bin's wieder, Anna.\\nIn den nächsten zwei Monaten hast du \\nZeit, unsere Managementprozesse besser \\nkennenzulernen. Ich werde dir am Ende \\nvon jedem dieser zwei Monate Feedback \\nzu deiner Lösung geben. Außerdem steht\\njeden Monat in der Furniture Post, wie\\nviel Material geliefert wird und wie\\nsich die Profite ändern. Ich freue mich \\nauf unsere Zusammenarbeit!\", avatar: 'ann'}); } // close active dialogues on month change this.scene.manager.scenes.filter(x =&gt; x instanceof DialogueScene &amp;&amp; x.scene.isActive(x.scene.key)).map(x =&gt; x.close()); if (this.month.value &gt; 0) // if this is not the initial month { if (this.month.value === 1 || this.month.value === 2) this.schedule.addDialogue('feedbackDialogue', {mainScene: this, height: 400, width: 500}); if (this.month.value === 3) this.schedule.addDialogue('assesmentDialogue', {mainScene: this, title: \"\", question: \"\", questionNumber: 1}); // Store values at soscisurvey if (this.month.value === 6) this.schedule.addDialogue('assesmentDialogue', {mainScene: this, title: \"\", question: \"\", questionNumber: 2}); if (!Constants.ON_LOCAL_MACHINE &amp;&amp; !this.tutorialPhase) this.storeValues(this.month.value -1); if (this.month.value === 11) this.schedule.addDialogue('aiDialogue', {mainScene: this, title: \"\", question: \"\", questionNumber: 1, aiData: { chair: { profit: this.chair.profit[this.month.value-1], solution: 6 }, bed: { profit: this.bed.profit[this.month.value-1], solution: 1 }, bookcase: { profit: this.bookcase.profit[this.month.value-1], solution: 4 }, table: { profit: this.table.profit[this.month.value-1], solution: 0 }, material: { wood: this.player.initialWood[this.month.value-1], metal: this.player.initialMetal[this.month.value-1] } }}); //play the sound for the next month this.newMonthSound.play(); // load the newspaper to give the player a pause. if (!Constants.MONTHLY_PAUSE) this.showPriceChanges(); } // if there are workshops, reset them. At the very beginning there are no workshops yet, // they will be skipped. if (this.workshops) { if (Constants.MONTHLY_RESET &amp;&amp; this.month.value &gt; 0) this.resetProduction(); this.workshops.forEach(workshop =&gt; { workshop.resetHours(); if (Constants.MONTHLY_RESET) workshop.interrupt(); }); } // if this is not the last month, initialte a new timer. if (!this.month.done) { if (Constants.MONTHLY_PAUSE &amp;&amp; this.month.value &gt; 0) { // display the newpaper scene. this.schedule.addDialogue('newsScene', {mainScene: this, height: 60, width: 75}); if (this.month.value ===2) this.schedule.addDialogue('messageDialogue', {mainScene: this, title: \"Nachricht von Anna\", question: \"Hallo, \\ndas war eine gute Einarbeitungszeit, \\nich bin mir sicher, dass du von jetzt \\nan auch ohne Feedback zurecht kommst \\nund unsere Produktion sehr gut managen \\nwirst. Für eine unternehmensinterne \\nQualitätskontrolle, beantworte bitte \\nam Ende einiger kommender Monate Fragen \\nzu deiner Managementarbeit und gib uns \\neine Selbsteinschätzung deiner Arbeit. \\nViel Erfolg!\", avatar: 'ann'}); if (this.month.value === 8) this.schedule.addDialogue('messageDialogue', {mainScene: this, title: \"Nachricht von Anna\", question: \"Hallo, \\nwir sind sehr zufrieden mit deiner \\nArbeit und befördern dich zu einer \\nneuen Managementposition in unserer Firma! \\nDamit deine alten Aufgaben aber weiter \\nerledigt werden, arbeite bitte deinen \\nneuen Kollegen Mike ein. Dafür manage \\nbitte die Produktion in den kommenden \\nMonaten. Mike wird deine Entscheidungen \\nnachverfolgen und dir Fragen zu ihnen stellen.\", avatar: 'ann'}); if (this.month.value === 8) this.schedule.addDialogue('textDialogue', {mainScene: this, avatar: 'mike', title: \"Frage von Mike\", question: \"Was sollte ich tun um eine \\nmöglichst gute Lösung zu finden?\", questionNumber: 1}); if (this.month.value === 10) this.schedule.addDialogue('textDialogue', {mainScene: this, avatar: 'mike', title: \"Frage von Mike\", question: \"Wie finde ich jeden Monat heraus, \\nwas ich bauen soll?\", questionNumber: 2}); } else { // start the timer for the next month this.startTimer(); } } else { // store the final values and start the final summary. if (!Constants.ON_LOCAL_MACHINE) { this.storeValues(Constants.MONTHS -1); } this.schedule.addDialogue('aiDialogue', {mainScene: this, title: \"\", question: \"\", questionNumber: 2, aiData: { chair: { profit: this.chair.profit[11], solution: 5 }, bed: { profit: this.bed.profit[11], solution: 1 }, bookcase: { profit: this.bookcase.profit[11], solution: 4 }, table: { profit: this.table.profit[11], solution: 0 }, material: { wood: this.player.initialWood[11], metal: this.player.initialMetal[11] } }}); this.schedule.addDialogue('finalSummary', { mainScene: this, height: 400, width: 500 }); } this.schedule.run(); } /** * This function stores the profit and produced items from player and model * from the past month to SosciSurvey variables. * @param {number} month the month for which the profits should be stored. */ storeValues(month) { let monthValue = month; let playerItems = this.player.producedItems; writeProfit('player', monthValue,this.player.monthlyProfit[monthValue]); writeProfit('model', monthValue,getMonthOptimalProfit(this.lpSolution, monthValue)); writeProducedItems('player',monthValue,{ beds: this.player.producedItems.beds[monthValue], bookcases: playerItems.bookcases[monthValue], tables: playerItems.tables[monthValue], chairs: playerItems.chairs[monthValue] }); writeProducedItems('model',monthValue,{ beds: this.lpSolution.numberOfBeds[monthValue], bookcases: this.lpSolution.numberOfBookCases[monthValue], tables: this.lpSolution.numberOfTables[monthValue], chairs: this.lpSolution.numberOfChairs[monthValue] }); } /** * This function renders a new Price table, that informs the player of the price changes. * It is only be used if the option [MONTHLY_PAUSE]{@link module:GameProperties#MONTHLY_PAUSE} is set to `false`. * @see ItemPriceTable */ showPriceChanges() { let newPrices = []; let oldPrices = []; this.items.forEach(item =&gt; { // get the prices of the new month and the prices of the old month newPrices.push(item.profit[this.month.value]); oldPrices.push(item.profit[this.month.value-1]); }); // render a new price table. let priceTable = new ItemPriceTable( { scene: this, x: 1200, y: 300, pricesOld: oldPrices, pricesNew: newPrices }); // start the animation of the price table priceTable.run(); } /** * Get information whether one or more workshops are currently producing. * @returns {number} 0 if none of the workshops are currently producing, 1 else. */ getProductionStatus() { let status = 0; this.workshops.forEach(workshop =&gt; { if(workshop.busy){ status= 1; } }); return status; } /** * This function stops all workshops and deletes available * parts inside the storage. It also writes a flag indicating if a workshop was active during * the month change. This helps to see if a player had not enough time to finish all parts. * @see Workshop * @see SosciWriter#writeProducingStatus */ resetProduction() { if (this.workshops) { let status = this.getProductionStatus(); if (!Constants.ON_LOCAL_MACHINE) { if (!this.month.done) { // inform sosci survey if the workshops were busy during month change writeProducingStatus(this.month.value-1,status); }else{ writeProducingStatus(Constants.MONTHS-1,status); } } } if (Constants.PRODUCE_PARTS) { // delete all parts inside the storage. Object.keys(this.storage.parts).forEach(key =&gt; { this.storage.parts[key] = 0; } ); } } /** * Starts the timer for the month. * The duration of the timer is specified by the option [MONTH_SECONDS]{@link module:GameProperties#MONTH_SECONDS}. */ startTimer() { let delayValue; if (this.month.value) delayValue = Constants.MONTH_SECONDS[this.month.value]*1000; else delayValue = Constants.MONTH_SECONDS[11]*1000; this.timer = this.time.addEvent( { delay: delayValue, callback: this.nextMonth, callbackScope: this } ); } } export default MainScene; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Management.js.html":{"id":"Management.js.html","title":"Source: Management.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Management.js import Building from './Building.js'; import Process from './Process.js'; import * as Constants from './Constants.js'; /** * @classdesc * This Class is responsible for rendering a management building. * In a management Building the player can see the Items that can be produced along with its costs and profit. * This should serve as information source for planning which items should be produced in the actual month. * Each management represents one production branch. * * @class Management * @extends Building * * @constructor * @param {object} data an object that stores the information needed to build this class. * @param {Phaser.Scene} data.scene the scene where the management building should be built in. See [Phaser.Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html} * @param {Number} data.x the x coordinate where the building should be placed. * @param {Number} data.y the y coordinate for the building. * @param {String} data.image the image key of the building. * @param {String} data.name the name of the building. * @param {Array} data.items the items that should be described by the management. * @param {Storage} data.storage the storage building, where the management should store produced items. * @param {Player} data.player the player instance. * @param {Number} data.branch the branch of the management. * */ class Management extends Building { constructor(data) { super(data); /** * This is a list of items that should be managed in this building. * This list corresponds to the branch of this management. * * @type {Array} */ this.items = data.items; /** * This is the list of workshops the management is responsible for. * This list is used to schedule production processes. If something is produced, the management calls the * workshops in this list. * * @type {Array} */ this.workshops = data.workshops; /** * This is the storage. If the option [PRODUCE_PARTS]{@link GameProperties#PRODUCE_PARTS} is activated, * this storage is called after the production is finished causing the produced part to be stored. * * @type {Storage} */ this.storage = data.storage; /** * The player. This is needed to add the profit and applying the costs. * * @type {Player} */ this.player = this.scene.player; this.addClickListener(this.createDialogue); /** * The Branch helps applying branch specific properties like duration and responsible workshops. * There are two possible values for the branch: * * + `0` - The branch including `chairs` and `tables`. * + `1` - The branch includin `beds` and `bookcases`. * * @type {Number} */ this.branch = data.branch; if (this.branch == 0) this.sign.setTexture('sign1').setScale(0.3); else this.sign.setTexture('sign2').setScale(0.3); this.sign.y -=40; this.sign.x += 30; this.sign.alpha = 1; this.add(this.sign); if(Constants.PRODUCE_PARTS) { // Add a listener to wait if an item is complete in order to sell it. this.storage.on('built'+this.branch, function(item) { this.item = item; this.sell(); },this); } } /** * This function is used as the callback function of the clicklistener. * If the building is clicked, a new [ManagementDialogue]{@link ManagementDialogue} will be launched. * @see {@link Building#addClickListener} */ createDialogue() { this.scene.scene.launch('managementDialogue', { mainScene: this.scene, height: 300, width: 500, management: this }); } /** * Produces an item, by consuming its costs and invoking a process. * @see Process * @param {Item} item The item that should be produced. * @returns {object} an object holding true inside its status attribute if the item can be produced, * else the dictionary status is false and it has an accessable reason. * * Example return if the item cannot be produced: {status: false, reason: 'not enough wood!'} * These values come from the canAfford method. */ produce(item) { let canAfford = this.canAfford(item); if (canAfford.status) // check if the item is affordable { // consume the required material form the players available resources this.player.availableWood[this.scene.month.value] -= item.costs.wood; this.player.availableMetal[this.scene.month.value] -= item.costs.metal; let times = Object.values(item.costs).slice(2); // slice the wood and metal from the items costs - only the times are left for (let i=0; i &lt; times.length; i++) { // distribute the time costs over the workshops this.workshops[i].availableHours -= times[i]; } // Start a new process let process = new Process({management: this, item: item}); process.start(); if(Constants.PRODUCE_PARTS) { // store the item if the process sends that the workshop is done producing process.on('done', this.store, {storage: this.storage, part: item, management: this}); } else { // sell the item. process.on('done', this.sell, {player: this.player, item: item, scene: this.scene}); } } return canAfford; } /** * Sells an item in the given context and add its profit to the players * money. After that, the produced item is added to the players statistics. */ sell() { let profit = this.item.profit[this.scene.month.value]; this.scene.buildSound.play(); this.player.money += profit; this.player.monthlyProfit[this.scene.month.value] += profit; switch (this.item.name) // using the item name to add the produced item to the statistics. { case Constants.ITEM_NAME_CHAIR: this.player.producedItems.chairs[this.scene.month.value] += 1; break; case Constants.ITEM_NAME_TABLE: this.player.producedItems.tables[this.scene.month.value] += 1; break; case Constants.ITEM_NAME_BED: this.player.producedItems.beds[this.scene.month.value] += 1; break; case Constants.ITEM_NAME_BOOKCASE: this.player.producedItems.bookcases[this.scene.month.value] += 1; break; } if (Constants.PRODUCE_PARTS) { this.item.parts.forEach(part =&gt; { this.storage.parts[part.name] -= part.demand; // consume the parts after the item has been sold. }); } } /** * Stores the last produced part inside the storage. * If the GameProperty [AUTOMATIC_SELLING]{@link module:GameProperties#AUTOMATIC_SELLING} is activated, it invokes * the [combineAvailable]{@link Storage#combineAvailable} function of storage, producting every item * that can be afforded. */ store() { this.storage.parts[this.part.name] +=1; if (Constants.AUTOMATIC_SELLING) { this.storage.combineAvailable(); } } /** * Checks if the player has the required resources and if the * workshops have enough time to produce the requested item. * @param {Item} item the item that should be produced. * @returns {{status: boolean, reason: string}} if the item can be afforded it just returns `status: true`. If not, * the status is set to `false` and the `reason` corresponds to the reason of why the item could not be produced. */ canAfford(item) { let costs = item.costs; if (costs.wood &gt; this.player.availableWood[this.scene.month.value]) return {status: false, reason: 'Nicht genug Holz!'}; if (costs.metal &gt; this.player.availableMetal[this.scene.month.value]) return {status: false, reason: 'Nicht genug Metall!'}; if (costs.hoursA &gt; this.scene.workshopA.availableHours) return {status: false, reason: 'Keine Zeit mehr in A!'}; if (costs.hoursB &gt; this.scene.workshopB.availableHours) return {status: false, reason: 'Keine Zeit mehr in B!'}; if (costs.hoursC &gt; this.scene.workshopC.availableHours) return {status: false, reason: 'Keine Zeit mehr in C!'}; if (costs.hoursD &gt; this.scene.workshopD.availableHours) return {status: false, reason: 'Keine Zeit mehr in D!'}; else return {status: true}; } } export default Management; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"ManagementDialogue.js.html":{"id":"ManagementDialogue.js.html","title":"Source: ManagementDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: ManagementDialogue.js import {SOUND_VOLUME, PRODUCE_PARTS, PRODUCE_IN_MANAGEMENT} from './Constants.js'; import DialogueScene from './DialogueScene.js'; import ItemPanel from './ItemPanel.js'; /** * @classdesc * This is the Dialogue that appears if a [Management Building]{@link Management} has been clicked by the player. * Its main task is to render a [Panel]{@link Panel}, that informs about buildable [Items]{@link Item}, its costs and profits. * To display the Items it initiaties an ItemPanel. * If the options [PRODUCE_PARTS]{@link module:GameProperties#PRODUCE_PARTS} and [PRODUCE_IN_MANAGEMENT]{@link module:GameProperties#PRODUCE_IN_MANAGEMENT} are active, * the panel gets pushed to the left in order to display additional building opions. * @class ManagementDialogue * @extends DialogueScene * @constructor */ class ManagementDialogue extends DialogueScene { constructor() { super('managementDialogue'); } /** * This function is always run after a scene is started. * It creates the resources that are needed to display and handel the dialogue. */ create() { // We set the volume of the sound globally. this.sound.setVolume(SOUND_VOLUME); /** * Adds the clicksound, which was loaded by the {@link Preloader} to the scene. * The sound is added using phasers [BaseSoundManager]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Sound.BaseSoundManager.html#add} * @type {Phaser.Sound.BaseSound} */ this.clickSound = this.sound.add('click'); /** * Adds the errorsound, which was loaded by the {@link Preloader} to the scene. * The sound is added using phasers [BaseSoundManager]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Sound.BaseSoundManager.html#add} * @type {Phaser.Sound.BaseSound} */ this.errorSound = this.sound.add('error'); // We set the images of items to facilitate the display. This way is just used by the management dialogue. this.mainScene.chair.image = new Phaser.GameObjects.Sprite(this, 0,0, 'chair').setScale(0.2).setOrigin(-0.3,0.5); this.mainScene.table.image = new Phaser.GameObjects.Sprite(this, 0,0, 'table').setScale(0.05).setOrigin(-0.3,0.5); this.mainScene.bed.image = new Phaser.GameObjects.Sprite(this, 0,0, 'bed').setScale(0.15).setOrigin(-0.3,0.5); this.mainScene.bookcase.image = new Phaser.GameObjects.Sprite(this, 0,0, 'bookcase').setScale(0.4).setOrigin(-0.3,0.5); /** * A management instance, which is the management that has been clicked. * This makes sure, that all actions taken in this scene affect the right management building. * * @type {Management} */ this.management = this.data.management; this.createDialogue(this.management.name); this.panel.headerSize = 16; if (PRODUCE_PARTS) { this.panel.x -= 120; } /** * The ItemPanel here organizes the items that should be displayed in this management. * * @type {ItemPanel} */ this.itemPanel = new ItemPanel({ scene: this, x: 0, y: -10, items: this.management.items }); this.panel.add(this.itemPanel); this.fadeIn(); if (this.mainScene.tutorialPhase) this.panel.buttonRound.disableInteractive(); } /** * This function is called after every frame, updating the queue status of the workshop and the progressbars */ update() { this.itemPanel.list.forEach((item) =&gt; { item.updatePrice(); }); } } export default ManagementDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Market.js.html":{"id":"Market.js.html","title":"Source: Market.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Market.js import Building from './Building.js'; /** * @classdesc * This class renders a market building with that can be used to * compare the profits of the player with the optimal solution. * * @class Market * @extends Building * @constructor * @param {object} data the object that is used to provide the required information. * See {@link Building} for more information. */ class Market extends Building { constructor(data) { super(data); /** * The player instance to retrieve the profits. * @type {Player} */ this.player = this.scene.player; /** * The linear programming problem solution that is used to be compared to the player's performance. */ this.lp = this.scene.lpSolution; // add the click listener to the building and trigger the createDialogue function if clicked. this.addClickListener(this.createDialogue); } /** * This function launches the market Dialogue scene where the * information is actually rendered. * @see MarketDialogue */ createDialogue() { this.scene.scene.launch('marketDialogue', { mainScene: this.scene, height: 400, width: 500, market: this }); } } export default Market; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"MarketDialogue.js.html":{"id":"MarketDialogue.js.html","title":"Source: MarketDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: MarketDialogue.js import Diagram from \"./Diagram.js\"; import DialogueScene from \"./DialogueScene.js\"; import ProfitSummary from \"./ProfitSummary.js\"; /** * @classdesc * The dialogue that is displayed after the player clicks on the market building. * It renders a summary consisting of the player's profits and optimal values. * @class MarketDialogue * @extends DialogueScene * @see Market * @see ProfitSummary */ class MarketDialogue extends DialogueScene { constructor() { super('marketDialogue'); } /** * This function is responsible for rendering the {@link ProfitSummary} */ create() { // bind the market to the dialogue this.market = this.data.market; // create the default panel to wrap the summary this.createDialogue('Letzter Monat:'); if (this.mainScene.month.value == 0) // If we are at the first month, display this message instead of a summary. { this.panel.add(new Phaser.GameObjects.Text(this.mainScene, -175,-50, 'Die Profitübersicht ist ab \\n\\ndem nächsten Monat verfügbar.',{fontSize:17,color: '#000'})); } else { this.ProfitSummary = new ProfitSummary({ scene: this, x: 0, y: 0, lpSolution: this.mainScene.lpSolution, player: this.mainScene.player, month: this.mainScene.month.value }); // add the summary to the panel this.panel.add(this.ProfitSummary); } this.fadeIn(); if (this.mainScene.tutorialPhase) this.panel.buttonRound.disableInteractive(); } } export default MarketDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"MessageDialogue.js.html":{"id":"MessageDialogue.js.html","title":"Source: MessageDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: MessageDialogue.js import {ON_LOCAL_MACHINE, TEXTDIALOGUE_WIDTH, TEXTDIALOGUE_HEIGHT} from './Constants.js'; import DialogueScene from './DialogueScene.js'; import FormUtil from './formUtil.js'; import Button from './Button.js'; import InteractionScene from './InteractionScene.js'; import {writeAnswer} from './SosciWriter.js'; /** * @classdesc * This class provides dialogue scene to get a user text input. * In order to create this dialogue the values required by the DialogueScene must be provided on creation. * Therefore, see {@link DialogueScene#init}. * @calss TextDialouge * In order to run this scene, it can be launched with phaser's scene plugin. * Additionaly, a title and a question text should be provided. * @example * // go to the place, where the scene should be started and insert the following line * this.scene.launch('textDialogue', {mainScene: this, title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION questionNumber: NUMBER}); * // \"this\" must be a scene, because this.scene points at the scene manager of the specific scene. * */ class MessageDialogue extends InteractionScene { constructor() { super('messageDialogue'); } /** * Creates the dialogues and all related game objects that are required in this scene. * This function runs automatically after the scene has been started. */ create() { /** * The background sprite. It is a black, slightly transparent rectangle, that is used to darken the * background. * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.background = new Phaser.GameObjects.Sprite(this, 0,0,'shadow-background').setScale(9); // First the background is set to fully transparent. We will animate this value later // to create a \"fade in\" effect. this.background.alpha = 0; // adding the background to this scene. this.add.existing(this.background); /** * This is the title of the dialogue. * @type {String} */ this.title = this.data.title; let avatar = this.data.avatar; /** * The question that is displayed to the user above the input field, where the player can * type in the answer. * @type {String} */ this.question = this.data.question; this.height = TEXTDIALOGUE_HEIGHT; this.width = 1.2 * TEXTDIALOGUE_WIDTH; this.createDialogue(this.title); this.renderQuestion(); this.panel.disableCloseButton(); let sendButton = new Button(this,90,130,'button-long', 'button-long-pressed','Okay',this.close,this); let avatarSprite = new Phaser.GameObjects.Sprite(this,190,-120, avatar).setScale(1); sendButton.setButtonScale(0.75); this.panel.add(sendButton); this.panel.add(avatarSprite); // animate the background from alpha = 0 to alpha = 1 in one second this.tweens.add( { targets: this.background, alpha: 1, duration: 1000 } ); // fade in the dialogue. this.fadeIn(); } /** * Displays the quesiton on the dialogue. */ renderQuestion() { this.questionElem = new Phaser.GameObjects.Text(this.mainScene, 0,-this.height/2+160, this.question, {fontSize: 17,color: \"#000\"}).setOrigin(0.5,0.3); this.panel.add(this.questionElem); } /** * Adjust the size of the question text. * @param {number} size the desired fontsize for the question */ setQuestionFontSize(size) { this.questionElem.setFontSize(size); } } export default MessageDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Constants.js.html":{"id":"Constants.js.html","title":"Source: Constants.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Constants.js /** * * This module contains settings concerning the games functionality. * To change the behavior of the game, see {@link module:GameProperties}. * * @module Constants */ import {parseLP} from './glpkUtility.js'; /* * Load the Game Properties into this script allows to access them * via the constants. */ export * from './GameProperties.js'; /** * Provide the path to the linear programming problem in cplex format. * @name module:Constants#MODEL */ export const MODEL = 'model_v6_parts.xml'; /** * The path to the optimal solution in JSON format. * @name module:Constants#SOLUTION */ export const SOLUTION = 'model_v6_solution_parts.xml'; /** * Disables the SosciSurvey functions, to enable testing * on local machines. * If you want to run the project on SosciSurvey, in order * to obtain data, this option must be set to 'false'. * @name module:Constants#ON_LOCAL_MACHINE */ export const ON_LOCAL_MACHINE = false; /** * A Json file mapping the action keys to the fulltext * action. * @name module:Constants#ACTION_MAP */ export const ACTION_MAP = \"action_map.xml\"; // Importing the linear model and parsing the game relevant information var config = parseLP(); /** * The available wood for every month. * @name module:Constants#WOOD */ export const WOOD = config.woodAvailable; /** * The metal available for the player. * @name module:Constants#METAL */ export const METAL = config.metalAvailable; /** * The hours available for workshop A. * @name module:Constants#HOURS_A */ export const HOURS_A = config.workshopAAvailable; /** * The hours available for workshop B. * @name module:Constants#HOURS_B */ export const HOURS_B = config.workshopBAvailable; /** * The hours available in workshop C * @name module:Constants#HOURS_C */ export const HOURS_C = config.workshopCAvailable; /** * The hours available in workshop D * @name module:Constants#HOURS_D */ export const HOURS_D = config.workshopDAvailable; /** * The values for the chair item. * These values consist of the costs of the item and the profit. * @name module:Constants#CHAIR */ export const CHAIR = config.items.chair; /** * The values for a bed item. * This variable stores the costs and profit of the bed. * @name module:Constants#BED */ export const BED = config.items.bed; /** * The values for a table item. * Stores information about the costs and profit of the table. * @name module:Constants#TABLE */ export const TABLE = config.items.table; /** * Values for the bookcase. * It contains information about the costs and profits. * @name module:Constants#BOOKCASE */ export const BOOKCASE = config.items.bookcase; /** * Define the width of the diagram inside the market * dialogue. * @name module:Constants#DIAGRAM_WIDTH */ export const DIAGRAM_WIDTH = 280; /** * Define the height of the diagram inside the market * dialogue. * @name module:Constants#DIAGRAM_HEIGHT */ export const DIAGRAM_HEIGHT = 65; /** * The Width of a Text input dialogue. * This is used to ask questions to the player. * @name module:Constants#TEXTDIALOGUE_WIDTH */ export const TEXTDIALOGUE_WIDTH = 500; /** * The height of the dialogue for text input. * @name module:Constants#TEXTDIALOGUE_HEIGHT */ export const TEXTDIALOGUE_HEIGHT = 400; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"FeedbackSummary.js.html":{"id":"FeedbackSummary.js.html","title":"Source: FeedbackSummary.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: FeedbackSummary.js /** * @module FeedbackSummary */ import Diagram from './Diagram.js'; import * as Constants from './Constants.js'; /** * @classdesc * This class is used to compare the profit of the player with the optimal solution. * Therefore several text elements as well as a diagram and feedback are generated. * It should be placed inside a {@link Panel} to ensure it is displayed properly. * * @class ProfitSummary * @extends Phaser.GameObjects.Container * @see [Phaser.GameObjects.Container]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Container.html} * * @constructor * @param {object} data the object that contains values required to buld the summary of the profit: * @param {Phaser.Scene} data.scene the Phaser scene where the summary should be displayed. This is * usually a {@link MarketDialogue}. * @param {number} data.x the x coordinate for the object. * @param {number} data.y the y coordinate for the object. * @param {Player} data.player an instance of the player to retrieve the profits. * @param {number} data.month the current month of the game. * */ class FeedbackSummary extends Phaser.GameObjects.Container { constructor(data) { let {scene, x,y, lpSolution, player, month} = data; month = month -1; let ownText = new Phaser.GameObjects.Text(scene, -190,-110, 'Deine Lösung:', {fontSize: 15, color: '#000'}).setOrigin(0,0.5); // Player Values let ownProfitText = new Phaser.GameObjects.Text(scene, ownText.x,ownText.y+30, '', {fontSize: 15, color: '#000'}).setOrigin(0,0.5); //let builtText = new Phaser.GameObjects.Text(scene, ownProfitText.x,ownProfitText.y+30, 'Hergestellt:', {fontSize: 15, color: '#000'}).setOrigin(0,0.5); let producedBeds = new Phaser.GameObjects.Text(scene, ownProfitText.x, ownProfitText.y+30, '',{fontSize: 15, color: '#000'}).setOrigin(0,0.5); let producedBookcases = new Phaser.GameObjects.Text(scene, ownProfitText.x, producedBeds.y+30, '',{fontSize: 15, color: '#000'}).setOrigin(0,0.5); let producedTables = new Phaser.GameObjects.Text(scene, ownProfitText.x, producedBookcases.y+30, '',{fontSize: 15, color: '#000'}).setOrigin(0,0.5); let producedChairs = new Phaser.GameObjects.Text(scene, ownProfitText.x, producedTables.y+30, '',{fontSize: 15, color: '#000'}).setOrigin(0,0.5); // Optimal Values let optimalText = new Phaser.GameObjects.Text(scene, -ownProfitText.x-20,ownText.y, '', {fontSize: 15, color: '#000'}).setOrigin(1,0.5); let possibleOptimum = new Phaser.GameObjects.Text(scene, optimalText.x, ownText.y,'',10,Phaser.GameObjects.Text.ALIGN).setOrigin(1,0.5); let linearProfitText = new Phaser.GameObjects.Text(scene, optimalText.x,optimalText.y+30, '', {fontSize: 15, color: '#000'}).setOrigin(1,0.5); let optimalBeds = new Phaser.GameObjects.Text(scene, linearProfitText.x, producedBeds.y, '', {fontSize: 15, color: '#000'}).setOrigin(1,0.5); let optimalBookcases = new Phaser.GameObjects.Text(scene, linearProfitText.x, producedBookcases.y, '', {fontSize: 15, color: '#000'}).setOrigin(1,0.5); let optimalTables = new Phaser.GameObjects.Text(scene, linearProfitText.x, producedTables.y, '', {fontSize: 15, color: '#000'}).setOrigin(1,0.5); let optimalChairs = new Phaser.GameObjects.Text(scene, linearProfitText.x, producedChairs.y, '', {fontSize: 15, color: '#000'}).setOrigin(1,0.5); let feedbackText = new Phaser.GameObjects.Text(scene, ownProfitText.x, producedChairs.y+30, '', {fontSize: 15, color: '#000'}).setOrigin(0,0.5); super (scene, x ,y , [ownText, ownProfitText,producedBeds,producedChairs,producedTables,producedBookcases,optimalText,possibleOptimum,linearProfitText,optimalBeds,optimalBookcases,optimalChairs,optimalTables, feedbackText]) /** * The solution of the linear problem. This is used to display the optimal solution. * * @property {list} numberOfBeds the number of beds built to work optimal for every month. * @property {list} numberOfBookCases the number of bookcases built every month. * @property {list} numberOfChairs the number of chairs built to work optimal for every month. * @property {list} numberOfTables the number of tables built to work optimal for every month. * @property {number} objective the total optimal profit for the year. */ this.lpSolution = lpSolution; /** * This is the scene that defines where this object is rendered. * * @type {Phaser.Scene} */ this.scene = scene; /** * The month from which the results should be displayed. * In this case the last month is used to display the recent profit. * * @type {number} */ this.month = month; /** * The player instance. * This is used to retrieve the profit of the player. * * @type {Player} */ this.player = player; // These values are to be manipulated using the set function this._ownProfitText = ownProfitText; this._producedBeds = producedBeds; this._producedBookcases = producedBookcases; this._producedTables = producedTables; this._producedChairs = producedChairs; /** * The display of the optimal solution. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.linearProfitText = linearProfitText; /** * The text placeholder that displays the number of optimal beds. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.optimalBeds = optimalBeds; /** * The text placeholder that displays the number of optimal bookcases. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.optimalBookcases = optimalBookcases; /** * The text placeholder that displays the number of optimal tables. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.optimalTables = optimalTables; /** * The text placeholder that displays the number of optimal chairs. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.optimalChairs = optimalChairs; /** * The text element for the headline of the optimal solution. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.optimalText = optimalText; /** * The headline for the possible optimal number of furniture built. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.possibleOptimum = possibleOptimum; /** * The textfield that displays the feedback. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.feedbackText = feedbackText; /** * The text element that displays the produced beds by the player. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.producedBeds = player.producedItems.beds[month]; /** * The text element that displays the produced bookcases by the player. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.producedBookcases = player.producedItems.bookcases[month]; /** * The text element that displays the produced tables by the player. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.producedTables = player.producedItems.tables[month]; /** * The text element that displays the produced chairs by the player. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.producedChairs = player.producedItems.chairs[month]; /** * A text field that displays the player's profit of the given month. * @type {Phaser.GameObjects.Text} * @see [Text]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Text.html} */ this.ownProfitText = player.monthlyProfit[month]; // Give the optimal text the value of the optimal profit this.optimalText.text = 'Meine Lösung:'; this.optimalBeds.text = this.lpSolution.numberOfBeds[month]; this.optimalBookcases.text = this.lpSolution.numberOfBookCases[month]; this.optimalTables.text = this.lpSolution.numberOfTables[month]; this.optimalChairs.text = this.lpSolution.numberOfChairs[month]; this.linearProfitText.text = getMonthOptimalProfit(lpSolution, month); this.makeFeedback(); // If feedback should be shown, show it. } /** * Sets the textfield for the player's produced beds to the given value with a preceeding name. * * @param {number} numberOfBeds the number that should be displayed in the text field. */ set producedBeds(numberOfBeds){ this._producedBeds.text = 'Betten: '+ numberOfBeds; // We want to give the texfield also a title. } /** * Sets the textfield for the player's produced bookcases to the given value with a preceeding name. * * @param {number} numberOfBookCases the number that should be displayed in the text field. */ set producedBookcases(numberOfBookCases){ this._producedBookcases.text = 'Regale: '+numberOfBookCases; } /** * Sets the textfield for the player's produced tables to the given value with a preceeding name. * * @param {number} numberOfTables the number that should be displayed in the text field. */ set producedTables(numberOfTables){ this._producedTables.text = 'Tische: '+numberOfTables; } /** * Sets the textfield for the player's produced chairs to the given value with a preceeding name. * * @param {number} numberOfChairs the number that should be displayed in the text field. */ set producedChairs(numberOfChairs){ this._producedChairs.text = 'Stühle: '+numberOfChairs; } /** * Sets the textfield to display the given profit. * * @param {number} profit the profit that should be displayed. */ set ownProfitText(profit){ this._ownProfitText.text = 'Profit: '+profit; } /** * Initiates the feedback towards the player. * The threshold values can be defined in [GameProperties]{@link module:GameProperties}. * @param {bool} isFinal defines if this is the feedback for the final solution at the end of the year. * @returns nothing, but the objects inside this dialogue responsible for the feedback ([medal]{@link ProfitSummary#medal}, * [feedbackText]{@link ProfitSummary#feedbackText} and [feedbackFrame]{@link ProfitSummary#feedbackFrame}) are made visible and filled with the feedback. */ makeFeedback(isFinal=false){ // Calculate the percentage of the optimal solution the player reached. var percentage = this.player.monthlyProfit[this.month]/getMonthOptimalProfit(this.lpSolution, this.month); // and the frame of the feedback. if (percentage === 1){ // reached 100%? this.feedbackText.text = Constants.FEEDBACK_PERFECT; return; } if (percentage &gt;= Constants.PERCENTAGE_VERY_GOOD){ // better than the very good threshold. this.feedbackText.text = Constants.FEEDBACK_VERY_GOOD; return; } if (percentage &gt;= Constants.PERCENTAGE_GOOD){ // better than the goood threshold this.feedbackText.text = Constants.FEEDBACK_GOOD; return; } // anything below: this.feedbackText.text = Constants.FEEDBACK_LOW; } /** * This method is used for the summary after the whole year. * instead of drawing just the profit of the last month, all values * are summed up. */ setFinalValues() { // Print values of the player this.ownProfitText = this.player.money; this.producedChairs = this.player.producedItems.chairs.reduce((a,b) =&gt; a+b); this.producedTables = this.player.producedItems.tables.reduce((a,b) =&gt; a+b); this.producedBeds = this.player.producedItems.beds.reduce((a,b) =&gt; a+b); this.producedBookcases = this.player.producedItems.bookcases.reduce((a,b) =&gt; a+b); // Print optimal values if (Constants.DISPLAY_OPTIMAL_SOLUTION == 'end' || Constants.DISPLAY_OPTIMAL_SOLUTION == 'always') { if (Constants.SHOW_SOLUTION_ASPECTS == 'all' || Constants.SHOW_SOLUTION_ASPECTS == 'profit') { this.optimalText.text = 'Optimale Lösung'; let optimalProfit = getAllOptimalProfits(this.lpSolution).reduce((a,b) =&gt; a+b); this.linearProfitText.text = optimalProfit; } if (Constants.SHOW_SOLUTION_ASPECTS == 'all' || Constants.SHOW_SOLUTION_ASPECTS == 'products') { this.possibleOptimum.text = 'Mögliches Vorgehen:'; this.optimalChairs.text = this.lpSolution.numberOfChairs.reduce((a,b) =&gt; a+b); this.optimalTables.text = this.lpSolution.numberOfTables.reduce((a,b) =&gt; a+b); this.optimalBeds.text = this.lpSolution.numberOfBeds.reduce((a,b) =&gt; a+b); this.optimalBookcases.text = this.lpSolution.numberOfBookCases.reduce((a,b) =&gt; a+b); } } if (!this.diagram &amp;&amp; Constants.SHOW_DIAGRAM) { this.addDiagram(); this.add(this.diagram); } this.makeFeedback(true); } } /** * Multiplies every item with its price at the given month and adds them up * to generate an optimal profit for a month. * @param {Object} the linear problem solution to get the values from. * @param {Number} month the actual month starting at zero. */ function getMonthOptimalProfit(lp, month){ let profitBed = lp.numberOfBeds[month]*Constants.BED.profit[month]; let profitBookcase = lp.numberOfBookCases[month]*Constants.BOOKCASE.profit[month]; let profitTable = lp.numberOfTables[month]*Constants.TABLE.profit[month]; let profitChair = lp.numberOfChairs[month]*Constants.CHAIR.profit[month]; return profitBed+profitBookcase+profitTable+profitChair; } /** * Retrieves the optimal profit for every month and stores returns that list. * @param {object} the optimal solution that usually has been generated by the function [loadSolution]{@link glpkUtility#loadSolution}. * */ function getAllOptimalProfits(lp){ let profits = []; for (let i =0; i&lt; Constants.MONTHS; i++){ profits.push(getMonthOptimalProfit(lp, i)); } return profits; } export default FeedbackSummary; export {getMonthOptimalProfit, getAllOptimalProfits}; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Game.js.html":{"id":"Game.js.html","title":"Source: Game.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Game.js import FinalSummary from './FinalSummary.js'; import MainScene from './MainScene.js'; import ManagementDialogue from './ManagementDialogue.js'; import MarketDialogue from './MarketDialogue.js'; import Preloader from './Preloader.js'; import StorageDialogue from './StorageDialogue.js'; import NewsScene from './NewsScene.js'; import Ui from './Ui.js'; import WorkshopDialogue from './WorkshopDialogue.js'; import TextDialogue from './TextDialogue.js'; import FeedbackDialogue from './FeedbackDialogue.js'; import MessageDialogue from './MessageDialogue.js'; import AssesmentDialogue from './AssesmentDialogue.js'; import AiDialogue from './AiDialogue.js'; import WarningDialogue from './WarningDialogue.js' /** * This module starts the game by applying the configuration of the game and launching the [preloader]{@link Preloader} scene. * To run the game, this module has to be embedded in an html page, like shown in the example. After that the html document can be * hosted on a webserver and launched, if the page is loaded. * * @example &lt;caption&gt; How to add the game to an HTML-document: &lt;/caption&gt; {@lang xml} * &lt;html&gt; * &lt;head&gt; * &lt;script type=\"module\" src=\"Game.js\"&gt;&lt;/script&gt; &lt;!-- loads the game into the web page --&gt; * &lt;/head&gt; * &lt;body&gt; * &lt;!-- inside this div the game is rendered. Hence, the id must match the parent field inside the config object. --&gt; * &lt;div id=\"can\"&gt; * &lt;/div&gt; * &lt;/body&gt; * &lt;/html&gt; * @module Game */ // hide the text area, since it is not needed yet let textarea = document.getElementById('textarea'); textarea.style.display = 'none'; /** * The configuration that defines how the game is started. * @property {number} type defines if WebGL should be used. The AUTO setting detects if the browser is capable of WebGL and runs it, if possible. See [AUTO]{@link https://photonstorm.github.io/phaser3-docs/Phaser.html#.AUTO__anchor} * @property {number} width the width of the game canvas. * @property {number} height the height of the game canvas. * @property {string} backgroundColor the standard background color of the canvas. * @property {boolean} pixelArt automatically applies a linear filter to the game to prevent blurry scaling effects. See [pixelArt]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Core.Config.html#pixelArt__anchor} * @property {string} parent the canvas where the game should be rendered. It can be the id of an HTML div as shown in the example above. * @property {object} physics sets the physics for the game. These values are not critical in this context. * @property {array} scene in this field all scenes are stored. As the game runs, all scenes are initialized and the key of the scenes gets stored inside * the global [SceneManager]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scenes.SceneManager.html}. The first element in this list is the [Preloader]{@link Preloader} scene that loads * all required assets for the game. */ const config = { type: Phaser.AUTO, width: 800, height: 600, backgroundColor: '#333333', pixelArt: true, parent: 'can', physics: { default: 'arcade', arcade: { gravity: {y:0} } }, scene: [Preloader, MainScene, Ui, WorkshopDialogue, ManagementDialogue, MarketDialogue, StorageDialogue, FinalSummary, NewsScene, TextDialogue, MessageDialogue, FeedbackDialogue, AssesmentDialogue, AiDialogue, WarningDialogue], }; /** * The game instance. We do not need to do much with it since the constructor takes care of starting the game. */ var game = new Phaser.Game(config); × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"GameProperties.js.html":{"id":"GameProperties.js.html","title":"Source: GameProperties.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: GameProperties.js /** * This module specifies changes in the behavior of the game. * @module GameProperties */ /** * Specify how many months the simulation should last * * @name module:GameProperties#MONTHS */ export const MONTHS = 12; /** * Set the volume of the game sound effect. * This value can be between 0 and 1. * * @name module:GameProperties#SOUND_VOLUME */ export const SOUND_VOLUME = 0.4; /** * Specify how many seconds a month should have. * * @name module:GameProperties#MONTH_SECONDS */ export const MONTH_SECONDS = [180,180,180,180,180,180,180,180,180,180,180,180]; /** * Decide wheter the player has to build the parts of the furniture or if he/she just * needs one click in order to produce an item. * * true - the parts need to be produced individually * false - the piece of furniture will be produced with one click, without splitting it into its components * @name module:GameProperties#PRODUCE_PARTS */ export const PRODUCE_PARTS = true; /** * Specify whether a market building should be created, where the player can * compare the own performance with the optimal solution. * @name: module:GameProperties#ENABLE_MARKET */ export const ENABLE_MARKET = false; /** * Set this to true to display Warnings if the player wants to skip a month * without having produced something or with active workshops. * @name: module:GameProperties#WARNINGS_AT_SKIP */ export const WARNINGS_AT_SKIP = true; /** * Define if the required amount of parts is queued with one click. * If set to false, one click will initiate the production of just one item. * If set to true, one click will produce the required amount of the item * @name module:GameProperties#PRODUCE_ONE_CLICK */ export const PRODUCE_ONE_CLICK = false; /** * This value defines how the production time should be scaled. * If the value is 1, one working hour corresponds to one second, * a value of 2 - two seconds etc. * @name module:GameProperties#PRODUCTION_TIME_SCALING */ export const PRODUCTION_TIME_SCALING = 2; /** * Decide if items should be sold automatically if all the required material * is available (true) or if the player has to combine the parts * to items inside the storage (false). * * This Property only has an effect, if [PRODUCE_PARTS]{@link module:GameProperties#PRODUCE_PARTS} is set to 'true'. * @name module:GameProperties#AUTOMATIC_SELLING */ export const AUTOMATIC_SELLING = true; /** * Specify if the itemparts should be produced inside the * management. * If this value is set to false, the player has to open the * corresponding workshop in order to produce the parts. * @name module:GameProperties#PRODUCE_IN_MANAGEMENT */ export const PRODUCE_IN_MANAGEMENT = false; /** * Reset working workshops and - if [PRODUCE_PARTS]{@link module:GameProperties#PRODUCE_PARTS} is true - the available * part on month change to prevent workshops carry the work over to the next month. * @name module:GameProperties#MONTHLY_RESET */ export const MONTHLY_RESET = true; /** * Set the name for the chair * @name module:GameProperties#ITEM_NAME_CHAIR */ export const ITEM_NAME_CHAIR = 'Stuhl'; /** * Set the name for the table * @name module:GameProperties#ITEM_NAME_TABLE */ export const ITEM_NAME_TABLE = 'Tisch'; /** * Set the name for the bed * @name module:GameProperties#ITEM_NAME_BED */ export const ITEM_NAME_BED = 'Bett'; /** * Set the name for the bookcase * @name module:GameProperties#ITEM_NAME_BOOKCASE */ export const ITEM_NAME_BOOKCASE = 'Regal'; /** * Set the name for the chair leg * @name module:GameProperties#PART_NAME_CHAIR_ */ export const PART_NAME_CHAIR_LEG = 'Stuhlbein'; /** * Set the name for the chair back * @name module:GameProperties#PART_NAME_CHAIR_BACK */ export const PART_NAME_CHAIR_BACK = 'Lehne'; /** * Set the name for the table leg * @name module:GameProperties#PART_NAME_TABLE_LEG */ export const PART_NAME_TABLE_LEG = 'Tischbein'; /** * Set the name for the table top * @name module:GameProperties#PART_NAME_TABLE_TOP */ export const PART_NAME_TABLE_TOP = 'Tischplatte'; /** * Set the name for the bedframe * @name module:GameProperties#PART_NAME_BED_FRAME */ export const PART_NAME_BED_FRAME = 'Bettrahmen'; /** * Set the name for the bed-top * @name module:GameProperties#PART_NAME_BED_TOP */ export const PART_NAME_BED_TOP = 'Bettgestell'; /** * Set the name for the bookcase leg * @name module:GameProperties#PART_NAME_BOOKCASE_LEG */ export const PART_NAME_BOOKCASE_LEG = 'Regalrahmen'; /** * Set the name for the bookcase top * @name module:GameProperties#PART_NAME_BOOKCASE_TOP */ export const PART_NAME_BOOKCASE_TOP = 'Regalbrett'; /** * Shows a feedback text inside the market. * depending on the distance of the profit towards the optimal profit. * @name module:GameProperties#DISPLAY_FEEDBACK */ export const DISPLAY_FEEDBACK = true; /** * Specify when the optimal solution should be displayed. * possible values: * 'always' : The optimal solution is displayed every month on the summary page. * 'end' : Displays the optimal solution in the end of the last month. * 'never' : The player gets never informed about the optimal solution. * * Uncomment the statement that you want to use. * export const DISPLAY_OPTIMAL_SOLUTION = 'always'; * export const DISPLAY_OPTIMAL_SOLUTION = 'end'; * export const DISPLAY_OPTIMAL_SOLUTION = 'never'; * * @name module:GameProperties#DISPLAY_OPTIMAL_SOLUTION * */ export const DISPLAY_OPTIMAL_SOLUTION = 'always'; /** * Specify what is displayed if an optimal solution is shown. * Possible values: * 'all': displays the profit and each produced product. * 'profit': only displays the profit. * 'products': only displays the products that need to be produced to achieve the optimal profit. * * NOTE: if DISPLAY_OPTIMAL_SOLUTION is set to 'never', none of these values are displayed. * * uncomment the statement that you want to use. * export const SHOW_SOLUTION_ASPECTS = 'all'; * export const SHOW_SOLUTION_ASPECTS = 'profit'; * export const SHOW_SOLUTION_ASPECTS = 'products'; * * @name module:GameProperties#SHOW_SOLUTION_ASPECTS */ export const SHOW_SOLUTION_ASPECTS = 'all'; /** * If set to true, the player gets a summary after a month is done. * The time of the next month starts if the player closes the summary. * * @name module:GameProperties#MONTHLY_PAUSE */ export const MONTHLY_PAUSE = true; /** * Define if the diagram should be displayed. * * @name module:GameProperties#SHOW_DIAGRAM */ export const SHOW_DIAGRAM = true; /** * The text to be displayed if the user has achieved the optimal * solution in terms of profit for one month * * @name module:GameProperties#FEEDBACK_PERFECT */ export const FEEDBACK_PERFECT = 'Perfekt!'; /** * The text for a very good solution * @name module:GameProperties#FEEDBACK_VERY_GOOD */ export const FEEDBACK_VERY_GOOD = 'Sehr gut!'; /** * Specify what proportion of the own solution regarding * the optimal solution will count as 'very good' * if set to 0.9, everything from 90% of the optimal * solution and above will count as 'very good', until 1 is reached, which will * trigger the perfect feedback. * @name module:GameProperties#PERCENTAGE_VERY_GOOD */ export const PERCENTAGE_VERY_GOOD = 0.95; /** * The Text for a good solution * @name module:GameProperties#FEEDBACK_GOOD */ export const FEEDBACK_GOOD = 'Nicht schlecht!'; /** * Specify at which percentage of the score depending on the optimal solution the player should * recieve a 'good' message. * Everything below that value will trigger the 'low' feedback, * values above the 'PRECENTAGE_VERY_GOOD' will trigger the 'very good' * message. * @name module:GameProperties#PERCENTAGE_GOOD */ export const PERCENTAGE_GOOD = 0.7; /** * The feedback text for a low profit, compared to the optimal * solution * * @name module:GameProperties#FEEDBACK_LOW */ export const FEEDBACK_LOW = 'Das geht besser!'; /** * This section covers sosciSurvey relevant values. * Make sure that the variable number for profit etc. is the same for model and * Player. * I.E. PL01 should be the profit for the player and MD01 should be the profit for * the Model. */ /** * Specify the variable name of the Player section * @name module:GameProperties#SOCI_PLAYER_VAR */ export const SOSCI_PLAYER_VAR = 'PL'; /** * Specify the variable name of the Model section * @name module:GameProperties#SOCI_MODEL_VAR */ export const SOSCI_MODEL_VAR = 'MD'; /** * Specify the variable name of the Player Time * @name module:GameProperties#SOCI_PLAYER_TIME_VAR */ export const SOSCI_PLAYER_TIME_VAR = 'PT01'; /** * Specify the variable name for player profit * @name module:GameProperties#SOCI_PROFIT */ export const SOSCI_PROFIT = '01'; /** * Specify the name of the variable for produced Beds * @name module:GameProperties#SOCI_BEDS */ export const SOSCI_BEDS = '02'; /** * Specify the name of the variable for produced Bookcases * @name module:GameProperties#SOCI_BOOKCASES */ export const SOSCI_BOOKCASES = '03'; /** * Specify the name of the variable for produced Tables * @name module:GameProperties#SOCI_TABLES */ export const SOSCI_TABLES = '04'; /** * Specify the name of the variable for produced Chairs * @name module:GameProperties#SOCI_CHAIRS */ export const SOSCI_CHAIRS = '05'; /** * The variable that should indicated if the player had producing workshops as the month * has changed * * @name module:GameProperties#SOCI_WAS_PRODUCING */ export const SOSCI_WAS_PRODUCING = '06'; /** * The variable that represents the free-text answers of the user. * @name module:GameProperties#SOSCI_ANSWER */ export const SOSCI_ANSWER = 'AN01'; /** * The variable represents the assessment answers of the user. * @name module:GameProperties#SOSCI_ASSESSMENT */ export const SOSCI_ASSESSMENT = 'AS'; /** * The feeback that the player gives to mike * @name module:GameProperties_SOSCI_FEEDBACK */ export const SOSCI_FEEDBACK = 'FB'; /** * The variable where the log is saved * @name module:GameProperties_SOSCI_LOG */ export const SOSCI_LOG = 'LG01_01'; /** * The minimum text length, the user needs to provide in order to answer the question. * @name module:GameProperties#MINIMUM_TEXT_SIZE */ export const MINIMUM_TEXT_SIZE = 30; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"glpkUtility.js.html":{"id":"glpkUtility.js.html","title":"Source: glpkUtility.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: glpkUtility.js import {MODEL, MONTHS, SOLUTION} from './Constants.js'; /** * @description * This module is used to parse linear problems and its solution. * It also provides tools to solve linear problems. In this case the glpk.js file must be * loaded before the game inside the website. * @see [glpk.js]{@link https://github.com/hgourvest/glpk.js} * @module glpkUtility */ /** * Read a textfile and process it with a callback function. * @function readTextFile * @memberof module:glpkUtility * @param {String} file the path to the file containing the linear problem * @param {function} callback a function that should be executed, if the file has been read. * A callback function usually writes the contents inside a variable as seen in [getLP]{@link module:glpkUtility#getLP}. */ function readTextFile(file, callback) { var rawFile = new XMLHttpRequest(); // request the file rawFile.open(\"GET\", file, false); // Create an asynchronous request rawFile.onreadystatechange = function () // if file as been read: { if(rawFile.readyState === 4) // if file is ready { if(rawFile.status === 200 || rawFile.status == 0) // and if it has been found { var allText = rawFile.responseText; // collect the text from the request (hence the file) callback(allText); // pass it to a callback function. } } } rawFile.send(null); } /** * Reads a linear problem from a file. Taken from {@link https://github.com/hgourvest/glpk.js/blob/master/test/test.js} and modified. * @function readCplexFromFile * @author [Henri Gourvest]{@link https://github.com/hgourvest} * @license GNU General Public License v2.0 * @param {object} lp the linear problem * @param {string} filename the name of the */ function readCplexFromFile(lp, filename){ var str = filename.toString(); var pos = 0; glp_read_lp(lp, null, function(){ if (pos &lt; str.length){ return str[pos++]; } else return -1; } ) } /** * Solves the linear problem and converts the result. Taken from {@link https://github.com/hgourvest/glpk.js/blob/master/test/test.js} and modified. * @function cplex * @author [Henri Gourvest]{@link https://github.com/hgourvest} * @license GNU General Public License v2.0 * @param {*} file a file in cplex format. * @returns {string} the results that are converted by [convertResult]{@link module:glpkUtility#convertResult}. */ function cplex(file){ var lp = glp_create_prob(); readCplexFromFile(lp,file); var smcp = new SMCP({presolve: GLP_ON}); glp_simplex(lp, smcp); var iocp = new IOCP({presolve: GLP_ON}); glp_intopt(lp, iocp); let result = convertResult(lp); return result; }; /** * Reads a text file and returns a linear Problem as string. It reads the model that is specified under * [MODEL]{@link module:Constants#MODEL}. * @function getLP * */ function getLP(){ let linearProblem; readTextFile(MODEL, function(text){ linearProblem = text; }); return linearProblem; } /** * This function loads the underlying linear problem and uses the [cplex]{@link module:glpkUtility#cplex} function to solve it. * @function solveLP * @returns {object} the solution of the linear problem. */ function solveLP(){ let linearProblem = getLP(); return cplex(linearProblem); } /** * This function loads a solution from file specified by the [SOLUTION]{@link module:Constants#SOLUTION} field. * @function loadSolution * @returns {object} the solution of the linear problem. */ function loadSolution(){ let solution; readTextFile(SOLUTION, function(text){ solution = text; }); solution = JSON.parse(solution); return solution; } /** * This function reads a linear problem and extracts the relevant data to run the * game. * It contains the value for every month for every item, available resources, * and costs. The structure of the linear problem object is the following: * @property {number} workshopAAvailable available hours in workshop A. * @property {number} workshopBAvailable available hours in workshop B. * @property {number} workshopCAvailable available hours in workshop C. * @property {number} workshopDAvailable available hours in workshop D. * @property {array} metalAvailable available metal for every month. * @property {array} woodAvailable available wood for every month. * @property {object} items information about the available items of the game. The keys are the names of * the different items 'bed', 'bookcase', 'chair', and 'table'. Each of these keys yields another object * with the fields: * @property {array} items.profit the profit of the item for every month. * @property {object} items.costs the costs of the specific item. See [costs]{@link module:Item~Item#costs} * @function parseLP * @memberof module:glpkUtility * */ function parseLP(){ let lpFile = getLP().split('\\n'); // Parsing profit values let filteredVarsProfit = lpFile.slice(0, lpFile.indexOf('s.t.')).filter(element =&gt; { return element.startsWith('+'); }).map(element =&gt; element.split(' ')); filteredVarsProfit.sort((a,b) =&gt; { return Number(a[1].split('x')[1]) - Number(b[1].split('x')[1]); }); let profitNumbers = filteredVarsProfit.map(e =&gt; Number(e[0])); let bedArrProfit = profitNumbers.slice(0, MONTHS); let bookcaseArrProfit = profitNumbers.slice(MONTHS, 2*MONTHS); let tableArrProfit = profitNumbers.slice(2*MONTHS, 3*MONTHS); let chairArrProfit = profitNumbers.slice(3*MONTHS, 4*MONTHS); // Parsing cost values let filteredVarsCosts = lpFile.slice(lpFile.indexOf('s.t.'), lpFile.length).filter(element =&gt; { return element.startsWith('+'); }).map(element =&gt; element.split(' '));; let bedArrCosts = filteredVarsCosts.filter(e =&gt; e[1] == 'x1' ).map(e =&gt; Number(e[0])); let bookcaseArrCosts = filteredVarsCosts.filter(e =&gt; e[1] == 'x'+Number(MONTHS+1)).map(e =&gt; Number(e[0])); let tableArrCosts = filteredVarsCosts.filter(e =&gt; e[1] == 'x'+Number(MONTHS*2+1)).map(e =&gt; Number(e[0])); let chairArrCosts = filteredVarsCosts.filter(e =&gt; e[1] == 'x'+Number(MONTHS*3+1)).map(e =&gt; Number(e[0])); // Parsing initial values let filteredConstraints = lpFile.filter(e =&gt; e.startsWith('&lt;=')); let materials = filteredConstraints.slice(0, MONTHS*2).map(e =&gt; Number(e.split(' ')[1])); let wood = []; let metal = []; for (const [x, _] of materials.entries()){ if (x % 2 == 0){ wood.push(materials[x]); }else{ metal.push(materials[x]); } } let hours = filteredConstraints.slice(MONTHS*2,MONTHS*2+4).map(e =&gt; Number(e.split(' ')[1])); // Building the linear problem as an object let lp = { workshopAAvailable: hours.shift(), workshopBAvailable: hours.shift(), workshopCAvailable: hours.shift(), workshopDAvailable: hours.shift(), metalAvailable: metal, woodAvailable: wood, items: { bed: { profit: bedArrProfit, costs: { wood: bedArrCosts.shift(), metal: bedArrCosts.shift(), hoursA: 0, hoursB: 0, hoursC: bedArrCosts.shift(), hoursD: bedArrCosts.shift() } }, bookcase: { profit: bookcaseArrProfit, costs: { wood: bookcaseArrCosts.shift(), metal: bookcaseArrCosts.shift(), hoursA: 0, hoursB: 0, hoursC: bookcaseArrCosts.shift(), hoursD: bookcaseArrCosts.shift() } }, table: { profit: tableArrProfit, costs: { wood: tableArrCosts.shift(), metal: tableArrCosts.shift(), hoursA: tableArrCosts.shift(), hoursB: tableArrCosts.shift(), hoursC: 0, hoursD: 0 } }, chair: { profit: chairArrProfit, costs: { wood: chairArrCosts.shift(), metal: chairArrCosts.shift(), hoursA: chairArrCosts.shift(), hoursB: chairArrCosts.shift(), hoursC: 0, hoursD: 0 } } } } return lp; } /** * Converts the result of the lp to enable the reading of the optimal solution * and the amount of built items for every month. * @param {*} lp */ function convertResult(lp){ let resultList = []; for( var i = 1; i &lt;= glp_get_num_cols(lp); i++){ resultList.push(glp_get_col_name(lp, i) + \" = \" + glp_mip_col_val(lp, i)); } resultList.sort((a, b) =&gt; Number(a.slice(1, a.length).split(' ')[0]) - Number(b.slice(1, b.length).split(' ')[0])) resultList = resultList.map(e =&gt; Number(e.split(' ')[2])); resultList = resultList.slice(0, resultList.length-1); let bedsBuilt = []; let bookcasesBuilt = []; let tablesBuilt = []; let chairsBuilt = []; let furniture = [bedsBuilt, bookcasesBuilt, tablesBuilt, chairsBuilt]; let itemIndex = 0; for (const [x, value] of resultList.entries()){ if (x % 12 == 0 &amp;&amp; x != 0){ itemIndex ++; } furniture[itemIndex].push(value); }; let result = { objective: glp_mip_obj_val(lp), numberOfBeds: bedsBuilt, numberOfBookCases: bookcasesBuilt, numberOfTables: tablesBuilt, numberOfChairs: chairsBuilt }; return result; } export {solveLP,loadSolution, parseLP, readTextFile}; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Item.js.html":{"id":"Item.js.html","title":"Source: Item.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Item.js /** * @module Item */ /** * @classdesc * This class implements an item, that can be built by workshops. * * @class Item * * @constructor * @param {object} data the data object contains the values the class needs to be created. * @param {string} data.name name of the item, that will be displayed to the player. * @param {object} data.costs the costs of the item (see [costs]{@link module:Item~Item#costs}). * @param {array} data.profit an array holding the price of the item for every month. * @param {Phaser.GameObjects.Sprite} [data.image] an image object of the item. This can be added to the item if an already scaled image is * present. * @param {number} data.branch a number that is 0 or 1. This value is used to define to which branch the * item belongs. Depending on the branch different workshops are assigned to the item. * @param {string} data.imageCode the image code that is used to display the image of the item. * @param {array} data.parts the parts the item consists of. This is necessary, if the option [PRODUCE_PARTS]{@link module:GameProperties#PRODUCE_PARTS} is activated. * see [parts]{@link module:Item~Item#parts}. */ class Item { constructor(data) { let {name, costs, profit, image, branch, imageCode, parts} = data; /** * The name of the item that is displayed to the player. * @type {string} */ this.name = name; /** * The costs of the item. * It consists of several parts: * * @type {object} * @property {number} wood the costs of wood * @property {number} metal the costs of metal * @property {number} hoursA the time needed in workshop A * @property {number} hoursB the time needed in workshop B * @property {number} hoursC the time needed in workshop C * @property {number} hoursD the time needed in workshop D */ this.costs = costs; /** * The profit this item yields for every month. * @type {Array} */ this.profit = profit; /** * The Image object of the item. It can be set if there is already an image to show. Otherwise * the image can created using the [imageCode]{@link module:Item~Item#imageCode}. * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.image = image; /** * The branch of the item, that defines which workshops are associated to the item. * A 0 stands for the first branch (Workshop A and B) and 1 stands for the second branch (Workshop C and D). * @type {number} */ this.branch = branch; /** * The image code for the item. This is a string that maches the string given by the corresponding * load function of the {@link Preloader}. * @see [Phaser.Loader.LoaderPlugin]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Loader.LoaderPlugin.html#image__anchor} */ this.imageCode = imageCode; /** * The parts define what needs to be built if the item should be created. * A parts is a list containing two part object. A parts object is defined as follows: * @property {string} name the name of the part that will be displayed. * @property {string} imageCode the string defining the key of the image that should be shown. * @property {number} demand defines which quantity of this part is required to build an item. * @property {object} costs defines how much a part costs. The structure is the same as the [costs]{@link module:Item~Item#costs} of an item. */ this.parts = parts; } } /** * This function is used to get the proper scaling for each item. This is necessary because the * images of the items have different sizes. By using this function, the images are scaled to the same size. * @function getScaling * @param {string} code the image code for which the scaling should be retreived. * @returns {number} the scaling of the requested image, that can be used for the [setScale]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html#setScale__anchor} * function on a sprite. * @memberof module:Item * @static */ function getScaling(code) { switch (code) { case 'chair': return 0.2; case 'table': return 0.05; case 'bed': return 0.15; case 'bookcase': return 0.4; default: return 1; } } /** * This function calculates the costs of producing a given itemPart so many times until its quantity is sufficient to * create an item. * @function scalePartsCosts * @param {object} itemPart an item part with the structure described in [parts]{@link module:Item~Item#parts}. * @returns {number} the new total costs, scaled by its demand value. * @memberof module:Item * @static */ function scalePartsCosts(itemPart) { let newCosts = {} Object.keys(itemPart.costs).forEach(e =&gt; { newCosts[e] = itemPart.costs[e] * itemPart.demand; }); return newCosts; } export default Item; export {getScaling, scalePartsCosts} × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"ItemPriceTable.js.html":{"id":"ItemPriceTable.js.html","title":"Source: ItemPriceTable.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: ItemPriceTable.js /** * @module ItemPriceTable */ /** * @description * Decides which arrow should be displayed and where the arrow should be displayed. * If oldPrice is higher than newPrice, the arrow will be red and downwards, vice versa * the arrow will be green and upwards. If they are the same, a whit line will indicate * that no change has happened. * @param {*} scene the scene, to render the symbols * @param {*} oldPrice the old price for example the price of an item one month before. * @param {*} newPrice the new price to be compared to the old price. * @param {*} x the x position where the arrow should be rendered. * @param {*} y the y position where the arrow should be rendered. */ function createArrow(scene, oldPrice, newPrice, x,y){ if (oldPrice &lt; newPrice){ return new Phaser.GameObjects.Sprite(scene,x,y,'arrow_up').setTint(0x1aff1a).setOrigin(0,0.5); }else if (oldPrice &gt; newPrice){ return new Phaser.GameObjects.Sprite(scene,x,y,'arrow_down').setTint(0xff1a1a).setOrigin(0,0.5); }else{ let symbol = new Phaser.GameObjects.Sprite(scene,x,y,'no_changes').setTint(0xd1d1d1).setOrigin(0.2,0.5); symbol.displayWidth = 20; return symbol } } /** * @classdesc * This class informs the player about the price changes in the new month, by animating a table with the pictures of the items, their old prices * and new prices. Additionally, arrows will indicate the movement of the price changes. * @class ItemPriceTable * @constructor * @param {object} data the data that is used to create the price table. * @param {Phaser.Scene} data.scene the scene where this table is rendered. * @param {number} data.x the x position where the table is rendered. * @param {number} data.y the y position where the table is rendered. * @param {number[]} data.pricesOld the old prices of the items. The first element is the old price of chair, followed by table, bed and bookcase. * @param {number[]} data.pricesOld the new prices of the items. The first element is the old price of chair, followed by table, bed and bookcase. * */ class ItemPriceTable extends Phaser.GameObjects.Container{ constructor (data){ let {scene, x, y, pricesOld, pricesNew} = data; let texts = []; let sprites = []; let spriteFrame = new Phaser.GameObjects.Sprite(scene,0,0,'panel-blue'); let spriteBed = new Phaser.GameObjects.Sprite(scene,-80,-50,'bed'); let spriteBookcase = new Phaser.GameObjects.Sprite(scene,spriteBed.x,spriteBed.y+40,'bookcase'); let spriteTable = new Phaser.GameObjects.Sprite(scene,spriteBed.x,spriteBookcase.y+40,'table'); let spriteChair = new Phaser.GameObjects.Sprite(scene,spriteBed.x,spriteTable.y+40,'chair'); let textBedOld = new Phaser.GameObjects.Text(scene, spriteBed.x+30,spriteBed.y, pricesOld[2],{color: '#000', fontSize: 25}).setOrigin(0,0.5); texts.push(textBedOld); let textBookcaseOld = new Phaser.GameObjects.Text(scene, spriteBookcase.x+30,spriteBookcase.y, pricesOld[3],{color: '#000', fontSize: 25}).setOrigin(0,0.5); texts.push(textBookcaseOld); let textTableOld = new Phaser.GameObjects.Text(scene, spriteTable.x+30,spriteTable.y, pricesOld[1],{color: '#000', fontSize: 25}).setOrigin(0,0.5); texts.push(textTableOld); let textChairOld = new Phaser.GameObjects.Text(scene, spriteChair.x+30,spriteChair.y, pricesOld[0],{color: '#000', fontSize: 25}).setOrigin(0,0.5); texts.push(textChairOld); let itemHeight = 30; let arrBed = createArrow(scene, pricesOld[2],pricesNew[2],textBedOld.x+30,textBedOld.y); let arrBookcase = createArrow(scene, pricesOld[3],pricesNew[3],textBookcaseOld.x+30,textBookcaseOld.y); let arrTable = createArrow(scene, pricesOld[1],pricesNew[1],textTableOld.x+30,textTableOld.y); let arrChair = createArrow(scene, pricesOld[0],pricesNew[0],textChairOld.x+30,textChairOld.y); let textBedNew = new Phaser.GameObjects.Text(scene, arrBed.x+30,spriteBed.y, pricesNew[2],{color: '#000', fontSize: 25}).setOrigin(0,0.5); texts.push(textBedNew); let textBookcaseNew = new Phaser.GameObjects.Text(scene, arrBookcase.x+30,spriteBookcase.y, pricesNew[3],{color: '#000', fontSize: 25}).setOrigin(0,0.5); texts.push(textBookcaseNew); let textTableNew= new Phaser.GameObjects.Text(scene, arrTable.x+30,spriteTable.y, pricesNew[1],{color: '#000', fontSize: 25}).setOrigin(0,0.5); texts.push(textTableNew); let textChairNew = new Phaser.GameObjects.Text(scene, arrChair.x+30,spriteChair.y, pricesNew[0],{color: '#000', fontSize: 25}).setOrigin(0,0.5); texts.push(textChairNew); let itemWidth = itemHeight; spriteBed.displayHeight = itemHeight; spriteBed.displayWidth = itemWidth; spriteBookcase.displayHeight = itemHeight; spriteBookcase.displayWidth = itemWidth; spriteTable.displayHeight = itemHeight-10; spriteTable.displayWidth = itemWidth; spriteChair.displayHeight = itemHeight; spriteChair.displayWidth = itemWidth; sprites.push(...[spriteBed,spriteBookcase,spriteChair,spriteTable]) spriteFrame.setScale(2); let title = new Phaser.GameObjects.Text(scene,-85,-85, 'Neue Preise!', {color: '#000', fontSize: 25}); super(scene,x,y,[spriteFrame,title,spriteBed,spriteBookcase,spriteTable,spriteChair,textBedOld,textBookcaseOld,textTableOld,textChairOld, textBedNew,textBookcaseNew,textTableNew,textChairNew,arrBed,arrBookcase,arrTable,arrChair]); this.scene = scene; this.texts = texts; this.sprites = sprites; this.sprites.map(e=&gt; e.setScale(e.scale*1.3)); this.title = title; this.spriteFrame = spriteFrame; this.setScrollFactor(0); this.scene.add.existing(this); } /** * This function animates the price table to appear at the right side, stay for 4 seconds and * slide out of the screen. */ run() { this.scene.tweens.add( { targets: this, x: 900, duration: 500, ease: Phaser.Math.Easing.Back.Out, completeDelay: 4000, onComplete: function() { this.targets[0].scene.tweens.add( { targets: this.targets[0], x: 1500, duration: 500, ease: Phaser.Math.Easing.Expo.In, completeDelay: 3000, onComplete: function() { this.targets[0].destroy(); } }); } }); } } export default ItemPriceTable; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"ProfitSummary.js.html":{"id":"ProfitSummary.js.html","title":"Source: ProfitSummary.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: ProfitSummary.js /** * @module ProfitSummary */ import Diagram from './Diagram.js'; import * as Constants from './Constants.js'; /** * @classdesc * This class is used to compare the profit of the player with the optimal solution. * Therefore several text elements as well as a diagram and feedback are generated. * It should be placed inside a {@link Panel} to ensure it is displayed properly. * * @class ProfitSummary * @extends Phaser.GameObjects.Container * @see [Phaser.GameObjects.Container]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Container.html} * * @constructor * @param {object} data the object that contains values required to buld the summary of the profit: * @param {Phaser.Scene} data.scene the Phaser scene where the summary should be displayed. This is * usually a {@link MarketDialogue}. * @param {number} data.x the x coordinate for the object. * @param {number} data.y the y coordinate for the object. * @param {Player} data.player an instance of the player to retrieve the profits. * @param {number} data.month the current month of the game. * */ class ProfitSummary extends Phaser.GameObjects.Container { constructor(data) { let {scene, x,y, lpSolution, player, month} = data; month = month -1; let ownText = new Phaser.GameObjects.Text(scene, -190,-110, 'Eigene Leistung', {fontSize:17,color: '#000'}).setOrigin(0,0.5); // Player Values let ownProfitText = new Phaser.GameObjects.Text(scene, ownText.x,ownText.y+30, '', {fontSize:17,color: '#000'}).setOrigin(0,0.5); let builtText = new Phaser.GameObjects.Text(scene, ownProfitText.x,ownProfitText.y+30, 'Hergestellt:', {fontSize:17,color: '#000'}).setOrigin(0,0.5); let producedBeds = new Phaser.GameObjects.Text(scene, ownProfitText.x, builtText.y+30, '',{fontSize:17,color: '#000'}).setOrigin(0,0.5); let producedBookcases = new Phaser.GameObjects.Text(scene, ownProfitText.x, producedBeds.y+30, '',{fontSize:17,color: '#000'}).setOrigin(0,0.5); let producedTables = new Phaser.GameObjects.Text(scene, ownProfitText.x, producedBookcases.y+30, '',{fontSize:17,color: '#000'}).setOrigin(0,0.5); let producedChairs = new Phaser.GameObjects.Text(scene, ownProfitText.x, producedTables.y+30, '',{fontSize:17,color: '#000'}).setOrigin(0,0.5); // Optimal Values let optimalText = new Phaser.GameObjects.Text(scene, -ownProfitText.x,ownText.y, '', {fontSize:17,color: '#000'}).setOrigin(1,0.5); let possibleOptimum = new Phaser.GameObjects.Text(scene, optimalText.x, builtText.y,'',{fontSize:17,color: '#000'}).setOrigin(1,0.5); let linearProfitText = new Phaser.GameObjects.Text(scene, optimalText.x,optimalText.y+30, '', {fontSize:17,color: '#000'}).setOrigin(1,0.5); let optimalBeds = new Phaser.GameObjects.Text(scene, linearProfitText.x, producedBeds.y, '', {fontSize:17,color: '#000'}).setOrigin(1,0.5); let optimalBookcases = new Phaser.GameObjects.Text(scene, linearProfitText.x, producedBookcases.y, '', {fontSize:17,color: '#000'}).setOrigin(1,0.5); let optimalTables = new Phaser.GameObjects.Text(scene, linearProfitText.x, producedTables.y, '', {fontSize:17,color: '#000'}).setOrigin(1,0.5); let optimalChairs = new Phaser.GameObjects.Text(scene, linearProfitText.x, producedChairs.y, '', {fontSize:17,color: '#000'}).setOrigin(1,0.5); let feedbackFrame = new Phaser.GameObjects.Sprite(scene, 0,235, 'panel-white').setVisible(false); feedbackFrame.displayWidth = scene.panel.panel.displayWidth; feedbackFrame.displayHeight = 60; let medal = new Phaser.GameObjects.Sprite(scene,-100,feedbackFrame.y,'').setScale(0.6).setVisible(false); let feedbackText = new Phaser.GameObjects.Text(scene, medal.x+medal.width,medal.y, '', {fontSize:17,color: '#000'}).setOrigin(0,0.5); super (scene, x ,y , [ownText, ownProfitText,builtText,producedBeds,producedChairs,producedTables,producedBookcases,optimalText,possibleOptimum,linearProfitText,optimalBeds,optimalBookcases,optimalChairs,optimalTables, feedbackFrame, feedbackText, medal]) /** * The solution of the linear problem. This is used to display the optimal solution. * * @property {list} numberOfBeds the number of beds built to work optimal for every month. * @property {list} numberOfBookCases the number of bookcases built every month. * @property {list} numberOfChairs the number of chairs built to work optimal for every month. * @property {list} numberOfTables the number of tables built to work optimal for every month. * @property {number} objective the total optimal profit for the year. */ this.lpSolution = lpSolution; /** * This is the scene that defines where this object is rendered. * * @type {Phaser.Scene} */ this.scene = scene; /** * The month from which the results should be displayed. * In this case the last month is used to display the recent profit. * * @type {number} */ this.month = month; /** * The player instance. * This is used to retrieve the profit of the player. * * @type {Player} */ this.player = player; // These values are to be manipulated using the set function this._ownProfitText = ownProfitText; this._producedBeds = producedBeds; this._producedBookcases = producedBookcases; this._producedTables = producedTables; this._producedChairs = producedChairs; /** * The display of the optimal solution. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.linearProfitText = linearProfitText; /** * The text placeholder that displays the number of optimal beds. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.optimalBeds = optimalBeds; /** * The text placeholder that displays the number of optimal bookcases. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.optimalBookcases = optimalBookcases; /** * The text placeholder that displays the number of optimal tables. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.optimalTables = optimalTables; /** * The text placeholder that displays the number of optimal chairs. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.optimalChairs = optimalChairs; /** * The text element for the headline of the optimal solution. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.optimalText = optimalText; /** * The headline for the possible optimal number of furniture built. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.possibleOptimum = possibleOptimum; /** * The Graphic that is displaying the medal, the player sees as feedback. * * @type {Phaser.GameObjects.Sprite} * @see [The Phaser Documentation]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.medal = medal; /** * The textfield that displays the feedback. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.feedbackText = feedbackText; /** * The frame around the feedback section. * @type {Phaser.GameObjects.Sprite} * @see [The Phaser Documentation]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.feedbackFrame = feedbackFrame; /** * The text element that displays the produced beds by the player. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.producedBeds = player.producedItems.beds[month]; /** * The text element that displays the produced bookcases by the player. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.producedBookcases = player.producedItems.bookcases[month]; /** * The text element that displays the produced tables by the player. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.producedTables = player.producedItems.tables[month]; /** * The text element that displays the produced chairs by the player. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.producedChairs = player.producedItems.chairs[month]; /** * A text field that displays the player's profit of the given month. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.ownProfitText = player.monthlyProfit[month]; // if the optimal solution should be displayed: if (Constants.DISPLAY_OPTIMAL_SOLUTION == 'always') { // if all solution aspects or the profit should be shown: if (Constants.SHOW_SOLUTION_ASPECTS == 'all' || Constants.SHOW_SOLUTION_ASPECTS == 'profit') { // Give the optimal text the value of the optimal profit this.optimalText.text = 'Optimale Lösung'; this.linearProfitText.text = getMonthOptimalProfit(lpSolution, month); } if (Constants.SHOW_SOLUTION_ASPECTS == 'all' || Constants.SHOW_SOLUTION_ASPECTS == 'products') { // if also the products should be shown, fill in the contents of the optimal solution. this.possibleOptimum.text = 'Mögliches Vorgehen:'; this.optimalBeds.text = this.lpSolution.numberOfBeds[month]; this.optimalBookcases.text = this.lpSolution.numberOfBookCases[month]; this.optimalTables.text = this.lpSolution.numberOfTables[month]; this.optimalChairs.text = this.lpSolution.numberOfChairs[month]; } if (Constants.SHOW_DIAGRAM) // If the diagram should be shown, add it. { this.addDiagram(); // make the diagram an object belonging to the summary: this.add(this.diagram); } } if (Constants.DISPLAY_FEEDBACK) this.makeFeedback(); // If feedback should be shown, show it. } /** * Sets the textfield for the player's produced beds to the given value with a preceeding name. * * @param {number} numberOfBeds the number that should be displayed in the text field. */ set producedBeds(numberOfBeds){ this._producedBeds.text = 'Betten: '+ numberOfBeds; // We want to give the texfield also a title. } /** * Sets the textfield for the player's produced bookcases to the given value with a preceeding name. * * @param {number} numberOfBookCases the number that should be displayed in the text field. */ set producedBookcases(numberOfBookCases){ this._producedBookcases.text = 'Regale: '+numberOfBookCases; } /** * Sets the textfield for the player's produced tables to the given value with a preceeding name. * * @param {number} numberOfTables the number that should be displayed in the text field. */ set producedTables(numberOfTables){ this._producedTables.text = 'Tische: '+numberOfTables; } /** * Sets the textfield for the player's produced chairs to the given value with a preceeding name. * * @param {number} numberOfChairs the number that should be displayed in the text field. */ set producedChairs(numberOfChairs){ this._producedChairs.text = 'Stühle: '+numberOfChairs; } /** * Sets the textfield to display the given profit. * * @param {number} profit the profit that should be displayed. */ set ownProfitText(profit){ this._ownProfitText.text = 'Profit: '+profit; } /** * Adds a diagram object to bottom of the Dialogue. */ addDiagram(){ this.diagram = new Diagram({ scene: this.scene, lpProfits: getAllOptimalProfits(this.lpSolution), playerProfits: this.player.monthlyProfit, months: Constants.MONTHS, x: -75, y: 75 }); } /** * Initiates the feedback towards the player. * The threshold values can be defined in [GameProperties]{@link module:GameProperties}. * @param {bool} isFinal defines if this is the feedback for the final solution at the end of the year. * @returns nothing, but the objects inside this dialogue responsible for the feedback ([medal]{@link ProfitSummary#medal}, * [feedbackText]{@link ProfitSummary#feedbackText} and [feedbackFrame]{@link ProfitSummary#feedbackFrame}) are made visible and filled with the feedback. */ makeFeedback(isFinal=false){ if (isFinal) // did we finish the year? { this.medal.setVisible(false); // We don't need the medal as we have a final text. this.feedbackText.x = this.feedbackFrame.x; this.feedbackFrame.setVisible(true); this.feedbackText.text = 'Gute Arbeit!'; // display this text to the user this.feedbackText.setOrigin(0.5); // center it inside the feedback frame. return; // nothing more to do. } else // We are in a normal month { // Calculate the percentage of the optimal solution the player reached. var percentage = this.player.monthlyProfit[this.month]/getMonthOptimalProfit(this.lpSolution, this.month); } this.medal.setVisible(true); // display the medal this.feedbackFrame.setVisible(true); // and the frame of the feedback. if (percentage === 1){ // reached 100%? this.feedbackText.text = Constants.FEEDBACK_PERFECT; this.medal.setTexture('medal-perfect'); // perfect feedback return; } if (percentage &gt;= Constants.PERCENTAGE_VERY_GOOD){ // better than the very good threshold. this.feedbackText.text = Constants.FEEDBACK_VERY_GOOD; this.medal.setTexture('medal-very-good'); return; } if (percentage &gt;= Constants.PERCENTAGE_GOOD){ // better than the goood threshold this.feedbackText.text = Constants.FEEDBACK_GOOD; this.medal.setTexture('medal-good'); return; } // anything below: this.feedbackText.text = Constants.FEEDBACK_LOW; this.medal.setTexture('medal-hammer').setScale(0.25); } /** * This method is used for the summary after the whole year. * instead of drawing just the profit of the last month, all values * are summed up. */ setFinalValues() { // Print values of the player this.ownProfitText = this.player.money; this.producedChairs = this.player.producedItems.chairs.reduce((a,b) =&gt; a+b); this.producedTables = this.player.producedItems.tables.reduce((a,b) =&gt; a+b); this.producedBeds = this.player.producedItems.beds.reduce((a,b) =&gt; a+b); this.producedBookcases = this.player.producedItems.bookcases.reduce((a,b) =&gt; a+b); // Print optimal values if (Constants.DISPLAY_OPTIMAL_SOLUTION == 'end' || Constants.DISPLAY_OPTIMAL_SOLUTION == 'always') { if (Constants.SHOW_SOLUTION_ASPECTS == 'all' || Constants.SHOW_SOLUTION_ASPECTS == 'profit') { this.optimalText.text = 'Optimale Lösung'; let optimalProfit = getAllOptimalProfits(this.lpSolution).reduce((a,b) =&gt; a+b); this.linearProfitText.text = optimalProfit; } if (Constants.SHOW_SOLUTION_ASPECTS == 'all' || Constants.SHOW_SOLUTION_ASPECTS == 'products') { this.possibleOptimum.text = 'Mögliches Vorgehen:'; this.optimalChairs.text = this.lpSolution.numberOfChairs.reduce((a,b) =&gt; a+b); this.optimalTables.text = this.lpSolution.numberOfTables.reduce((a,b) =&gt; a+b); this.optimalBeds.text = this.lpSolution.numberOfBeds.reduce((a,b) =&gt; a+b); this.optimalBookcases.text = this.lpSolution.numberOfBookCases.reduce((a,b) =&gt; a+b); } } if (!this.diagram &amp;&amp; Constants.SHOW_DIAGRAM) { this.addDiagram(); this.add(this.diagram); } this.makeFeedback(true); } } /** * Multiplies every item with its price at the given month and adds them up * to generate an optimal profit for a month. * @param {Object} the linear problem solution to get the values from. * @param {Number} month the actual month starting at zero. */ function getMonthOptimalProfit(lp, month){ let profitBed = lp.numberOfBeds[month]*Constants.BED.profit[month]; let profitBookcase = lp.numberOfBookCases[month]*Constants.BOOKCASE.profit[month]; let profitTable = lp.numberOfTables[month]*Constants.TABLE.profit[month]; let profitChair = lp.numberOfChairs[month]*Constants.CHAIR.profit[month]; return profitBed+profitBookcase+profitTable+profitChair; } /** * Retrieves the optimal profit for every month and stores returns that list. * @param {object} the optimal solution that usually has been generated by the function [loadSolution]{@link glpkUtility#loadSolution}. * */ function getAllOptimalProfits(lp){ let profits = []; for (let i =0; i&lt; Constants.MONTHS; i++){ profits.push(getMonthOptimalProfit(lp, i)); } return profits; } export default ProfitSummary; export {getMonthOptimalProfit, getAllOptimalProfits}; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"SosciWriter.js.html":{"id":"SosciWriter.js.html","title":"Source: SosciWriter.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: SosciWriter.js import * as Constants from './Constants.js'; import { SOSCI_LOG } from './GameProperties.js'; /** * @description * This module provides function that are used to write variables to SosciSurvey. * @module SosciWriter */ /** * Write the Profit into the corresponding intern variable. * @param {string} target the target. Could be 'player' or 'model' and specifies if the profit * should be added to the player or to the model. * @param {int} month the number of the month starting from 0. * @param {int} profit the profit of the model or player for the given month. */ function writeProfit(target,month,profit){ let variable = getVariable(getTarget(target)+Constants.SOSCI_PROFIT, month+1); writeValue(variable, profit); } /** * This function is used to write the answers of a user to the corresponding * SosciSurvey variable. * The Variable specified at [SOSCI_ANSWER]{@link module:GameProperties#SOSCI_ANSWER} is used as the * variable where the answers are stored. To assign the answers, question numbers are used, corresponding * to the items at SosciSurvey. * @param {number} questionNumber the question number to specify to which item the user's text should be written. * @param {String} answer the answer of the user. */ export function writeAnswer(questionNumber, answer) { let variable = getVariable(Constants.SOSCI_ANSWER, questionNumber); writeValue(variable, answer); } /** * Writes the assessment value to soscisurvey question. The assesment number stands for a question. * The likert-scaled answer of the player will be represented by item 01 and the freetext answer will be * represented as item 02. Thus an assessment answer has always 2 items. * In sosci survey it can look like: AS01_01 for the likert answer of the first assessment question and AS01_02 for the freetext answer * of the same assessment dialogue accordingly. * @param {number} assessmentNumber the number of the assesment question at soscisurvey. * @param {number} option the likert answer of the user. * @param {string} answer the fee-text answer of the user. * @param {boolean} mike defines whether this answer is the own assessment or feedback to mike (thus, comes from an AiDialogue) */ export function writeAssessment(assessmentNumber, option, answer, mike=false) { let key; // Ensure that the given numbers will be converted with leading zeros // Necessary because sosci survey creates variables like AS01. let number = assessmentNumber.toString().padStart(2,'0'); if (mike) { key = Constants.SOSCI_FEEDBACK+number; } else key = Constants.SOSCI_ASSESSMENT+number; let likert_answer = getVariable(key,1); let freetext = getVariable(key,2); writeValue(likert_answer,option); writeValue(freetext,answer); } /** * Write the production status to SosciSurvey. This is helpful to get an idea * if the player has been interrupted during the change of a month, which * could serve as an indication that the available time per month should be adjusted. * @param {int} month the number of the month starting from 0. * @param {boolean} status set true, if the player was producing during the month change, * false if not. */ export function writeProducingStatus(month, status) { let variable = getVariable(Constants.SOSCI_PLAYER_VAR+Constants.SOSCI_WAS_PRODUCING, month+1); writeValue(variable, status); } /** * Write the number of produced item for a given month to the corresponding * SosciSurvey variable. * * EXAMPLE: writeProducedItems('player', 0, { * beds: 1, * bookcases: 30, * tables: 20, * chairs: 15 * }); * Writes the given amount of items to the player variable for the month january. * @param {string} target Could be 'player' or 'model' and defines, if the value should be * written to a player or to a model variable. * @param {int} month the number of the month starting from 0. * @param {Object} items an object containing the item numbers. * Must contain the keys 'beds', 'bookcases', 'tables', 'chairs'. */ export function writeProducedItems(target,month,items){ let _target = getTarget(target); let beds = getVariable(_target+Constants.SOSCI_BEDS,month+1); let bookcases = getVariable(_target+Constants.SOSCI_BOOKCASES,month+1); let tables = getVariable(_target+Constants.SOSCI_TABLES,month+1); let chairs = getVariable(_target+Constants.SOSCI_CHAIRS,month+1); writeValue(beds, items.beds); writeValue(bookcases, items.bookcases); writeValue(tables, items.tables); writeValue(chairs, items.chairs); } /** * Writes the elapsed time to the corresponding SosciSurvey variable. * @param {int} month the month to specify the Sosci variable * @param {int} time the elapsed time to store in milliseconds */ export function writeTime(month, time){ let variable = getVariable(Constants.SOSCI_PLAYER_TIME_VAR,month+1); writeValue(variable, time); } /** * Write a value to a given SosciSurvey variable * @param {object} variable a dom object obtained by getVariable(). * @param {*} value the value that should be written inside the given variable. */ function writeValue(variable, value){ variable.value = value; } /** * Returns a DOM object of the given variable. * EXAMPLE: getVariable('PL01',1) returns the intern SosciSurvey variable 'PL01_01' * @param {string} varName The name of the intern variable. Must be the same as in SosciSurvey. * @param {int} varNumber The number of the item inside the intern variable. */ function getVariable(varName, varNumber){ return document.getElementById(varName+'_'+varNumber.toString().padStart(2,'0')); } /** * Get the variable name of a Sosci Survey variable given the intuitive name. * @param {sting} target the target that should be converted to the * SosciSurvey variable. Could be 'player' or 'model'. */ function getTarget(target){ if (target === 'player'){ return Constants.SOSCI_PLAYER_VAR; }else if (target === 'model'){ return Constants.SOSCI_MODEL_VAR; } } /** * Write the final log to the corresponding SoSci Variable. * @param {string} log the log string containing the actions of the Player. * @see EventDispatcher */ export function writeLog(log) { let variable = document.getElementById(Constants.SOSCI_LOG); writeValue(variable,log); } /** * Disables the 'next' button. */ export function disableNextButton(){ SoSciTools.submitButtonsHide(); } /** * Submits the recorded values to SosciSurvey. */ export function submit(){ SoSciTools.submitPage(); } export {writeProfit}; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"NewsScene.js.html":{"id":"NewsScene.js.html","title":"Source: NewsScene.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: NewsScene.js import Diagram from './Diagram.js'; import DialogueScene from \"./DialogueScene.js\"; import ItemPriceTable from './ItemPriceTable.js'; import { MONTHS } from './Constants.js'; import { getAllOptimalProfits } from './ProfitSummary.js'; import Button from './Button.js'; import InteractionScene from './InteractionScene.js'; /** * @classdesc * This Class servs as a summary of the last month while providing * information about the coming month. * After closing this dialogue, the new month will start. */ class NewsScene extends InteractionScene { constructor() { super('newsScene'); } /** * Create all the gameObjects necessary to create the scene. */ create() { /** * The background sprite. It is a black, slightly transparent rectangle, that is used to darken the * background. * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.background = new Phaser.GameObjects.Sprite(this, 0,0,'shadow-background').setScale(9); // making the backround transparent to animate its fade in later this.background.alpha = 0; // add the background to the scene this.add.existing(this.background); this.createDialogue(); // We overwrite the typical panel texture by a newspaper texture. this.panel.panel.setTexture('newspaper'); // we don't need the white paper texture in this case. this.panel.contents.destroy(); // we also do not need the close button as we will have a \"continue\" button. this.panel.buttonRound.destroy(); // delete the cross... this.panel.cross.destroy(); // ...and the header text this.panel.headerText.destroy(); this.addDiagram(); this.displayPriceChanges(); this.displayNewResouces(); this.addButtonSection(); // animate the fade in for the black backround. this.tweens.add( { targets: this.background, alpha: 1, duration: 1000 } ); // make the newpaper appear. this.fadeIn(); } /** * This function displays the price changes on the newspaper. * It just creates a new {@link PriceTable} object and changes it to fit inside the newspaper * displayed in this scene. */ displayPriceChanges() { let newPrices = []; let oldPrices = []; let title = new Phaser.GameObjects.Text(this, -200,80, 'Neuer Profit', {fontSize: 20, color: '#000'}).setOrigin(0.5); this.mainScene.items.forEach(item =&gt; { newPrices.push(item.profit[this.mainScene.month.value]); oldPrices.push(item.profit[this.mainScene.month.value-1]); }); /** * The price table that is used to display the price changes on the newspaper. * @type {ItemPriceTable} */ this.priceTable = new ItemPriceTable( { scene: this, x: -170, y: 180, pricesOld: oldPrices, pricesNew: newPrices }); this.priceTable.title.destroy(); this.priceTable.spriteFrame.destroy(); this.priceTable.setScale(1); this.panel.add(title); this.panel.add(this.priceTable); } /** * Adds the button to continue with the next month. */ addButtonSection() { let title = new Phaser.GameObjects.Text(this, 205,80, 'Monat Beginnen', {fontSize: 20, color: '#000'}).setOrigin(0.5); let descriptionText = new Phaser.GameObjects.Text(this, title.x-5,140, 'Klicke auf \"Starten\"\\num einen neuen Monat\\nzu beginnen.', {fontSize: 15,color: '#000'}).setOrigin(0.5); let button = new Phaser.GameObjects.Sprite(this, title.x,260, 'button-long'); button.displayWidth -= 30; let buttonText = new Phaser.GameObjects.Text(this, button.x, button.y, 'Starten', {fontSize: 18, color: '#fff'}).setOrigin(0.5); this.panel.add([title, descriptionText, button, buttonText]); button.setInteractive(); button.on('pointerdown', function() { button.setTexture('button-long-pressed'); button.once('pointerup', function() { this.mainScene.startTimer(); this.close(); }, this); this.input.on('pointerup', function() { button.setTexture('button-long'); },this); }, this); } /** * Display the new resources available in the next month. */ displayNewResouces() { let title = new Phaser.GameObjects.Text(this, 0,90, 'Verfügbares\\nMaterial', {fontSize: 20, color: '#000', align: 'center'}).setOrigin(0.5); let description = new Phaser.GameObjects.Text(this,0,150, 'In diesem Monat\\nhat die Furniture C.O.\\ndie folgenden\\nRohstoffe:', {fontSize: 15, color: '#000', align:'left'}).setOrigin(0.5); let woodText = new Phaser.GameObjects.Text(this, -90,200, this.mainScene.player.availableWood[this.mainScene.month.value], {fontSize: 18, color: '#000'}).setOrigin(0.2);; let woodPicture = new Phaser.GameObjects.Sprite(this, woodText.x+woodText.width, woodText.y, 'wood').setScale(0.05).setOrigin(0, 0.3); let metalText = new Phaser.GameObjects.Text(this, woodText.x,woodText.y+30, this.mainScene.player.availableMetal[this.mainScene.month.value], {fontSize: 18, color: '#000'}).setOrigin(0.2);; let metalPicture = new Phaser.GameObjects.Sprite(this, metalText.x+metalText.width, metalText.y, 'metal').setScale(0.05).setOrigin(0, 0.3); this.panel.add([woodText, woodPicture, metalText, metalPicture, title, description]); } /** * Add the diagram to the dialogue */ addDiagram() { this.diagram = new Diagram( { scene: this, x : -140, y: 5, lpProfits: getAllOptimalProfits(this.mainScene.lpSolution), playerProfits: this.mainScene.player.monthlyProfit, months: MONTHS, height: 100, width: 510 }); this.panel.add(this.diagram); } } export default NewsScene; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Panel.js.html":{"id":"Panel.js.html","title":"Source: Panel.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Panel.js /** * @classdesc * This class implements a basic panel that acts as a frame for every dialogue. * It is use by the {@link DialogueScene} which gives the functionality to its child classes. * These classes then add their elements to this panel, which ensures that all the elements * are located relatively to the panel. * * @constructor * @param {object} data the data that is used by the constructor to create the panel. * @param {Phaser.Scene} data.scene the scene where the panel should be placed. See [Phaser.Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html} * @param {Number} data.x the x coordinate where the panel should be displayed. * @param {Number} data.y the y coordinate for the panel. * @param {Number} data.width the width of the panel. * @paran {Number} data.height defines the height of the panel. * @param {String} data.header defines the headline of the dialogue. */ class Panel extends Phaser.GameObjects.Container { constructor(data) { let {scene, x, y, width, height, header} = data; let panel = new Phaser.GameObjects.Sprite(scene, 0,0, 'panel'); let contents = new Phaser.GameObjects.Sprite(scene, -1,-5, 'panel-contents'); panel.displayWidth = width; panel.displayHeight = height; contents.displayHeight = panel.displayHeight - 50; contents.displayWidth = panel.displayWidth - 70; let buttonRound = new Phaser.GameObjects.Sprite(scene, panel.x-40+panel.displayWidth/2, panel.y+20-panel.displayHeight/2, 'round-button').setOrigin(0,0.5).setScale(1.5); let cross = new Phaser.GameObjects.Sprite(scene, buttonRound.x,buttonRound.y, 'cross').setOrigin(-0.6,0.5).setScale(1.5); let headerText = new Phaser.GameObjects.Text(scene, panel.x, contents.y-contents.displayHeight/2, header, {fontSize:24,color: '#000'}).setOrigin(0.5, -0.8); super(scene,x,y,[panel, contents, buttonRound, cross, headerText]); scene.add.existing(this); this.setScrollFactor(0); buttonRound.setInteractive(); buttonRound.once('pointerdown', function(){ this.scene.close(); }); /** * This is the main frame of the panel, realized as a brown window. This is later be filled * by a [contents]{@link Panel#contents} object, acting as a paper on top of the brown frame. * * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.panel = panel; /** * This is a round button that can be used to close the panel. * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.buttonRound = buttonRound; /** * The cross is inside the [buttonRound]{@link Panel#buttonRound} and helps the button to look like a typical close button. * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.cross = cross; /** * The contents sprite is on top of the [panel]{@link Panel#panel} and looks like paper. * @type {Phaser.GameObjects.Sprite} * @see [Phaser.GameObjects.Sprite]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} */ this.contents = contents; /** * The scale of the panel. This value is used to animate its appearance. Initially the scale is 0 hence, the * panel is not visible. With the [fadeIn]{@link DialogueScene#fadeIn} function the value is used to create an opening animation. * * @type {number} */ this.scale = 0; /** * The text container that displays the headline on top of the dialogue panel. * @type {Phaser.GameObjects.BitmapText} * @see [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} */ this.headerText = headerText; } /** * Adjust the font size of the header * @param {Number} size the new fontsize the header should get */ set headerSize(size) { this.headerText.fontSize = size; } /** * Hides the close button to prevent the player from closing the panel. */ disableCloseButton() { this.buttonRound.setVisible(false); this.cross.setVisible(false); } } export default Panel; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"PartDisplay.js.html":{"id":"PartDisplay.js.html","title":"Source: PartDisplay.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: PartDisplay.js import Button from \"./Button.js\"; import { PRODUCE_ONE_CLICK } from './Constants.js'; import { PRODUCE_IN_MANAGEMENT } from \"./GameProperties.js\"; import { scalePartsCosts } from \"./Item.js\"; /** * @classdesc * This class displays the parts of an item and has buttons to initiate its production. * * @class PartDisplay * @extends Phaser.GameObjects.Container * @see [Phaser.GameObjects.Container]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Container.html} * * @constructor * @param {object} data the object that contains the values required to build the part display. * @param {Phaser.Scene} data.scene A phaser scene that defines where the Display is rendered. * @param {number} data.x the x coordinate for the object. * @param {number} data.y the y coordinate for the object. * @param {Item} data.item the item. This item provides the parts that will be displayed * inside the part display. * */ class PartDisplay extends Phaser.GameObjects.Container { constructor(data) { let {scene, x, y, item} = data; // Initiate the visible resources needed: let partDisplay = new Phaser.GameObjects.Sprite(scene, 0, 0, 'part-display').setScale(2.5); let header = new Phaser.GameObjects.Text(scene, 0,-110, 'Einzelteile', {fontSize: 15,color: '#000'}); // Images for the two parts let partOne = new Phaser.GameObjects.Sprite(scene, -20, -40, item.parts[0].imageCode).setScale(2.5).setScale(1); let partTwo = new Phaser.GameObjects.Sprite(scene, -20, 60, item.parts[1].imageCode).setScale(2.5).setScale(1); // names of the two parts let partOneText = new Phaser.GameObjects.Text(scene, 60,-80, item.parts[0].demand + 'x'+item.parts[0].name, {fontSize: 15,color: '#000'}).setOrigin(0.5,0.5); let partTwoText = new Phaser.GameObjects.Text(scene, 60,15, item.parts[1].demand + 'x'+item.parts[1].name, {fontSize: 15,color: '#000'}).setOrigin(0.5,0.5); // Set the costs. Scale them if the everything needs to be produced with just one click. let costsOne = item.parts[0].costs; let costsTwo = item.parts[1].costs; if (PRODUCE_ONE_CLICK) { costsOne = scalePartsCosts(item.parts[0]); costsTwo = scalePartsCosts(item.parts[1]); } let costsWoodOne = new Phaser.GameObjects.Text(scene, partOneText.x-40,partOneText.y+20, costsOne.wood, {fontSize: 15,color: '#000'}).setOrigin(0.5,0.5); let woodOne = new Phaser.GameObjects.Sprite(scene, costsWoodOne.x+costsWoodOne.width, costsWoodOne.y,'wood').setScale(0.04).setOrigin(0,0.5); let costsMetalOne = new Phaser.GameObjects.Text(scene, costsWoodOne.x,costsWoodOne.y+20, costsOne.metal, {fontSize: 15,color: '#000'}).setOrigin(0.5,0.5); let metalOne = new Phaser.GameObjects.Sprite(scene, costsMetalOne.x+costsMetalOne.width, costsMetalOne.y, 'metal').setOrigin(0,0.5).setScale(0.05); let costsWoodTwo = new Phaser.GameObjects.Text(scene, costsWoodOne.x,partTwoText.y+20, costsTwo.wood, {fontSize: 15,color: '#000'}).setOrigin(0.5,0.5); let woodTwo = new Phaser.GameObjects.Sprite(scene, costsWoodTwo.x+costsWoodTwo.width, costsWoodTwo.y,'wood').setScale(0.04).setOrigin(0,0.5); let costsMetalTwo = new Phaser.GameObjects.Text(scene, costsWoodTwo.x,costsWoodTwo.y+20, costsTwo.metal, {fontSize: 15,color: '#000'}).setOrigin(0.5,0.5); let metalTwo = new Phaser.GameObjects.Sprite(scene, costsMetalTwo.x+costsMetalTwo.width, costsMetalTwo.y, 'metal').setOrigin(0,0.5).setScale(0.05); let workshopOne, workshopTwo, hoursOne, hoursTwo; if (item.branch == 0) { workshopOne = scene.mainScene.workshopA.image; hoursOne = costsOne.hoursA; workshopTwo = scene.mainScene.workshopB.image; hoursTwo = costsTwo.hoursB; } else if (item.branch == 1) { workshopOne = scene.mainScene.workshopC.image; hoursOne = costsOne.hoursC; workshopTwo = scene.mainScene.workshopD.image; hoursTwo = costsTwo.hoursD; } let durationOne = new Phaser.GameObjects.Text(scene, costsWoodOne.x,costsMetalOne.y+20,hoursOne + ' in', {fontSize: 15,color: '#000'}).setOrigin(0.08,0.5); let pictureOne = new Phaser.GameObjects.Sprite(scene, durationOne.x+durationOne.width,durationOne.y,workshopOne).setScale(0.38).setOrigin(0,0.5); let durationTwo = new Phaser.GameObjects.Text(scene, costsWoodOne.x,metalTwo.y+20,hoursTwo+' in', {fontSize: 15,color: '#000'}).setOrigin(0.06,0.5); let pictureTwo = new Phaser.GameObjects.Sprite(scene, durationTwo.x+durationTwo.width,durationTwo.y,workshopTwo).setScale(0.38).setOrigin(0,0.5); super(scene, x, y, [partDisplay, header, partOne,partTwo, partOneText,partTwoText,costsWoodOne,woodOne,costsMetalOne,metalOne, durationOne, pictureOne,costsWoodTwo,woodTwo,costsMetalTwo,metalTwo,durationOne,durationTwo,pictureOne,pictureTwo]); this.metalOne = metalOne; this.metalTwo = metalTwo; /** * This is the scene that defines where this object is rendered. * * @type {Phaser.Scene} */ this.scene = scene; /** * The costs of the first part of the item. It is used to display the costs of the * part in the user interface. * If the option [PRODUCE_ONE_CLICK]{@link module:GameProperties#PRODUCE_ONE_CLICK} is activated, * the costs are scaled to represent the total costs of producing the amount of parts to built the final item. * As an example: If the part costs 1 metal but the part is required 4 time to produce the item, its * costs will be displayed as 4 metal. * * @property {number} wood the costs of wood * @property {number} metal the costs of metal * @property {number} hoursA the time needed in workshop A * @property {number} hoursB the time needed in workshop B * @property {number} hoursC the time needed in workshop C * @property {number} hoursD the time needed in workshop D */ this.costsOne = costsOne; /** * The same as for [costsOne]{@link PartDisplay#costsOne} but for the second item. */ this.costsTwo = costsTwo; /** * This is the item that should be produced. From this property the parts are read and * displayed. * * @type {Item} */ this.item = item; if (PRODUCE_IN_MANAGEMENT) { this.createProduceButtons(); } /** * Defines if the display is currently active, which means that it is visible. * @type {boolean} */ this.active = false; } /** * This function will be delivered to the two buttons that are created in this class. * It initiates the building process of the part after checking if it can be produced. * @see Button */ callbackFunction() { let scaledItem = {...this.item}; let productionAmount = 1; if (PRODUCE_ONE_CLICK) { scaledItem.costs = this.costs; productionAmount = this.item.demand; } let result = this.scene.management.canAfford(scaledItem); if (result.status) { for (let i = 0; i &lt; productionAmount; i++) { this.scene.management.produce(this.item); } this.scene.clickSound.play(); this.button.showMessage('Wird gebaut!'); } else { this.scene.errorSound.play(); this.button.showMessage(result.reason, true); } } /** * The setter for the activity status of this display. * If it is set to true, it will animate its appearance. * If set to false it will deactivate itself with an anmation. * * @param {boolean} val The value to set partDisplay active or inactive. */ set active(val) { this._active = val if (this._active) { this.scene.tweens.add ( { targets: this, alpha: 1, duration: 500, ease: Phaser.Math.Easing.Sine.Out } ); } else { this.scene.tweens.add ( { targets: this, alpha: 0, duration: 500, ease: Phaser.Math.Easing.Sine.Out } ); } } /** * Requests the active value. * @returns {boolean} a boolean indicating if the partDisplay is active. */ get active() { return this._active; } /** * This function creates two buttons to produce the parts. * It is only invoked, if [PRODUCE_IN_MANAGEMENT]{@link module:GameProperties#PRODUCE_IN_MANAGEMENT} is set to `true` is true. */ createProduceButtons() { /** * The button for the first item. * If it is clicked, the first part will be produced. * This button is created if [PRODUCE_IN_MANAGEMENT]{@link module:GameProperties#PRODUCE_IN_MANAGEMENT} is set to `true`. * * @type {Button} */ this.buttonOne = new Button(this.scene,140,this.metalOne.y,'button-square-unpressed','button-square','notes', this.callbackFunction, undefined, this.item.parts[0].name); this.buttonOne.setImageScale(0.25); /** * This is the context that is given to the first button. * The context is assigned individually, which enables to have only one [callbackFunction]{@link PartDisplay#callbackFunction} * for both buttons. The different contexts represent the data that is used by the callback function to initiate the production of the parts. * * @property {Phaser.Scene} scene The scene that is used by this class * @property {Button} button the button to trigger the message. * @property {object} item this should be an object representing an [itempart]{@link Item#parts}. * @property {object} costs the (scaled) costs of the item, depending on the options. See {@link PartDisplay#costsOne}. * */ this.buttonOne.setContext( { scene: this.scene, button: this.buttonOne, item: this.item.parts[0], costs: this.costsOne }); // The button is near the right border, so we push the text more to the left. // This ensures that it is readable. this.buttonOne.messageOffsetX = -60; this.add(this.buttonOne); /** * This is the second button, representing the second part of the item. * @type {Button} */ this.buttonTwo = new Button(this.scene,140,this.metalTwo.y,'button-square-unpressed','button-square','notes', this.callbackFunction,undefined, this.item.parts[1].name); this.buttonTwo.setImageScale(0.25); // We use this context to produce a specific item without needing to write a whole new // callback function, since the callback function for both buttons will use individual contexts. this.buttonTwo.setContext( { scene: this.scene, button: this.buttonTwo, item: this.item.parts[1], costs: this.costsTwo }); this.buttonTwo.messageOffsetX = -60; this.add([this.buttonOne, this.buttonTwo]); } } export default PartDisplay; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Player.js.html":{"id":"Player.js.html","title":"Source: Player.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Player.js import {MONTHS} from './Constants.js'; /** * @classdesc * This class implements the data of the player. * It also keeps track of the profit, available material and produced items. * @calss Player * @constructor * @param {Object} data a data object containing the required information. * @param {Phaser.Scene} data.scene the scene the player belongs to. This is usually the {@link MainScene}. * @param {number[]} data.availableWood the wood the player has availlable each month. * @param {number[]} data.availableMetal the metal the player has availlable each month. */ class Player { constructor(data) { this.scene = data.scene; /** * The money the player has throughout the game. */ this.money = 0; /** * This field keeps track of the profit that is made each month. * @type{number[]} */ this.monthlyProfit = []; /** * The available wood of the player for each month * @type{number[]} * @example * player.availableWood[3]; // --&gt; Gives the wood available in the fourth month. */ this.availableWood = data.availableWood; /** * The available metal the player has at each month. * @type{number[]} */ this.availableMetal = data.availableMetal; /** * The initial wood. This value will not be changed. This helps to look up what the player has at * the beginning of a given month. * @type{number[]} */ this.initialWood = [...data.availableWood]; /** * The initial metal the player has at the beginning of a given month. * @type{number[]} */ this.initialMetal = [...data.availableMetal]; /** * The items that the player has produced each month. * @property {number[]} chairs The number of chairs built throughout the year. * @property {number[]} tables The number of tables for each month. * @property {number[]} beds The number of beds. * @property {number[]} bookcases The number of bookcases for each month. */ this.producedItems = { chairs: new Array(MONTHS).fill(0), tables: new Array(MONTHS).fill(0), beds: new Array(MONTHS).fill(0), bookcases: new Array(MONTHS).fill(0) }; } } export default Player; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Preloader.js.html":{"id":"Preloader.js.html","title":"Source: Preloader.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Preloader.js import { disableNextButton } from './SosciWriter.js'; import { ON_LOCAL_MACHINE } from './Constants.js'; /** * @classdesc * This class is used to load all resources of the game while showing a loading screeen. */ class Preloader extends Phaser.Scene { constructor() { super({ key:'preloader', pack: {files: [ { type: 'image', key: 'logo', url: 'logo.png' } ]} }); } /** * This function is called to hide the next button on soscisurvey. */ init() { if (!ON_LOCAL_MACHINE){ // hide the next button of the SosciSurvey website. disableNextButton(); } } /** * In this function all resources should be loaded to make sure it happens once before the game starts. * This increases performance. */ preload() { this.add.image(400,300,'logo'); var progressBar = this.add.graphics(); var progressBox = this.add.graphics(); progressBox.fillStyle(0x222222, 0.8); progressBox.fillRect(240, 430, 320, 50); this.load.on('progress', function(value) { progressBar.clear(); progressBar.fillStyle(0xffffff,1); progressBar.fillRect(250,440,300*value,30); }); // Map this.load.image('tiles-medival', 'RTS_medieval2-ex.png'); this.load.image('tiles-scifi', 'scifi_tilesheet2-ex.png'); this.load.tilemapTiledJSON('map', 'furniture_company_map.xml'); //Buildings this.load.image('workshop-a', 'workshop-a.png'); this.load.image('workshop-b', 'workshop-b.png'); this.load.image('workshop-c', 'workshop-c.png'); this.load.image('workshop-d', 'workshop-d.png'); this.load.image('management_one', 'management_a.png'); this.load.image('management_two', 'management_b.png'); this.load.image('market', 'market.png'); this.load.image('storage', 'storage.png'); this.load.image('sign1', 'sign1.png'); this.load.image('sign2', 'sign2.png'); this.load.image('sign-a', 'Sign_legs.png'); this.load.image('sign-b', 'sign_b.png'); this.load.image('sign-c', 'sign_c.png'); this.load.image('sign-d', 'sign_d.png'); // Items this.load.image('wood', 'wood_item.png'); this.load.image('metal', 'iron.png'); this.load.image('gold', 'gold.png'); this.load.image('chair', 'chair.png'); this.load.image('chair-leg', 'chair_leg.png'); this.load.image('chair-back', 'chair_back.png'); this.load.image('table', 'table.png'); this.load.image('table-leg', 'table_leg.png'); this.load.image('table-top', 'table_top.png'); this.load.image('bed', 'bed.png'); this.load.image('bed-frame', 'bed_frame.png'); this.load.image('bed-top', 'bed_top.png'); this.load.image('bookcase', 'shelf.png'); this.load.image('bookcase-leg', 'shelf_leg.png'); this.load.image('bookcase-top', 'shelf_top.png'); // UI elements this.load.image('panel', 'panel_brown.png'); this.load.image('panel-long', 'panel_long_beige.png'); this.load.image('panel-contents', 'contents.png'); this.load.image('panel-white', 'panelWhite.png'); this.load.image('round-button', 'buttonRound_blue.png'); this.load.image('cross', 'iconCross_beige.png'); this.load.image('button-green', 'button_green.png'); this.load.image('button-green-pressed', 'button_green_pressed.png'); this.load.image('notes', 'notes_white.png'); this.load.image('ui-panel', 'upper_border.png'); this.load.image('tooltip', 'tooltip.png'); this.load.image('tooltip-right', 'tooltip_right_arr.png'); this.load.image('panel-blue', 'panel_blue.png'); this.load.image('arrow_up', 'grey_arrowUpWhite.png'); this.load.image('arrow_down', 'grey_arrowDownWhite.png'); this.load.image('no_changes', 'minus.png'); this.load.image('part-display', 'partDisplay.png'); this.load.image('button-square', 'button_square.png'); this.load.image('button-square-unpressed', 'button_square_unpressed.png'); this.load.image('button-long', 'buttonLong_blue.png'); this.load.image('button-long-pressed', 'buttonLong_blue_pressed.png'); this.load.image('wrench', 'wrench.png'); this.load.image('right', 'right.png'); this.load.image('left', 'left.png'); this.load.image('shadow-background', 'ShadowSummary.png'); this.load.image('newspaper', 'newspaper.png'); this.load.image('radio-button', 'grey_circle.png'); this.load.image('radio-button-checked', 'blue_boxTick.png'); this.load.image('audio-on', 'audio_on.png'); this.load.image('audio-off', 'audio_off.png'); this.load.image('arrow-right', 'arrowRight.png'); this.load.image('banner', 'banner.png'); // Avatars this.load.image('ann', 'ann.png'); this.load.image('mike', 'mike.png'); // Medals this.load.image('medal-perfect', 'medal_perfect.png'); this.load.image('medal-very-good', 'medal_very_good.png'); this.load.image('medal-good', 'medal_good.png'); this.load.image('medal-hammer', 'medal_hammer.png'); // Progress bar this.load.image('left-cap-shadow', 'barShadowLeft.png'); this.load.image('middle-shadow', 'barShadowMiddle.png'); this.load.image('right-cap-shadow', 'barShadowRight.png'); this.load.image('left-cap', 'barLeft.png'); this.load.image('right-cap', 'barRight.png'); this.load.image('middle', 'barMiddle.png'); this.load.image('left-cap-blue', 'barLeftBlue.png'); this.load.image('right-cap-blue', 'barRightBlue.png'); this.load.image('middle-blue', 'barMiddleBlue.png'); // Vertical bar resources this.load.image('vertical_shadow_top', 'bar_vertical_shadow_top.png'); this.load.image('vertical_shadow_mid', 'bar_vertical_shadow_mid.png'); this.load.image('vertical_shadow_bottom', 'bar_vertical_shadow_bottom.png'); this.load.image('vertical_blue_top', 'bar_vertical_blue_top.png'); this.load.image('vertical_blue_mid', 'bar_vertical_blue_mid.png'); this.load.image('vertical_blue_bottom', 'bar_vertical_blue_bottom.png'); this.load.image('vertical_green_top', 'bar_vertical_green_top.png'); this.load.image('vertical_green_mid', 'bar_vertical_green_mid.png'); this.load.image('vertical_green_bottom', 'bar_vertical_green_bottom.png'); // Load Fonts this.load.bitmapFont('black_font', 'pressstart.png', 'pressstart.xml'); this.load.bitmapFont('white_font', 'pressstart_white.png', 'pressstart_white.xml'); this.load.bitmapFont('red_font', 'pressstart_red.png', 'pressstart_red.xml'); // Load Sounds this.load.audio('click', [ 'switch_001.ogg', 'switch_001.mp3' ]); this.load.audio('error', [ 'error_004.ogg', 'error_004.mp3' ]); this.load.audio('month_change', [ 'drop_004.ogg', 'drop_004.mp3' ]); this.load.audio('coins', [ 'coins.ogg', 'coins.mp3']); } /** * This function is called after all resources have been loaded. It closes this scene * while starting the {@link MainScene}, which takes care of the game itself. */ create() { this.scene.start('main'); } } export default Preloader; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Process.js.html":{"id":"Process.js.html","title":"Source: Process.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Process.js /** * @classdesc * This class implements a process that organizes the production of an item. * It distributes the work over the workshops and handels their status using callbacks. * If ever workshop has finished the work it signals to the {@link Management} that the process is done. * * @class Process * @extends Phaser.Events.EventEmitter * @see [Phaser.Events.EventEmitter]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Events.EventEmitter.html} * @constructor * @param {object} data the data that is passed to start a process. * @param {Management} data.management the management building that starts the process. * @param {module:Item~Item} data.item the item that is to be produced. * */ class Process extends Phaser.Events.EventEmitter { constructor(data) { super(); /** * The associated management building that starts the process. This management instance * listens to the progress of this process class. * @type {Management} */ this.management = data.management; /** * The workshops that will be involved in this production process. During production * these workshops will be instructed to build the item that is produced in this process. * @type {Workshop[]} */ this.workshops = this.management.workshops; /** * The item that is produced in this process. * @type {module:Item~Item} */ this.item = data.item; /** * The number of workshops that are still working. This value gets decremented if a workshop * has finised its work. If all workshops have finished their work, the product is done. * @type {number} */ this.stillWorking = this.workshops.length; } /** * Starts the production of the item. * This method calls every involved workshop in [workshops]{@link Process#workshops} and listens * if they're finished. If a workshop has finished, the function [handelFinished]{@link Process#handelFinished} is called. * @returns {object} return an object with a status that is true if everything is done. */ start() { // get the production times for every item. let times = Object.values(this.item.costs).slice(2); for (let i=0; i &lt; times.length; i++) // go through every production time { if (times[i] == 0) // If an item doesn't need time in this workshop, finish this workshop directly { this.handelFinished(); } else // if it needs more than 0 hours in a workshop, listen to the finish of this workshop and let it work. { this.once(this.workshops[i].name, this.handelFinished, this); this.workshops[i].work({process: this, time: times[i]}); } } return {status: true}; } /** * If a workshop is finished, the [stillWorking]{@link Process#stillWorkung} value is decremented by 1. * If all the workshops are done, emit the event that the process is done to the {@link Management}. */ handelFinished() { this.stillWorking --; if (this.stillWorking == 0) { this.emit('done'); } } } export default Process; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"ProgressBar.js.html":{"id":"ProgressBar.js.html","title":"Source: ProgressBar.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: ProgressBar.js /** * @classdesc * This class implements an horizontal progress bar that can be used to show item usage or time left. * @class ProgressBar * @constructor * @param {object} data the data which is required to represent a progressbar. * @param {Phaser.Scene} data.scene the scene where the progressbar should be rendered. * @param {number} data.x the x coordinate of the progress bar. * @param {number} data.y the y coordinate of the progress bar. * @param {number} data.width the width of the progress bar. */ class ProgressBar extends Phaser.GameObjects.Container{ constructor(data){ let {scene, x,y, workshop, width} = data; let barLeftShadowCap = new Phaser.GameObjects.Sprite(scene, 0,0,'left-cap-shadow').setOrigin(0, 0.5); let barMiddleShadow = new Phaser.GameObjects.Sprite(scene, barLeftShadowCap.x+barLeftShadowCap.width,barLeftShadowCap.y,'middle-shadow').setOrigin(0,0.5); barMiddleShadow.displayWidth = width; let barRightShadow = new Phaser.GameObjects.Sprite(scene,barMiddleShadow.x+barMiddleShadow.displayWidth,barLeftShadowCap.y,'right-cap-shadow').setOrigin(0,0.5); let barLeftCap = new Phaser.GameObjects.Sprite(scene, barLeftShadowCap.x,barLeftShadowCap.y,'left-cap').setOrigin(0, 0.5); let barMiddle = new Phaser.GameObjects.Sprite(scene, barLeftCap.x+barLeftCap.width,barLeftShadowCap.y,'middle').setOrigin(0,0.5); barMiddle.displayWidth = 0; let barRightCap = new Phaser.GameObjects.Sprite(scene,barMiddle.x+barMiddle.displayWidth,barLeftShadowCap.y,'right-cap').setOrigin(0,0.5); let valueText = new Phaser.GameObjects.Text(scene,barMiddle.x+barMiddle.width, barLeftShadowCap.y, '',{fontSize:14,color: '#fff'}).setOrigin(0,0.5); super(scene, x,y, [barLeftShadowCap,barMiddleShadow, barRightShadow,barLeftCap,barMiddle,barRightCap,valueText]); /** * The progressbar consisting of three parts. The different parts are used for the animation. * @type {object} * @property {Phaser.GameObjects.Sprite} leftCap the left part of the bar * @property {Phaser.GameObjects.Sprite} middle the middle part of the bar * @property {Phaser.GameObjects.Sprite} rightCap the right part of the bar */ this.bar = {middle: barMiddle, leftCap: barLeftCap, rightCap: barRightCap}; /** * It is possible to have a text inside the progressbar, which can be useful * to display seconds that are left until the process has been finished for example. * @type {Phaser.GameObjects.BitmapText} */ this.valueText = valueText; /** * The maximum width of the progressbar * @type {number} */ this.maxWidth = width; } /** * Use this function to set a new text value for the progress bar. * It will automatically change the text object [valueText]{@link ProgressBar#valueText} * @example * // set the text inside the progressbar to the string below: * progressbar.value = \"Time left: 6\" */ set value(newT){ this._valueText = newT; this.valueText.text = this._valueText; } /** * Animates the progressbar to a desired percent value. * @param {*} percent the percent value to fill the bar. The value can be between 0 and 1. */ setMeterPercentage(percent = 1){ const width = this.maxWidth * percent; this.scene.tweens.add({ targets : this.bar.middle, displayWidth: width, duration: 500, ease: Phaser.Math.Easing.Circular.Out, onUpdate: () =&gt; { this.bar.rightCap.x = this.bar.middle.x + this.bar.middle.displayWidth; this.bar.leftCap.visible = Math.round(this.bar.middle.displayWidth) &gt; 0; this.bar.middle.visible = Math.round(this.bar.middle.displayWidth) &gt; 0; this.bar.rightCap.visible = Math.round(this.bar.middle.displayWidth) &gt; 0; } }); } } export default ProgressBar; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"ProgressBarVertical.js.html":{"id":"ProgressBarVertical.js.html","title":"Source: ProgressBarVertical.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: ProgressBarVertical.js /** * @classdesc * This class implements a vertical progress bar. * @class ProgressBarVertical * @constructor * @param {object} data the object that contains the information required * to build the progress bar. * @param {Phaser.Scene} data.scene the scene where the container should be rendered. * @param {number} data.x the x coordinate of the Progressbar. * @param {number} data.y the y coordinate of the Progressbar. * @param {number} data.height the height of the Progressbar. */ class ProgressBarVertical extends Phaser.GameObjects.Container { constructor(data) { let {scene, x, y, height} = data; let bottomShadow = new Phaser.GameObjects.Sprite(scene, 0,0,'vertical_shadow_bottom').setOrigin(0.9,1); let midShadow = new Phaser.GameObjects.Sprite(scene, bottomShadow.x,bottomShadow.y-bottomShadow.height,'vertical_shadow_mid').setOrigin(0.9,1); midShadow.displayHeight = height; let topShadow = new Phaser.GameObjects.Sprite(scene, midShadow.x,midShadow.y-midShadow.displayHeight,'vertical_shadow_top').setOrigin(0.9,1); let bottom = new Phaser.GameObjects.Sprite(scene, bottomShadow.x,bottomShadow.y, 'vertical_blue_bottom').setOrigin(0.9,1); let mid = new Phaser.GameObjects.Sprite(scene, midShadow.x,bottom.y-bottom.height, 'vertical_blue_mid').setOrigin(0.9,1); let top = new Phaser.GameObjects.Sprite(scene, topShadow.x,mid.y-mid.displayHeight, 'vertical_blue_top').setOrigin(0.9,1); mid.displayHeight = 0; super(scene,x,y,[topShadow,midShadow,bottomShadow,bottom, mid,top]); this.maxHeight = height; /** * This is an object that contains the top, middle and bottom element * of the progress bar. This is used to animate the progress bar. * @property {Phaser.GameObjects.Sprite} top the top element of the bar. * @property {Phaser.GameObjects.Sprite} mid the middle element of the bar. * @property {Phaser.GameObjects.Sprite} bottom the bottom of the bar. */ this.bar = {top: top,mid: mid,bottom: bottom}; } /** * Animates the progressbar to a desired percent value. * @param {*} percent the percent value to fill the bar. The value can be between 0 and 1. */ setMeterPercentage(percent = 1){ const height = this.maxHeight * percent; this.scene.tweens.add({ targets : this.bar.mid, displayHeight: height, duration: 500, ease: Phaser.Math.Easing.Circular.Out, onUpdate: () =&gt; { this.bar.top.y = this.bar.mid.y - this.bar.mid.displayHeight; this.bar.bottom.visible = Math.round(this.bar.mid.displayHeight) &gt; 0; this.bar.mid.visible = Math.round(this.bar.mid.displayHeight) &gt; 0; this.bar.top.visible = Math.round(this.bar.mid.displayHeight) &gt; 0; } }); } } export default ProgressBarVertical × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Storage.js.html":{"id":"Storage.js.html","title":"Source: Storage.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Storage.js import Building from \"./Building.js\"; import * as Constants from './Constants.js'; /** * @classdesc * This class implements a storage building, that can hold the parts of * the items. * * @class Storage * @extends Building * @constructor * @param {object} data this object is needed to render the workshop building. * It contains the same parameters as the constructor of {@link Building}. */ class Storage extends Building { constructor(data) { super(data); this.addClickListener(this.createDialogue); /** * This object keeps track of the parts that have been produced to indicate * how many parts are available to produce an item. * @type {object} */ this.parts = { [Constants.PART_NAME_CHAIR_LEG]: 0, [Constants.PART_NAME_CHAIR_BACK]: 0, [Constants.PART_NAME_TABLE_LEG]: 0, [Constants.PART_NAME_TABLE_TOP]: 0, [Constants.PART_NAME_BED_FRAME]: 0, [Constants.PART_NAME_BED_TOP]: 0, [Constants.PART_NAME_BOOKCASE_LEG]: 0, [Constants.PART_NAME_BOOKCASE_TOP]: 0 }; } createDialogue() { this.scene.scene.launch('storageDialogue', { mainScene: this.scene, height: 500, width: 500, storage: this }); } /** * This function checks if the available amount of parts inside the storage * is sufficient to build an item and builds it. */ combineAvailable() { this.scene.items.forEach(item =&gt; { if (this.parts[item.parts[0].name] &gt;= item.parts[0].demand &amp;&amp; this.parts[item.parts[1].name] &gt;= item.parts[1].demand) { this.emit('built'+item.branch, item); } } ); } } export default Storage; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"StoragePanel.js.html":{"id":"StoragePanel.js.html","title":"Source: StoragePanel.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: StoragePanel.js /** * This class handels the entries that are visible in the storage. */ import { AUTOMATIC_SELLING } from './Constants.js'; import {getScaling} from './Item.js'; export default class StoragePanel extends Phaser.GameObjects.Container { constructor(data) { let {scene, x,y,items} = data; super(scene, x, y); let offset = 0; this.entries = []; items.forEach(item =&gt; { let entry = new StorageEntry( { scene: scene, x: x, y: y+offset, item: item } ); this.add(entry) offset += 100; this.entries.push(entry); }); } } /** * This class serves as an entry for each item, listing its components. */ class StorageEntry extends Phaser.GameObjects.Container { constructor(data) { let {scene, x,y, item} = data; let frame = new Phaser.GameObjects.Sprite(scene, 0,0, 'panel-long'); frame.setScale(2); frame.displayHeight = 100; let topPart = new Phaser.GameObjects.Sprite(scene, -160,-23, item.parts[0].imageCode).setScale(0.7); let topText = new Phaser.GameObjects.Text(scene, topPart.x+ 20, topPart.y, scene.storage.parts[item.parts[0].name]+'/'+item.parts[0].demand, {fontSize: 18, color: '#000'}).setOrigin(0,0.5); let bottomPart = new Phaser.GameObjects.Sprite(scene, topPart.x, topPart.y+50, item.parts[1].imageCode).setScale(0.7); let bottomText = new Phaser.GameObjects.Text(scene, topPart.x+ 20, bottomPart.y, scene.storage.parts[item.parts[1].name]+'/'+item.parts[1].demand, {fontSize: 18, color: '#000'}).setOrigin(0,0.5); super(scene,x,y,[frame, topPart,bottomPart, topText, bottomText]); this.tree = this.drawTree(scene,new Phaser.Math.Vector2(topText.x+topText.width,topText.y), new Phaser.Math.Vector2(bottomText.x+bottomText.width,bottomText.y), frame.y) this.scene = scene; this.item = item; this.topText = topText; this.bottomText = bottomText; this.add(this.tree); this.demandOne = item.parts[0].demand; this.demandTwo = item.parts[1].demand; this.availableOne = this.scene.storage.parts[item.parts[0].name]; this.availableTwo = this.scene.storage.parts[item.parts[1].name]; this.itemPicture = new Phaser.GameObjects.Sprite(scene,120, frame.y, item.imageCode).setScale(getScaling(item.imageCode)); this.button = new Phaser.GameObjects.Sprite(scene, topText.x+40+this.drawLength, frame.y, 'button-square'); this.button.displayHeight = this.button.displayHeight + 20; this.button.diplayWidth = this.button.diplayWidth - 20; this.wrench = new Phaser.GameObjects.Sprite(scene, this.button.x, this.button.y, 'wrench').setScale(0.4).setTint(0xe2d2ac); this.addButtonListener(); this.add(this.itemPicture); if (!AUTOMATIC_SELLING) { this.add(this.button); this.add(this.wrench); } } /** * This function is used to set the text color of the * available parts display. If all need parts are available * the text turns black, otherwise it remains red, setting * the cond boolean to false to disable the merging into an item. */ updateItemDisplay() { this.availableOne = this.scene.storage.parts[this.item.parts[0].name]; this.availableTwo = this.scene.storage.parts[this.item.parts[1].name]; if (this.availableOne &gt;= this.demandOne) { this.topText.setColor('#000'); this.condOne = true; } else { this.topText.setColor('#cf3434'); this.condOne = false; } if (this.availableTwo &gt;= this.demandTwo) { this.bottomText.setColor('#000'); this.condTwo = true; } else { this.bottomText.setColor('#cf3434'); this.condTwo = false; } } /** * This function signals whether there are enough parts available * to combine them into an item. * * @returns true, if the conditions for both parts are satisfied, * false, if not. */ canMerge() { return this.condOne &amp;&amp; this.condTwo; } set availableOne(value) { this._availableOne = value; this.topText.text = this.scene.storage.parts[this.item.parts[0].name]+'/'+this.item.parts[0].demand; } get availableOne() { return this._availableOne; } set availableTwo(value) { this._availableTwo = value; this.bottomText.text = this.scene.storage.parts[this.item.parts[1].name]+'/'+this.item.parts[1].demand; } get availableTwo() { return this._availableTwo; } /** * Used to draw the line, indicating that two parts can be combined to create an item. * @param {Phaser.Scene} scene, the scene to draw in, should be the scene that implements the drawing. * @param {Phaser.Math.Vector2} topPos the position of the top text to connect with the line. * @param {Phaser.Math.Vector2} bottomPos the position of the bottom text to connect with the line. * @param {Number} frameMidY the middle of the frame to enable drawing in the middle of that frame. */ drawTree(scene, topPos, bottomPos, frameMidY) { let graphics = new Phaser.GameObjects.Graphics(scene); this.drawLength = 100; graphics.lineStyle(3, 0x838796); graphics.beginPath(); graphics.moveTo(topPos.x+15, topPos.y); graphics.lineTo(topPos.x+ this.drawLength, topPos.y); graphics.lineTo(topPos.x+ this.drawLength, frameMidY); graphics.moveTo(topPos.x+15, bottomPos.y); graphics.lineTo(topPos.x+this.drawLength, bottomPos.y); graphics.lineTo(topPos.x+this.drawLength, frameMidY); graphics.lineTo(topPos.x+this.drawLength*2, frameMidY); graphics.strokePath(); return graphics; } /** * This function implements a click listener for the * merging button. If it is clicked, it will be checked * if all required parts for that item are available and * a corresponding event is triggered. */ addButtonListener() { this.button.setInteractive(); this.button.on('pointerdown', function(){ if (this.canMerge()) { this.successAnimation(); this.scene.storage.emit('built'+this.item.branch, this.item); }else { this.failAnimation(); } }, this); } /** * This animation is triggered, if an item can be built successfully. */ successAnimation() { let wrench = this.wrench; let tween = this.scene.tweens.addCounter( { from: 0, to: 360, duration: 500, ease: Phaser.Math.Easing.Expo.Out, onUpdate: function(tween) { wrench.setAngle(tween.getValue()); } } ); } /** * If it is not possible to build an item, this animation * is triggered and nothing more happens. */ failAnimation() { let wrench = this.wrench; this.scene.errorSound.play(); let tween = this.scene.tweens.addCounter( { from: 0, to: 45, duration: 300, ease: Phaser.Math.Easing.Elastic.In, yoyo: true, onUpdate: function(tween) { wrench.setAngle(tween.getValue()); } } ); } } × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"TextDialogue.js.html":{"id":"TextDialogue.js.html","title":"Source: TextDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: TextDialogue.js import {ON_LOCAL_MACHINE, TEXTDIALOGUE_WIDTH, TEXTDIALOGUE_HEIGHT, MINIMUM_TEXT_SIZE} from './Constants.js'; import DialogueScene from './DialogueScene.js'; import FormUtil from './formUtil.js'; import Button from './Button.js'; import {writeAnswer} from './SosciWriter.js'; import InteractionScene from './InteractionScene.js'; /** * @classdesc * This class provides dialogue scene to get a user text input. * In order to create this dialogue the values required by the DialogueScene must be provided on creation. * Therefore, see {@link DialogueScene#init}. * @calss TextDialouge * In order to run this scene, it can be launched with phaser's scene plugin. * Additionaly, a title and a question text should be provided. * @example * // go to the place, where the scene should be started and insert the following line * this.scene.launch('textDialogue', {mainScene: this, title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION questionNumber: NUMBER}); * // \"this\" must be a scene, because this.scene points at the scene manager of the specific scene. * */ class TextDialogue extends InteractionScene { constructor() { super('textDialogue'); } create() { /** * This is the title of the dialogue. * @type {String} */ this.title = this.data.title; /** * The question number specifies in what sosci survey item the value is stored. * This is important, if there are multiple text dialogues to keep track of the different questions. * @type {number} */ this.questionNumber = this.data.questionNumber; let avatar = this.data.avatar; /** * The question that is displayed to the user above the input field, where the player can * type in the answer. * @type {String} */ this.question = this.data.question; this.height = TEXTDIALOGUE_HEIGHT; this.width = 1.25 * TEXTDIALOGUE_WIDTH; this.createDialogue(this.title); this.renderQuestion(); this.panel.disableCloseButton(); let sendButton = new Button(this,90,150,'button-long', 'button-long-pressed','Absenden',this.sendText,this); sendButton.setButtonScale(0.75); this.sendButton = sendButton let avatarSprite = new Phaser.GameObjects.Sprite(this,200,-120, avatar).setScale(1); this.panel.add([sendButton,avatarSprite]); /** * The form util takes care of the setup of the text area. * @type {FormUtil} */ this.formUtil = new FormUtil({ scene: this }); // Set up the textarea to be displayed at the right place this.formUtil.scaleToGameW('textarea', .5); this.formUtil.scaleToGameH('textarea',.3); this.formUtil.placeElementAt(400,450, 'textarea', true, true); this.formUtil.disableResize('textarea'); this.fadeIn(this.showTextArea); // create the dialogue, by animating the panel given in the super class. } showTextArea() { this.formUtil.showTextArea('textarea'); } /** * Displays the quesiton on the dialogue. */ renderQuestion() { this.questionElem = new Phaser.GameObjects.Text(this.mainScene, -50,-this.height/2+100, this.question, {fontSize: 17,color: \"#000\"}).setOrigin(0.5,0.3); this.panel.add(this.questionElem); } /** * This function sends the text that has been typed in by the player * via the Sosci Writer. * If [ON_LOCAL_MACHINE]{@link module:Constants#ON_LOCAL_MACHINE} is set to true, * the value is just being printed. */ sendText() { let textarea = document.getElementById('textarea'); if (textarea.value.length &lt; MINIMUM_TEXT_SIZE) { this.sendButton.showMessage(\"Bitte schreibe etwas mehr.\", alert=true, 10,1000); return; } if (ON_LOCAL_MACHINE) console.log(textarea.value); else writeAnswer(this.questionNumber, textarea.value); textarea.value = ''; this.formUtil.hideTextArea('textarea'); this.close(); } /** * Adjust the size of the question text. * @param {number} size the desired fontsize for the question */ setQuestionFontSize(size) { this.questionElem.setFontSize(size); } } export default TextDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Tutorial.js.html":{"id":"Tutorial.js.html","title":"Source: Tutorial.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Tutorial.js import InformerBanner from \"./InformerBanner.js\"; import Building from './Building.js'; import ManagementDialogue from './ManagementDialogue.js'; import DialogueScene from \"./DialogueScene.js\"; import WorkshopDialogue from \"./WorkshopDialogue.js\"; import Ui from './Ui.js'; import {WOOD, METAL, ENABLE_MARKET} from './Constants.js'; import EventDispatcher from './EventDispatcher.js'; import MainScene from \"./MainScene.js\"; /** * @classdesc * This class handels the infrastructure of the tutorial at the beginning of the game. * @constructor * @param {MainScene} mainScene the mainscene of the game, used to manipulate the game flow during the tutorial. */ class Tutorial extends Phaser.Events.EventEmitter { constructor(mainScene) { super(); this.mainScene = mainScene; /** * Used for resetting the resources afte the tutorial has ended. * @type {array} */ this.initMetal = [...METAL]; /** * Used for resetting the resources afte the tutorial has ended. * @type {array} */ this.initWood = [...WOOD]; /** * A flag that indicates that the tutorial is still active. * This should be set to false if the month is skipped from the tutorial * @type {boolean} */ this.active = true; /** * The eventDispatcher instance. It is used to catch when a dialogue is ready. * We need this information to control buttons or other elements but this is only possible when they're loaded properly. * @type {EventDispatcher} */ this.emitter = EventDispatcher.getInstance(); this.sceneManager = mainScene.scene.manager; /** * Provide the tutorial timeline. Choose text and the condition that needs to be met in order * to continue to the next step of the tutorial. * @type {object[]} */ this.MESSAGES = [ { text: \"Willkommen bei der Furniture Company! Schön, dass du dich bereit erklärt hast, den Produktionssektor zu übernehmen. Ich bin Anna, die Abteilungsleiterin, und ich werde dir alles zeigen was du wissen musst. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \"Deine Aufgabe in der Furniture Company wird es sein, einen möglichst hohen Gewinn zu erzielen, indem du Möbel produzierst. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \"Du kannst dich auf der Karte umsehen, indem du den Mauszeiger auf einer freien Fläche bewegst, während du die linke Maustaste gedrückt hältst. Probiere es aus und klicke hier, um fortzufahren.\", action: this.waitForClick.bind(this) }, { text: \"Um zu erfahren, welche Möbel du produzieren kannst, sieh dir Managementgebäude 1 am oberen Rand an, indem du darauf klickst.\", action: this.waitForClick.bind(this, this.mainScene.management_one) }, { text: \"Super! In den Managementgebäuden erhältst du Informationen über Möbel, die du bauen kannst. Zum Beispiel benötigt ein Tisch 2 Holz und 5 Metall und die Herstellung dauert 4 Stunden in Werkstatt A und 6 in Werkstatt B. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \"Um ein Möbelstück zu bauen, ist es deine Aufgabe, die richtigen Einzelteile herzustellen. Du kannst herausfinden welche Einzelteile ein Möbelstück braucht, indem du auf den grünen Knopf klickst. Probiere es beim Tisch aus!\", action: this.waitForClick.bind(this, this.mainScene.scene.manager.keys.managementDialogue) }, { text: \"Sehr gut! Wir brauchen also 4 Tischbeine für jeweils 1 Metall und eine Tischplatte für 1 Metall und 2 Holz. Dafür erhalten wir dann 4 Gold. (Weiter).\", action: this.waitForClick.bind(this) }, { text: \"Die Gebäudesymbole zeigen dir außerdem, wo du diese Teile produzieren kannst. Schließe nun das Management Fenster, indem du auf das \\\"X\\\" oben rechts klickst.\", action: this.waitForClose.bind(this, this.mainScene.scene.manager.keys.managementDialogue) }, { text: \"Nun produzieren wir die Teile, die wir für den Tisch brauchen. Wir beginnen mit den Tischbeinen. Dafür ist die Werkstatt A zuständig. Öffne sie!\", action: this.waitForClick.bind(this, this.mainScene.workshopA) }, { text: \"In dieser Werkstatt kannst du Stuhl-und Tischbeine produzieren und den Fortschritt sowie die Warteschlange verfolgen. Produziere nun 4 Tischbeine, indem du vier mal auf den entsprechenden Knopf klickst.\", action: this.waitForProduction.bind(this, this.mainScene.scene.manager.keys.workshopDialogue, 1,1) }, { text: \"Du musst dabei nicht warten, bis ein Teil fertig produziert wurde. Deine Aufträge werden nacheinander abgearbeitet.\", action: this.waitForProduction.bind(this, this.mainScene.scene.manager.keys.workshopDialogue, 1,3) }, { text: \"Super! Die Tischbeine werden nun produziert. Schließe nun die Werkstatt.\", action: this.waitForClose.bind(this, this.mainScene.scene.manager.keys.workshopDialogue) }, { text: \"Auf dem Gelände gibt es auch ein Lager, wo du nützliche Informationen bekommst. Sieh es dir einmal an.\", action: this.waitForClick.bind(this, this.mainScene.storage) }, { text: \"Im Lager siehst du welche Teile du brauchst und welche du bereits hast, um ein Möbelstück herzustellen. Das kann sehr hilfreich sein! Du siehst hier die vier Tischbeine die du bisher produziert hast (Weiter).\", action: this.waitForClick.bind(this) }, { text: \"Jetzt fehlt also nur noch die Tischplatte. Schließe das Lager.\", action: this.waitForClose.bind(this, this.mainScene.scene.manager.keys.storageDialogue) }, { text: \"Öffne nun die Werkstatt B ...\", action: this.waitForClick.bind(this, this.mainScene.workshopB) }, { text: \"... und produziere eine Tischplatte.\", action: this.waitForProduction.bind(this, this.mainScene.scene.manager.keys.workshopDialogue, 1, 1) }, { text: \"Du siehst, alle Werkstätten haben eine ähnlichen Aufbau, manche Teile brauchen aber länger in der Produktion als andere. Beachte das bei deiner Planung. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \"Schließe nun die Werkstatt wieder. Laufende Produktionen oder Warteschlangen werden dadurch nicht unterbrochen.\", action: this.waitForClose.bind(this, this.mainScene.scene.manager.keys.workshopDialogue) }, { text: \"Sobald du alle Teile für ein Möbelstück produziert hast, brauchst du nichts weiter zu tun. Unser Montageteam fügt die Einzelteile zusammen und kümmert sich um die Auslieferung. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \"Den Gewinn von den produzierten Möbeln kannst du oben links sehen. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \"Du kennst nun die Grundprinzipien deiner Aufgabe. Beachte bitte, dass du wenn es richtig losgeht, nur begrenzte Zeit hast, dein Material aufzubrauchen. Oben rechts wird sich der grüne Balken nach und nach füllen. (Weiter)\", action:this.waitForClick.bind(this) }, { text: \"Ist der Balken voll, endet der Monat und arbeitende Werkstätten werden unterbrochen. Jeden Monat wird neues Holz und Metall geliefert, allerdings in unterschiedlichen Mengen. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \" Nicht verbaute Einzelteile und übriges Material spenden wir. Versuche also in jedem Monat möglichst alles aufzubrauchen. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \"Solltest du jedoch früher mit der Produktion fertig sein, kannst du jederzeit zum neuen Monat springen, indem du auf den weißen Pfeil in der rechten oberen Ecke klickst. (Weiter)\", action: this.waitForClick.bind(this) }, { text: \"Überspringe nun den Monat, um mit der richtigen Aufgabe zu beginnen. Du bist nun bestens vorbereitet. Ich wünsche dir viel Erfolg!\", action: this.enableInteraction.bind(this) } ]; } /** * Initiates the tutorial. It also changes the settings of the * game to separate the actual experiment from the tutorial story */ startTutorial() { let uiScene = this.mainScene.scene.manager.keys.ui; this.deactivateGameflow(); /** * The banner, that is used to place the tutorial text. * @type {InformerBanner} */ this.banner = new InformerBanner(uiScene, 400,540,\"\"); uiScene.add.existing(this.banner); this.banner.setInteractive(); //initiate the dialogue this.step(); } /** * Steps to the next position of the messages field, reloading the text and invoking a new listener. */ step() { let msg = this.MESSAGES.shift(); this.banner.text = msg.text; // set the new text in the tutorial msg.action(); // Perform the action (function) that is stored in the action field. // Force the tutorial scene to be above all the other elements. this.sceneManager.bringToTop(\"ui\"); } /** * Turns off the controls of the ui scene and deactivates the timer. */ deactivateGameflow() { this.mainScene.timer.remove(); this.emitter.on('uiReady', ui =&gt; { ui.skipButton.texture.disableInteractive(); }); } /** * Waits until the player has clicked a production button several times. This corresponds to a desired quantity that needs to be produced. * a WorkshopDialogue emits 'workshopReady' when opened. We use this event to make sure the elements inside this dialogue are loaded. * @param {WorkshopDialogue} element the dialogue scene to locate the production button in * @param {number} position 0 for the left button 1 for the right button of the workshop. * @param {number} quantity define how often the button must be clicked in order to continue. * @see {@link WorkshopDialogue} */ waitForProduction(element, position, quantity) { // If the dialogue is not active yet, wait for it to complete if (!element.buttonLeft || !element.buttonLeft.active) { this.emitter.once('workshopReady', (workshop) =&gt; { this.countProduction(element,position,quantity); }); } else this.countProduction(element,position,quantity); } /** * Invoked if the buttons are successfully loaded and takes care of the productionbutton clicks * to count the right amount of parts built. * @param {*} element this is usually from the class [WorkshopDialogue]{@link WorkshopDialogue}, where the buttons are located. We will * listen to them and count the clicks. * @param {number} position In the workshop dialogue there is a left and a right produciton button. Provide a 0 to listen to the left button and 1 for the right button. * @param {number} quantity the quatntity of the item to be built. After the item is built in the provided quantity we will step to the next dialogue point. */ countProduction(element, position, quantity) { let button; if (position === 0) { button = element.buttonLeft.texture; } else { button = element.buttonRight.texture; } button.setInteractive(); let clickCounter = 0; button.on('pointerup', () =&gt; { clickCounter++; if (clickCounter===quantity) { button.off(\"pointerup\"); this.step(); } }); } /** * Waits for a dialogue to be closed. * @param {DialogueScene} element the element containing the close button */ waitForClose(element) { let button = element.panel.buttonRound; button.setInteractive(); button.once('pointerdown', this.step,this); } /** * Implements the functionality to change the text if the element is clicked. * This allows to make multiple messages where the subject can click through. * If it is clicked once, the next text message is loaded, invoking a different listener. * @param {*} element the element that should be clicked to continue. */ waitForClick(element) { // Default case: if the banner is clicked: continue to next message if (!element) { this.banner.once('pointerup', () =&gt; { this.step(); }); } // Wait for a building to be clicked, and cause the building to blink. else if (element instanceof Building) { element.addFlashEffect(); element.setInteractive(); element.once('pointerup', () =&gt; { element.stopFlashEffect(); this.step(); element.disableInteractive(); }); } // If a Player has looked up the required parts of an item. else if (element instanceof ManagementDialogue) { let button = element.itemPanel.list[1].button.texture; button.once('pointerup', () =&gt; { this.step(); }); } } /** * Ends the tutorial, reactivating the timer and resetting the values. */ endTutorial() { Object.keys(this.mainScene.storage.parts).forEach(key =&gt; { this.mainScene.storage.parts[key] = 0; }); // Resetting player values from tutorial let player = this.mainScene.player; player.monthlyProfit = []; this.mainScene.tutorialPhase = false; this.mainScene.monthIterator = this.mainScene.createMonthIterator(undefined,12); player.availableWood = this.initWood; player.availableMetal = this.initMetal; // Reset all the produced Items, the player made during the tutorial. Object.keys(player.producedItems).forEach(key =&gt; { player.producedItems[key][0] = 0; }); player.money = 0; } /** * Enables all functionlaity of the game and get rid of the tutorial dialogue. * This allows the player to look around and try the new learned features and controls of the game. * Furthermore, the button for skipping the month officially ends the tutorial. */ enableInteraction() { // Leaving the tutorial phase allows to make sure that the buildings will no longer be disabled after closing. this.mainScene.tutorialPhase = false; this.mainScene.management_one.setInteractive(); this.mainScene.management_two.setInteractive(); if (ENABLE_MARKET) this.mainScene.market.setInteractive(); this.mainScene.storage.setInteractive(); this.mainScene.workshops.map(workshop =&gt; workshop.setInteractive()); this.banner.destroy(); let ui = this.mainScene.scene.manager.keys.ui; let button = ui.skipButton.texture; button.setInteractive(); } } export default Tutorial; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Ui.js.html":{"id":"Ui.js.html","title":"Source: Ui.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Ui.js import ProgressBar from \"./ProgressBar.js\"; import Button from './Button.js'; import EventDispatcher from \"./EventDispatcher.js\"; import {WARNINGS_AT_SKIP} from \"./Constants.js\"; /** * This class implements a UI scene as a top bar, that shows available material, the actual month and * the time until the next month. * @class Ui * @extends Phaser.Scene */ class Ui extends Phaser.Scene { constructor() { super('ui'); } /** * The function is called if the scene is launched. The data is passed with the function that starts this scene. * @see [Launching a Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scenes.ScenePlugin.html#launch__anchor} * @param {object} data the data that is passed to the scene. * @param {Player} data.player the player instance that is used to display the available material and money. * @param {MainScene} data.mainScene the mainScene. This instance is used to display the time that is left. */ init(data) { /** * The player instance. * @type {Player} */ this.player = data.player; /** * The main scene to get infromation from. * @type {MainScene} */ this.mainScene = data.mainScene; /** * An event dispatcher which is used to record when the player skips a month. */ this.emitter = EventDispatcher.getInstance(); } /** * This function renders the information inside the scene. */ create() { this.add.image(400,0,'ui-panel').setOrigin(0.5,0.2); // Profit this.uiProfit = this.add.text(20,0, this.player.money, {fontSize:20,color: '#000'}).setOrigin(0,-0.2); this.gold = this.add.image(this.uiProfit.x + this.uiProfit.width, this.uiProfit.y, 'gold').setOrigin(0,0.1).setScale(2); // Available Wood this.uiWood = this.add.text(150, 0,'',{fontSize:20,color: '#000'}).setOrigin(0,-0.2); this.wood = this.add.image(this.uiWood.x+this.uiWood.width, this.uiWood.y, 'wood').setOrigin(-0.3,0).setScale(0.05); // Avaiable Metal this.uiMetal = this.add.text(270, 0, '', {fontSize:20,color: '#000'}).setOrigin(0,-0.2); this.metal = this.add.image(this.uiMetal.x+this.uiMetal.width, this.uiMetal.y, 'metal').setScale(0.05).setOrigin(-0.1,0); this.monthText = this.add.text(500, 0, '', {fontSize:20,color: '#000'}).setOrigin(0,-0.2); this.monthProgress = new ProgressBar( { scene: this.mainScene, x: this.monthText.x+120, y: 12, width: 100 }); this.monthTextNext = this.add.text(this.monthProgress.x+120, 0, '', {fontSize:20,color: '#000'}).setOrigin(0,-0.2); this.monthProgress.setScale(1,0.5); this.setupSkipButton(); this.audioButton = new Phaser.GameObjects.Sprite(this,770,50,'audio-on').setScale(0.3); this.audioButton.setInteractive(); this.audioOn = true; this.audioButton.on('pointerdown', (pointer) =&gt; { this.audioButton.once('pointerup', () =&gt; { this.audioOn = !this.audioOn; if (this.audioOn) { this.audioButton.setTexture('audio-on'); this.scene.manager.game.sound.mute = false; } else { this.audioButton.setTexture('audio-off'); this.scene.manager.game.sound.mute = true; } this.emitter.emit('toggledAudio',this.audioOn); },this); }); this.add.existing(this.audioButton); this.add.existing(this.monthProgress); this.emitter.emit('uiReady', this); this.emitter.on(\"clickedYes\", this.proceed.bind(this)); } update() { this.uiProfit.text = this.player.money; this.gold.x = this.uiProfit.x+this.uiProfit.width; this.uiWood.text = this.player.availableWood[this.mainScene.month.value]; this.wood.x = this.uiWood.x+this.uiWood.width; this.uiMetal.text = this.player.availableMetal[this.mainScene.month.value]; this.metal.x = this.uiMetal.x+this.uiMetal.width; this.monthProgress.setMeterPercentage(this.mainScene.timer.elapsed/this.mainScene.timer.delay); if (this.mainScene.month.done) { this.monthText.text = 'Fertig!'; }else { this.monthText.text = 'Monat: '+ Number(this.mainScene.month.value+1); } if (this.mainScene.month.value &lt; 11) { this.monthTextNext.text = Number(this.mainScene.month.value+2); }else { this.monthTextNext.text = ''; } } /** * This function initiates the button that is used to skip the month. */ setupSkipButton() { this.skipButton = new Button(this, this.monthText.x, this.monthText.y, 'button-square-unpressed', 'button-square', 'right',this.skipMonth, this, 'Zum nächsten\\nMonat'); this.skipButton.texture.displayWidth += 5; this.skipButton.texture.setScale(0.45); this.skipButton.image.setScale(0.25); this.skipButton.x += 280; this.skipButton.y += 10; this.add.existing(this.skipButton); } /** * This function is invoked, when the skip button is pressed. */ skipMonth() { let month = this.mainScene.month.value; let text; if (WARNINGS_AT_SKIP) { if (this.mainScene.getProductionStatus() == 1) { text = \"Im Moment sind noch Werkstätten aktiv. Wenn du jetzt zum nächsten Monat springst, werden die laufenden Produktionen abgebrochen. Bist du dir sicher?\"; this.mainScene.scene.launch('warningDialogue', {mainScene: this.mainScene, title: 'Achtung!', text: text}); return false; } else if (this.player.monthlyProfit[month] == 0) { text = \"Du hast in diesem Monat noch nichts gebaut. Bist du dir sicher, dass du zum nächsten Monat springen willst?\"; this.mainScene.scene.launch('warningDialogue', {mainScene: this.mainScene, title: 'Achtung!', text: text}); return false } } this.proceed(); } /** * If the player has agreed on the skip month dialogue or everything is set to skip the month, * it will executed, ending the tutorial - if any - and proceeding to the next month. */ proceed() { this.emitter.emit('monthSkipped'); if (this.mainScene.tutorial &amp;&amp; this.mainScene.tutorial.active) { this.mainScene.tutorial.endTutorial(); this.mainScene.tutorial.active = false; } this.mainScene.timer.remove(); this.mainScene.nextMonth(); } } export default Ui; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"WarningDialogue.js.html":{"id":"WarningDialogue.js.html","title":"Source: WarningDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: WarningDialogue.js import InteractionScene from './InteractionScene.js'; import Button from './Button.js'; import {TEXTDIALOGUE_WIDTH, TEXTDIALOGUE_HEIGHT} from './Constants.js' /** * @classdesc * This class asks the player if he or she is sure to proceed. * It can be used if the player skips a month without having produced anything * of if it is tryed to skip the month while workshops are still producing. * In order to make this dialogue work, the data dictionary must contain the field * \"text\", filled with the text, the player recieves. Also the fields mentioned in {@link DialogueScene} * must be filled in. * * @class WarningDialogue * @extends InteractionScene * @example * // Starts a warningDialogue asking the player if he or she is sure to proceed. * this.scene.launch('warningDialogue', {mainScene: this, title: \"Warning\", text: \"Are you sure you want to proceed?\"}); */ class WarningDialogue extends InteractionScene { constructor() { super(\"warningDialogue\"); } create() { /** * The title of the dialogue * @type {String} */ this.title = this.data.title; /** * The text message that should be displayed to the player. * It should be a question that can be answered with \"yes\" or \"no\", * since the player gets two buttons to answer. * @type {String} */ this.text = this.data.text; // adjusting the height of the dialogue this.height = 0.7 *TEXTDIALOGUE_HEIGHT; this.width = TEXTDIALOGUE_WIDTH // Add the panel to fill it with contents this.createDialogue(this.title); let textElement = new Phaser.GameObjects.Text(this, -200,-60, this.text, {color: \"#000\", wordWrap: {width: 420, useAdvancedWrap: true}}); let buttonNo = new Button(this, -100, 50, \"button-long\", \"button-long-pressed\", \"Nein\", this.handelResponse.bind(this,false),this); let buttonYes = new Button(this, 100, buttonNo.y, \"button-long\", \"button-long-pressed\", \"Ja\", this.handelResponse.bind(this,true),this); buttonYes.setButtonScale(0.8); buttonNo.setButtonScale(0.8); this.panel.add([textElement, buttonYes,buttonNo]); this.panel.disableCloseButton(); this.fadeIn(); } /** * Act according to the decision of the player. * Used as a callback function from the buttons. * @param {boolean} response the response of the player, if set to false, the * dialoge closes without any further actions. * If set to true, the dialogue closes and emits a callback called \"clickedYes\". */ handelResponse(response) { if (response) { this.emitter.emit(\"clickedYes\"); } else this.close(); } } export default WarningDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Workshop.js.html":{"id":"Workshop.js.html","title":"Source: Workshop.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: Workshop.js import Building from \"./Building.js\"; import ProgressBar from \"./ProgressBar.js\"; import ProgressBarVertical from \"./ProgressBarVertical.js\"; import {PRODUCTION_TIME_SCALING} from './Constants.js'; /** * @classdesc * This class implements a workshop that can produce items. * @class Workshop * @extends Building * @constructor * @param {object} data the data object that is used to create a workshop. * @param {Phaser.Scene} data.scene the scene where the building should be built in. See [Phaser.Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html} * @param {Number} data.x the x coordinate where the building should be placed. * @param {Number} data.y the y coordinate for the building. * @param {String} data.image the image key of the building. * @param {String} data.name the name of the building. * @param {number} data.availableHours the time that is available per month on this workshop. * @param {module:Item~Item[]} data.items the items this workshop can produce. * @param {Management} data.management the management building associated to this workshop. This is used to * plan a production of an item. */ class Workshop extends Building { constructor(data){ let {time, availableHours, items, management, sign} = data; // set up a basic building super(data); this.time = time; /** * The items this workshop can produce. * @type {module:Item~Item[]} */ this.items = items; /** * The management that organizes this workshop. * @type {Management} */ this.management = management; this._busy = false; /** * The queue that indicates which item should be produced if the actual item is done producing. * @type {Array} */ this.queue = []; this.initialHeight = this.displayHeight; this.initialY = this.y; this.addBars(); /** * The initial amount of hours available in this workshop. * This value is used to reset the available hours on month change. * @type {number} */ this.initialHours = availableHours; /** * The hours available in this workshop. * For every item built this value is decreased. * @type {number} */ this.availableHours = this.initialHours; this.addClickListener(this.createDialogue); this.sign.setTexture(sign).setScale(0.3); this.sign.y -=40; this.sign.x += 30; this.sign.alpha = 1; this.add(this.sign); } /** * Sets the availalbe hours of this workshop while manipulating the ProgressBar that indicates the * time available in the workshop. * @param {number} hours the value that should be set. */ set availableHours(hours) { this._availableHours = hours; this.timeBar.setMeterPercentage(this.availableHours/this.initialHours); } /** * Returns the time available inside the workshop */ get availableHours() { return this._availableHours; } /** * Defines if the workhsop is producing right now. If this is set to true, all following work * commands will be added to the [queue]{@link Workshop#queue} and the produce animation of this workshop is activated. * @param {boolean} status define if the workshop is busy or not. */ set busy(status) { this._busy = status; this.setProduceAnimation(this._busy); } /** * Returns the status of the workshop. */ get busy() { return this._busy; } /** * Creates the [WorkshopDialogue]{@link WorkshopDialogue}. */ createDialogue() { this.scene.scene.launch('workshopDialogue', { mainScene: this.scene, height: 300, width: 500, workshop: this, }); } /** * Initiates the animation of the building to signal that it is busy. * @param {boolean} on defining if the animation should be started or stopped. */ setProduceAnimation(on) { if (on) { if(this.tween &amp;&amp; this.tween.isPlaying()) /* if the tween is active, ensure that this remains this is useful to keep control of the animation, if this is not done, the workshop will increase in height, every time something new is produced which will look very weird. This is necessary because if something is stored inside the queue, the busy value of the workshop gets switch off and on very fast, which stop the animation and start a new one. But in this case it will just continue animating the height without stopping. */ { this.tween.loopCounter = 100; this.tween.loop = -1; } else { // start an animation by animating the height forth and back. this.tween = this.scene.tweens.add({ targets: [this.buildingSprite], displayHeight: this.buildingSprite.displayHeight+15, // increase height of the building y: this.buildingSprite.y - 5, // move the building a bit, to make the animation look more natural. ease: Phaser.Math.Easing.Linar, // linear movement. duration: 400, // 400 milliseconds hold: 0, // do not wait, roll back the animation yoyo: true, // if the animation is done run it reversed. This creates the up and down effect. loop: -1, // loop forever. onUpdate: () =&gt; { this.progressBar.setMeterPercentage(this.timer.elapsed/this.timer.delay); }, onComplete: () =&gt; { this.progressBar.setMeterPercentage(0); } }); } } else { if(this.tween) // stop the animation if there is any. { this.tween.loop = 0; this.tween.loopCounter = 0; } } } /** * Initiate the working animation and the timer in order to finish a * process. If the time is over, the [done]{@link Workshop#done} function of this workshop is called, * signaling the [process]{@link Process} that this workshop is done. * If the workshop is already producing, the process will be queued. * * @param {Object} data an object holding the process and the amount of * time that will be needed to finish the process. * @param {Process} data.process the process that provides the data needed to produce the item. * @param {number} data.time the time that is needed inside this workshop. */ work(data) { let process = data.process; let time = data.time; if (this.busy) { this.queue.push({process: process, time: time}); } else { if (time &gt; 0) this.busy = true; this.timer = this.scene.time.addEvent({delay: time*PRODUCTION_TIME_SCALING*1000, callback: this.done, callbackScope: {workshop: this, process: process}}); this.item = process.item; } } /** * Stops the current production and detatching its process * and clearing the queue. * */ interrupt() { if (this.timer &amp;&amp; this.timer.callbackScope) { let process = this.timer.callbackScope.process; process.removeAllListeners(); this.timer.remove(); this.busy = false; this.queue = []; } } /** * This function is triggered after the working timer has expired. * It emits a 'finished' event to the process, that can handel the result. * After that, the queue is checked to produce the next item. */ done() { this.process.emit(this.workshop.name, this.process); this.workshop.busy = false; if (this.workshop.queue.length &gt; 0) { this.workshop.work(this.workshop.queue.shift()); } } /** * Add the bars for available time and producing time, * that are visible on the map. */ addBars() { this.timeBar = new ProgressBarVertical( { scene: this.scene, x: this.buildingSprite.x+this.buildingSprite.width, y: this.buildingSprite.y+ this.buildingSprite.displayHeight/2, height: 50 }); this.progressBar = new ProgressBar( { scene: this.scene, x: this.buildingSprite.x- this.buildingSprite.width/2, y: this.buildingSprite.y + this.buildingSprite.height/1.3, width: 50 }); this.progressBar.setMeterPercentage(0); this.progressBar.setScale(1,0.5); this.add(this.progressBar); this.add(this.timeBar); } /** * Reset the available working hours back to the initial values * to refill the capacity. Usually done at the change of month. */ resetHours() { this.availableHours = this.initialHours; } } export default Workshop; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"WorkshopDialogue.js.html":{"id":"WorkshopDialogue.js.html","title":"Source: WorkshopDialogue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: WorkshopDialogue.js import DialogueScene from './DialogueScene.js'; import ProgressBar from './ProgressBar.js'; import WorkshopQueue from './WorkshopQueue.js'; import {getScaling, scalePartsCosts} from './Item.js'; import { PRODUCTION_TIME_SCALING, PRODUCE_ONE_CLICK, SOUND_VOLUME, PRODUCE_IN_MANAGEMENT, PRODUCE_PARTS} from './Constants.js'; import Button from './Button.js'; import EventDispatcher from './EventDispatcher.js' /** * @classdesc * This class is the Dialogue that appears if a Workshop has been clicked. * The main Responsibility lies in providing information about the production status as well as * the production queue. * It also provides production functionality if the option [PRODUCE_IN_MANAGEMENT]{@link GameProperties#PRODUCE_IN_MANAGEMENT} is set to `false`. * * @class WorkshopDialogue * @extends DialogueScene * @constructor * */ class WorkshopDialogue extends DialogueScene { constructor() { super('workshopDialogue'); } /** * This function is always run after a scene is started. * It creates the resources that are needed to display and handel the dialogue. */ create() { this.emitter = EventDispatcher.getInstance(); this.sound.setVolume(SOUND_VOLUME); /** * Adds the clicksound, which was loaded by the {@link Preloader} to the scene. * The sound is added using phasers [BaseSoundManager]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Sound.BaseSoundManager.html#add} * @type {Phaser.Sound.BaseSound} */ this.clickSound = this.sound.add('click'); /** * Adds the errorsound, which was loaded by the {@link Preloader} to the scene. * The sound is added using phasers [BaseSoundManager]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Sound.BaseSoundManager.html#add} * @type {Phaser.Sound.BaseSound} */ this.errorSound = this.sound.add('error'); /** * A workshop instance, which is the workshop that has been clicked. * This makes sure, that all actions taken in this scene affect the right workshop. * * @type {Workshop} */ this.workshop = this.data.workshop; this.createDialogue(this.workshop.name); // The yOffset specifies the starting y- position of the progress display. // it is manipulated if addProduceButtons() is called, to provide space // for the produce buttons. let yOffset = -80; if (!PRODUCE_IN_MANAGEMENT &amp;&amp; PRODUCE_PARTS) // if parts should not be selected inside the management buildings { yOffset += this.addProduceButtons(); } /** * The text indicating that something is being produced. See [BitmapText]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.BitmapText.html} for more information. */ this.producingText = new Phaser.GameObjects.Text(this,-200, yOffset, '', {fontSize:18,color: '#000'}).setOrigin(0,0.3); /** * Text that describes the [ProgressBar]{@link WorkshopDialogue#workProgress}. */ this.progressText = new Phaser.GameObjects.Text(this,this.producingText.x, this.producingText.y+45,'Fortschritt:', {fontSize:18,color: '#000'}).setOrigin(0,0.3); /** * Text that describers the [AvailableTimeBar]{@link WorkshopDialogue#availableBar}. */ this.availableTimeText = new Phaser.GameObjects.Text(this,this.producingText.x, this.progressText.y+45, 'Verfügbare Zeit:',{fontSize:18,color: '#000'}).setOrigin(0,0.3); /** * Text that describes the [Queue]{@link WorkshopDialogue#workshopQueue}. */ this.nextText = new Phaser.GameObjects.Text(this,this.producingText.x, this.availableTimeText.y+30,'Als nächstes:', {fontSize:18,color: '#000'}).setOrigin(0,0.3); /** * The image that indicates the item that is currently produced. * See [The Phaser Documentation]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html} for informations about sprites. * @type {Phaser.GameObjects.Sprite} */ this.itemImage = new Phaser.GameObjects.Sprite(this,-20,this.progressText.y-40,'chair'); this.panel.add(this.itemImage); /** * The Progressbar that informs about the time that is left to finish production of the item that is * currently produced. * * @type {ProgressBar} */ this.workProgress = new ProgressBar( { scene: this, x: -40, y: this.progressText.y+5, width:200 }); /** * The Progressbar that shows how much time is available in the actual month. * * @type {ProgressBar} */ this.availableBar = new ProgressBar( { scene: this, x: this.workProgress.x+50, y: this.availableTimeText.y+5, width: 150 }); // We want this progressbar to be blue, so we set the blue texture this.availableBar.bar.middle.setTexture('middle-blue'); this.availableBar.bar.leftCap.setTexture('left-cap-blue'); this.availableBar.bar.rightCap.setTexture('right-cap-blue'); /** * The queue that displays the items that will be produced after the actual item is finished. * @type {WorkshopQueue} */ this.workshopQueue = new WorkshopQueue( { scene: this, x: 0, y: this.nextText.y+40 } ) // Adding the elements to the UI frame 'panel' this.panel.add(this.availableTimeText); this.panel.add(this.availableBar); this.panel.add(this.progressText); this.panel.add(this.workProgress); this.panel.add(this.producingText); this.panel.add(this.workshopQueue); this.panel.add(this.nextText); this.fadeIn(); if (this.mainScene.tutorialPhase) { this.panel.buttonRound.disableInteractive(); this.buttonLeft.texture.disableInteractive(); this.buttonRight.texture.disableInteractive(); this.emitter.emit('workshopReady', this); } } /** * This function is called after every frame, updating the queue status of the workshop and the progressbars */ update() { this.workshopQueue.update(); // Describing bar indicating the available hours. this.availableBar.value = this.workshop.availableHours + ' Stunden'; this.availableBar.setMeterPercentage(this.workshop.availableHours/this.workshop.initialHours); // If the timer is running = the workshop is producing something. if (this.workshop.timer &amp;&amp; this.workshop.timer.elapsed != this.workshop.timer.delay) { this.itemImage.setTexture(this.workshop.item.imageCode); // set itemImage texture to the item that is currently produced. this.itemImage.setScale(getScaling(this.workshop.item.imageCode)); // Rescale, because the item images have different sizes. this.itemImage.alpha = 1; // make the item visible. this.producingText.text = 'Produziert: '; this.workProgress.setMeterPercentage(this.workshop.timer.elapsed/this.workshop.timer.delay); this.workProgress.value = 'Dauer: ' + Math.ceil(((this.workshop.timer.delay - this.workshop.timer.elapsed)/1000)/PRODUCTION_TIME_SCALING); } else { // The workshop is not producing at the moment. try { // If there is an image, make it invisible. this.itemImage.alpha = 0; } catch { // There is no item image to make transparent. Just continue with the program } this.workProgress.value = ''; this.workProgress.setMeterPercentage(0); // reset the progressBar to 0. this.producingText.text = 'Produziert: Nichts.'; } } /** * This function adds the produce buttons inside the workshop dialogue * on top of the progess display and the queue. * Therefore it changes the size of the dialogue and the position of the * progress display and queue. * * @returns {Number} The new offset for the following objects, that * appear in the dialogue. */ addProduceButtons() { // The offset to increase the size of the panel. // This is used to provide more space as the produce buttons // are shown here if not in the management. let offset = 100; this.panel.panel.displayHeight += offset; this.panel.contents.displayHeight += offset; // Height is applied on both sides, hence we need to move up the // Game elements by the half of the given offset this.panel.buttonRound.y -= offset/2; this.panel.cross.y -= offset/2; this.panel.headerText.y -=offset/2; // Add textfields to display the costs. this.costsLeft = this.addCostsContainer(-this.panel.panel.displayWidth/2.5,-offset*1.3,this.workshop.items[0]); this.panel.add(this.costsLeft); this.costsRight = this.addCostsContainer(this.panel.panel.displayWidth/5,-offset*1.3,this.workshop.items[1]); this.panel.add(this.costsRight); // Adding buttons to produce the parts of items /** * If the option [PRODUCE_IN_MANAGEMEN]{@link GameProperties#PRODUCE_IN_MANAGEMENT} is set to `false`, a button is created * to initiatie the production of one part of furniture. * This button is located on the left. * * @type {Button} * */ this.buttonLeft = new Button( this,-this.panel.panel.displayWidth/9,-offset, 'button-square-unpressed','button-square',this.workshop.items[0].imageCode,function() { let canAfford = this.workshop.management.canAfford(this.workshop.items[0]); let amount = 1; if (PRODUCE_ONE_CLICK &amp;&amp; PRODUCE_PARTS) { let scaledCosts = scalePartsCosts(this.workshop.items[0]); let item = {...this.workshop.items[0]}; item.costs = scaledCosts; canAfford = this.workshop.management.canAfford(item); amount = this.workshop.items[0].demand; } if (canAfford.status == true) { for (let i = 0; i &lt; amount; i++) { this.workshop.management.produce(this.workshop.items[0]); } // If the production was successfully initiated: this.buttonLeft.showMessage('Wird gebaut!'); this.emitter.emit('itemButtonClicked', this.workshop.items[0].name, undefined); this.clickSound.play(); } else { // If not, pass the reason obtained from the canAfford method // from management. this.buttonLeft.showMessage(canAfford.reason, true); this.emitter.emit('itemButtonClicked', this.workshop.items[0].name, canAfford.reason); this.errorSound.play(); } }, this, this.workshop.items[0].name); /** * If the option [PRODUCE_IN_MANAGEMENT]{@link GameProperties#PRODUCE_IN_MANAGEMENT} is set to `false`, a button is created * to initiatie the production of one part of furniture. * * @type {Button} */ this.buttonRight = new Button( this,this.panel.panel.displayWidth/9,-offset, 'button-square-unpressed','button-square',this.workshop.items[1].imageCode,function() { let canAfford = this.workshop.management.canAfford(this.workshop.items[1]); let amount = 1; if (PRODUCE_ONE_CLICK &amp;&amp; PRODUCE_PARTS) { let scaledCosts = scalePartsCosts(this.workshop.items[1]); let item = {...this.workshop.items[1]}; item.costs = scaledCosts; canAfford = this.workshop.management.canAfford(item); amount = this.workshop.items[1].demand; } if (canAfford.status == true) { for (let i = 0; i &lt; amount; i++) { this.workshop.management.produce(this.workshop.items[1]); } this.buttonRight.showMessage('Wird gebaut!'); this.emitter.emit('itemButtonClicked', this.workshop.items[1].name, undefined); this.clickSound.play(); } else { this.buttonRight.showMessage(canAfford.reason, true); this.emitter.emit('itemButtonClicked', this.workshop.items[1].name, canAfford.reason); this.errorSound.play(); } }, this, this.workshop.items[1].name); // We need the button to be a bit larger. this.buttonLeft.setButtonScale(1.3); this.buttonLeft.messageOffsetX = -50; this.buttonRight.setButtonScale(1.3); this.buttonRight.messageOffsetX = 50; this.panel.add([this.buttonLeft, this.buttonRight]); return offset/2; // Tell the following game objects where to move } /** * Creates a container that adds the required resources for the particular part. * It has textfields to indicate the costs of the item (wood, metal and time). * See the [Phaser Docs]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Container.html}. * @returns {Phaser.GameObjects.Container} the container that has been created. */ addCostsContainer(x,y, item) { let costs = item.costs; if (PRODUCE_ONE_CLICK) { costs = scalePartsCosts(item); } let costHeader = new Phaser.GameObjects.Text(this, 0,0, 'Kosten', {fontSize:18,color: '#000'}).setOrigin(0,0.3); let woodText = new Phaser.GameObjects.Text(this, 0,costHeader.y+20, costs.wood,{fontSize:18,color: '#000'}).setOrigin(0,0.3); let wood = new Phaser.GameObjects.Sprite(this, woodText.width, woodText.y, 'wood').setScale(0.04).setOrigin(-0.3, 0.4); let metalText = new Phaser.GameObjects.Text(this, 0,woodText.y+20, costs.metal,{fontSize:18,color: '#000'}).setOrigin(0,0.3); let metal = new Phaser.GameObjects.Sprite(this, woodText.width, metalText.y, 'metal').setScale(0.04).setOrigin(-0.3, 0.4); let costHours = Math.max(...Object.values(costs).slice(2)); // Get the maximum value of all costs. We assume that a part is only produced in one workshop! let timeText = new Phaser.GameObjects.Text(this, 0,metalText.y+20, costHours+ ' Std.',{fontSize:18,color: '#000'}).setOrigin(0,0.3); let container = new Phaser.GameObjects.Container(this, x,y, [costHeader,woodText,wood,metalText,metal,timeText]); return container; } } export default WorkshopDialogue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"WorkshopQueue.js.html":{"id":"WorkshopQueue.js.html","title":"Source: WorkshopQueue.js","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Source: WorkshopQueue.js import {getScaling} from './Item.js'; /** * @classdesc * This class is responsible for displaying the items that will be produced next for one workshop. * It displays the five next items. If the queue is longer than five, these items are invisible until they belong to the * indices 0-4. * * @class WorkshopQueue * @extends Phaser.GameObjects.Container * @see [Phaser.GameObjects.Container]{@link https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Container.html} * @constructor * @param {object} data the data object that contains the required information to build the queue. * @param {Phaser.Scene} data.scene the scene where the queue should be rendered in. This is usually a [WorkshopDialogue]{@link WorkshopDialogue}. * @param {number} data.x the x coordinate where the queue is displayed in. * @param {number} data.y the y coordinate where the queue is displayed in. */ class WorkshopQueue extends Phaser.GameObjects.Container { constructor(data) { let {scene, x,y} = data let queue = scene.workshop.queue; let sprites = []; let spriteX = -125; // this is the location of the first image for (let i = 0; i &lt; 5; i++) { // Pushing placeholders in form of invisible chairs to the list of sprites // this way it can be controlled, that only five items are shown inside the queue. sprites.push(new Phaser.GameObjects.Sprite(scene,spriteX,0, 'chair').setScale(getScaling('chair')).setAlpha(0)); spriteX += 60; // To display the item side-by-side, the x coordinate is increased every iteration. } super(scene,x,y,sprites); /** * This is a list of sprites. * Its size is always 5 corresponding to the maximum of visible values in this queue. * If the queue is smaller than 5, the rest of the items inside the sprite list will be set to invisible, * but they still use space. This ensures the stack-like behavior. * * @type {Array.&lt;Phaser.Sprite&gt;} */ this.sprites = sprites; /** * The queue is obtained from the {@link Workshop#queue}. * It is a list of objects that are structured the following way: * @type {Array.&lt;object&gt;} * @property {Process} process the production process of the item * @property {number} time the production duration that is reserved for the process. */ this.queue = queue; /** * The scene where this object is rendered. * * @see [Phaser.Scene]{@link https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html} */ this.scene = scene; } /** * Refresh the status of the queue. * This function iterates over the images and if there are items inside the queue, * it displays them by getting the imageCode and making them visible by setting alpha to 1. * If an item does not exist in the queue, it is set to transparent (= invisible). */ update() { for (let i = 0; i &lt; this.sprites.length; i++) { if (this.queue &amp;&amp; this.scene.workshop.queue.length &gt; 0) { if (this.queue[i]) { let imageKey = this.queue[i].process.item.imageCode; this.sprites[i].setTexture(imageKey) this.sprites[i].setScale(getScaling(imageKey)); this.sprites[i].setAlpha(1); } else this.sprites[i].setAlpha(0); } else this.sprites[i].setAlpha(0); } } } export default WorkshopQueue; × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Modules Classes AiDialogue AssesmentDialogue Building Button Diagram DialogueScene DialogueSchedule EventDispatcher FinalSummary FinalSummary FormUtil InformerBanner InteractionScene LikertScale MainScene Management ManagementDialogue Market MarketDialogue MessageDialogue ProfitSummary ItemPriceTable Item ProfitSummary NewsScene Panel PartDisplay Player Preloader Process ProgressBar ProgressBarVertical RadioButton Storage StorageEntry TextDialogue Tutorial Ui WarningDialogue Workshop WorkshopDialogue WorkshopQueue × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Classes Classes AiDialogue AssesmentDialogue Building Button Diagram DialogueScene DialogueSchedule EventDispatcher FinalSummary FinalSummary FormUtil InformerBanner InteractionScene LikertScale MainScene Management ManagementDialogue Market MarketDialogue MessageDialogue ProfitSummary ItemPriceTable Item ProfitSummary NewsScene Panel PartDisplay Player Preloader Process ProgressBar ProgressBarVertical RadioButton Storage StorageEntry TextDialogue Tutorial Ui WarningDialogue Workshop WorkshopDialogue WorkshopQueue × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Tutorials Classes AiDialogue AssesmentDialogue Building Button Diagram DialogueScene DialogueSchedule EventDispatcher FinalSummary FinalSummary FormUtil InformerBanner InteractionScene LikertScale MainScene Management ManagementDialogue Market MarketDialogue MessageDialogue ProfitSummary ItemPriceTable Item ProfitSummary NewsScene Panel PartDisplay Player Preloader Process ProgressBar ProgressBarVertical RadioButton Storage StorageEntry TextDialogue Tutorial Ui WarningDialogue Workshop WorkshopDialogue WorkshopQueue × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey The Furniture Company Documentation of the Strategy Game Version This documentation as two main purposes: Firstly it provides an API documentation on how to use the classes of the project. This should help making adjustments to the code and other customizations. The documentation can be found by navigating to the Classes tab. The second Purpose is to help at setting up the project in SosciSurvey by providing tutorials. These can be found inside the Tutorials tab. There are several options that can be adjusted to change the behavior of the game. A documentation of the different Option can be found in the Modules tab. × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"AiDialogue.html":{"id":"AiDialogue.html","title":"Class: AiDialogue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: AiDialogue AiDialogue This class provides dialogue scene to get a user text input. In order to create this dialogue the values required by the DialogueScene must be provided on creation. Therefore, see DialogueScene#init. new AiDialogue() Source: AiDialogue.js, line 24 Example // go to the place, where the scene should be started and insert the following line this.scene.launch('textDialogue', {mainScene: this, title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION questionNumber: NUMBER}); // \"this\" must be a scene, because this.scene points at the scene manager of the specific scene. Members aiData :Object The profit of the items in the scenario that the character describes. The item entries of this object have the properties profit and solution. Type: Object Properties: Name Type Description chair Object the properties of the chair table Object the table item bookcase Object the bookcase item bed Object the bed item material Object the material which can be accessed with wood and metal. Source: AiDialogue.js, line 49 formUtil :FormUtil The form util takes care of the setup of the text area. Type: FormUtil Source: AiDialogue.js, line 133 question :String The question that is displayed to the user above the input field, where the player can type in the answer. Type: String Source: AiDialogue.js, line 65 questionNumber :number The question number specifies in what sosci survey item the value is stored. This is important, if there are multiple text dialogues to keep track of the different questions. Type: number Source: AiDialogue.js, line 58 title :String This is the title of the dialogue. Type: String Source: AiDialogue.js, line 37 Methods createFurnitureEntry(x, y, picture [, scale], value [, gold]) Creates an image and a text element. This can be used to create entries for furniture inside the table. Parameters: Name Type Argument Default Description x number x-position of the sprite y number y-position of the sprite picture String the image key of the furniture that should be displayed. scale number &lt;optional&gt; 1 the scale of the image. value * the value that should be displayed beneath the sprite gold boolean &lt;optional&gt; false defines whether a money symbol should be displayed additionally. Source: AiDialogue.js, line 208 Returns: a list containing the image and the text object to be added to the scene Type Array sendText() This function sends the text that has been typed in by the player via the Sosci Writer. If ON_LOCAL_MACHINE is set to true, the value is just being printed. Source: AiDialogue.js, line 164 setQuestionFontSize(size) Adjust the size of the question text. Parameters: Name Type Description size number the desired fontsize for the question Source: AiDialogue.js, line 193 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"AssesmentDialogue.html":{"id":"AssesmentDialogue.html","title":"Class: AssesmentDialogue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: AssesmentDialogue AssesmentDialogue This class provides dialogue scene to get a user text input. In order to create this dialogue the values required by the DialogueScene must be provided on creation. Therefore, see DialogueScene#init. new AssesmentDialogue() Source: AssesmentDialogue.js, line 25 Example // go to the place, where the scene should be started and insert the following line this.scene.launch('textDialogue', {mainScene: this, title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION questionNumber: NUMBER}); // \"this\" must be a scene, because this.scene points at the scene manager of the specific scene. Members formUtil :FormUtil The form util takes care of the setup of the text area. Type: FormUtil Source: AssesmentDialogue.js, line 76 question :String The question that is displayed to the user above the input field, where the player can type in the answer. Type: String Source: AssesmentDialogue.js, line 52 questionNumber :number The question number specifies in what sosci survey item the value is stored. This is important, if there are multiple text dialogues to keep track of the different questions. Type: number Source: AssesmentDialogue.js, line 45 title :String This is the title of the dialogue. Type: String Source: AssesmentDialogue.js, line 38 Methods sendText() This function sends the text that has been typed in by the player via the Sosci Writer. If ON_LOCAL_MACHINE is set to true, the value is just being printed. Source: AssesmentDialogue.js, line 107 setQuestionFontSize(size) Adjust the size of the question text. Parameters: Name Type Description size number the desired fontsize for the question Source: AssesmentDialogue.js, line 138 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Building.html":{"id":"Building.html","title":"Class: Building","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Building Building This class implements a superclass for implementing different buildings. It handels renders an image of a building, takes care of the positioning and implements a click listener. new Building(data) Parameters: Name Type Description data object an object that stores the information needed to build this class. Properties Name Type Description scene Phaser.Scene the scene where the management building should be built in. See Phaser.Scene x Number the x coordinate where the building should be placed. y Number the y coordinate for the building. image String the image key of the building. name String the name of the building. Source: Building.js, line 3 See: Phaser.GameObjects.Container Extends Phaser.GameObjects.Container Members buildingSprite :Phaser.GameObjects.Sprite The sprite that renders the building. See Phaser.GameObjects.Sprite. Type: Phaser.GameObjects.Sprite Source: Building.js, line 53 emitter :EventDispatcher The Emitter is an instance of the EventDispatcher and is used to record the actions performed by the user. In the case of buildings, we always want to record which building has been opened by the player. Type: EventDispatcher Source: Building.js, line 84 image :Phaser.GameObjects.Sprite The image sprite of the building Type: Phaser.GameObjects.Sprite Source: Building.js, line 92 name :String The name of the Building. This is also the name that is displayed in the tooltip. Type: String Source: Building.js, line 41 scene :Phaser.Scene The Scene where the building should be rendered in. In this case this is usually the MainScene. Type: Phaser.Scene Source: Building.js, line 61 See: Phaser.Scene sign A sign that can be placed beneath a building Source: Building.js, line 46 tooltip :Phaser.GameObjects.Sprite This is the tooltip object that is triggered if the cursor is on the building. Type: Phaser.GameObjects.Sprite Source: Building.js, line 68 tooltipText :Phaser.GameObjects.BitmapText The text that should be inside the tooltip. It contains the name of the building. Type: Phaser.GameObjects.BitmapText Source: Building.js, line 76 Methods addClickListener(func) Adds a listener that reacts on a click on the object. This is used for triggering a dialogue if a specific building is clicked. The function to initiate the individual dialogue must be passed by the instance. Parameters: Name Type Description func function the function that should be triggered, after the object as been clicked. Source: Building.js, line 111 addFlashEffect() Add a flash effect to the building to highlight it for the tutorial. Source: Building.js, line 157 addPointerListeners() Adds pointer events to toggle the display of the tooltip if the pointer is hovering over a building. It will fade in the tooltip if the cursor is above and fade it out if the cursor leaves the building. Source: Building.js, line 129 stopFlashEffect() Stop the flash effect. Source: Building.js, line 174 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Button.html":{"id":"Button.html","title":"Class: Button","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Button Button This class represents a button that can be used in the game. It provides a click animation as well as a text animation to show messages on click. It extends a Phaser container, consider the Phaser API page for more information. new Button(scene, x, y, buttonTexture, buttonTexturePressed, buttonImage, callback, context [, tooltipText]) Parameters: Name Type Argument Description scene Phaser.Scene The scene to display the button in. x Number the x coordinate of the button. y Number the y coordinate of the button. buttonTexture String the texture of the button. buttonTexturePressed String The Picture of the button if it is pressed. buttonImage String the image key pointing to the image that should be shown inside the button. If no image has been found under this key, a text element is created instead with the provided from buttonImage. callback function the function that should be called if the button has been clicked. context Object the context where the callback function should act inside. tooltipText String &lt;optional&gt; if a tooltipText is provided it gets displayed in a tooltip above the button, if the pointer hovers over it. If not provided, no tooltip will be shown. Source: Button.js, line 1 Extends Phaser.GameObjects.Container Members callback :function The callback function, that will be called after button click. Type: function Source: Button.js, line 64 context :Object The context to run the callback function in. It should contain all elements that the callback function needs. Often the context is just the calling class instance. Type: Object Source: Button.js, line 84 Example // callback function button.callback = function() { console.log('Hello ' + this.str); } // This function can be run and in the context we can specify the str element. // If the context was like this button.context = {str: 'World'}; button.callback() // ==&gt; 'Hello World' image :String The image that will be located inside the button. This is a string that can be defined in the Preloader class. Type: String Source: Button.js, line 103 messageOffsetX :Number The X-Coordinate for the message that is animated after button click. By default the message emerges from the middle of the button. Type: Number Default Value: 0 Source: Button.js, line 57 scene :Phaser.Scene The scene where the button should be placed in. Type: Phaser.Scene Source: Button.js, line 48 texture :String The texture of the button. This can be seen as the background image of the button. This is a string, pointing to a key inside the texture manager of the phaser engine. Hence, it is the string that is defined in the Preloader class from the image path. Type: String Source: Button.js, line 95 Methods closeMessage(message, duration) This method closes the given message by animating its fadeout. Parameters: Name Type Description message Object the text object to be closed duration Number the duration of the fade-out animation. Source: Button.js, line 204 setButtonScale(scale) Scale the button texture. This does not affect the image inside the button. You can call the Button#setImageScale function for this sake. Parameters: Name Type Description scale Number the target scale of the button texture. Source: Button.js, line 148 setCallbackFunction(func) Specifies the callback function to change it later. Parameters: Name Type Description func function the callback function which will be triggered after a click. Source: Button.js, line 239 setContext(context) Specify the context for the callback function Parameters: Name Type Description context Object the context as an object containing a scene, a button object and an item (part) see Button#context. Source: Button.js, line 248 setImageScale(scale) Scale the image inside the button. Does not affect the button scale. Parameters: Name Type Description scale Number the target scale of the image. Source: Button.js, line 157 setOrigin(x [, y]) Sets the same origin for the button texture and the button image. The origin indicates the offset of the game object from the given position Parameters: Name Type Argument Default Description x Number The origin value on the x axis. y Number &lt;optional&gt; x The origin value for the y axis Source: Button.js, line 227 Example button.setOrigin(0.5) // Positions the middle of the sprite at its given x-and y coordinate. setTooltip(text) This function adds a tooltip to the button, that will be displayed, if the cursor hovers over it. Parameters: Name Type Description text String The text that should be displayed inside the tooltip. Source: Button.js, line 257 showMessage(text [, alert] [, distance] [, duration]) This function displays a message at the location of the button. It can be used to inform the player if an item has been built successfully. This function automatically invokes an animation of the text, gliding to the top and triggering the closeMessage function to fade out the text object. Parameters: Name Type Argument Default Description text String The text that should be displayed to the user. alert boolean &lt;optional&gt; false A boolean. By default it is false causing the text to be black. If set to true, the text is red. In the game this is used to inform the player about an error like missing material. distance number &lt;optional&gt; 30 specifies how far the text should travel to the top if shown. duration number &lt;optional&gt; 0 specifies how long the message should be displayed Source: Button.js, line 175 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Diagram.html":{"id":"Diagram.html","title":"Class: Diagram","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Diagram Diagram Implements a diagram that displays a comparison of profit on the y-axix and the month on the x-axis. It is used to compare the player's and the optimal profit during the game. It is displayed at a MarketDialogue as well as in the NewsScene. new Diagram(data) Parameters: Name Type Description data object the data object that is used to create a diagram. Properties Name Type Argument Description scene Phaser.Scene the scene in which the diagram should be drawn. lpProfits Array a list of the optimal profits for every month. playerProfits Array a list of the player's profits for every month. month number the number of months. This is used to scale the x-axis. x number the x position for the starting point of the diagram. y number the y position for the diagram. height number &lt;optional&gt; the height of the diagram. width number &lt;optional&gt; the width of the diagram. Source: Diagram.js, line 20 Members diagramHeight The height of the diagram. If the height has not been specified inside the constructor, the default value DIAGRAM_HEIGHT is used. Source: Diagram.js, line 92 diagramWidth The width of the diagram. If the width has not been specified inside the constructor, the default value DIAGRAM_WIDTH is used. Source: Diagram.js, line 98 graphics :Phaser.GameObjects.Graphics This is an instance of the Phaser graphics and is used to draw inside a scene. Type: Phaser.GameObjects.Graphics Source: Diagram.js, line 50 See: Phaser.GameObjects.Graphics lpProfits :Array The list of optimal profits for every month. The length of this array is used to define for how many months the graph is displayed. As we only want to display the values until the current month, the length of this array always corresponds to the actual month. Type: Array Source: Diagram.js, line 58 maxMonths :number This value defines the maximum number of months for which the diagram should be scaled. It also has impact to the labeling and scaling of the x-axis. This is normally set to 12, to always display the x-axis with 12 steps. Type: number Source: Diagram.js, line 74 maxProfit This is maximum profit that can be reached for a month in the game. It is used to scale the y-axis of the diagram, causing the maximum profit to be the highest point. Source: Diagram.js, line 80 playerProfits :Array The profits of the player for every month. The length of this array is used to define for how many months the graph is displayed. As we only want to display the values until the current month, the length of this array always corresponds to the actual month. Type: Array Source: Diagram.js, line 66 scene :Phaser.Scene The scene where this diagram is drawn. Type: Phaser.Scene Source: Diagram.js, line 29 startX :number The x bottom left starting point of the diagram. This is initially set via the x value given by the constructor. Type: number Source: Diagram.js, line 36 startY :number The y starting point of the diagram. Type: number Source: Diagram.js, line 43 Methods addBorder() Adds a border for the diagram, by drawing a rectangle taking the height and width into account. Source: Diagram.js, line 112 addDescription() Adds the description for the axis Source: Diagram.js, line 186 addOptimalProfit() Adds the profits from the linear model for each month to the diagram. Source: Diagram.js, line 150 addPlayerProfit() Adds the profit of the player to the diagram Source: Diagram.js, line 135 scaleHeight(value) This function scales a profit value relative to the maximum value and the height of the diagram. Parameters: Name Type Description value int The profit for a given month Source: Diagram.js, line 167 Returns: the scaled value to be added as y coordinate to the diagram. scaleWidth(value) This function scales the given month relative to the maximum amount of months and the width of the diagram. Parameters: Name Type Description value int a month starting at 1. Source: Diagram.js, line 178 Returns: the scaled value to be added as x coordinate to the diagram. × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"DialogueScene.html":{"id":"DialogueScene.html","title":"Class: DialogueScene","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: DialogueScene DialogueScene This class implements a wrapper for dialogues. Such a dialogue usually consists of a frame where contents can be placed and a close button. This class also handels animations and appearance of the dialogue window and my be extended by every dialogue. As an example: this class is extended for every dialogue that is launched if a building is clicked. new DialogueScene(sceneName) Parameters: Name Type Description sceneName String The scene name is defined at creation of the scene and is used to find, launch or close the scene by the SceneManager. Source: DialogueScene.js, line 4 See: Phaser.Scene Extends Phaser.Scene Members data :object Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way the scene can be used more flexible. As an example: the WorkshopDialogue maintains an instance of the workshop, to read the status and schedule building orders. The workshop can be passed as an entry in this data object. Type: object Source: DialogueScene.js, line 59 emitter The EventDispatcher to monitor that a dialogue has been closed by the player Source: DialogueScene.js, line 65 height :number The height of the dialogue. Type: number Source: DialogueScene.js, line 45 mainScene :MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. Type: MainScene Source: DialogueScene.js, line 39 panel :Panel The panel which renders the frame and the headline. Type: Panel Source: DialogueScene.js, line 112 width :number The width of the dialogue. Type: number Source: DialogueScene.js, line 51 Methods close() This function creates a closing effect, animating the scale of the panel to zero within 150 milliseconds. This function also stops the scene that is calling the function and enables the inputs of the main scene. Source: DialogueScene.js, line 74 createDialogue(header) Creates a panel that can be filled with content by every class inheriting from this class. Note that the panel initially has a scale of zero causing the object to be invisible. The function fadeIn can be used to make it appear. Alternatively the scale of the panel can be set to 1 manually. This function also disables every input for the main scene, which means that the player cannot open new buildings or navigate through the map as long as a dialogue is opened. The close function re-enables the inputs of the main scene. Parameters: Name Type Default Description header string Header the headline which will be displayed on top of the panel. Source: DialogueScene.js, line 103 fadeIn( [completeCallback]) This function is used to animate the appearance of the panel, by animating its scale to 100% within 150 milliseconds. Parameters: Name Type Argument Description completeCallback function &lt;optional&gt; a function that is executed once the animation has finished. Source: DialogueScene.js, line 128 init(data) The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. launch start). In this case the additional data is used to build a basic panel that can be adopted by every class that is extending this class. Parameters: Name Type Description data object the data object contains relevant data for this scene as well as additional data that can be used by the child scenes of this DialogueScene. See {@DialogueScene#data}. Properties Name Type Description mainScene MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. height number The height of the dialogue. width number The width of the dialogue. Source: DialogueScene.js, line 34 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"DialogueSchedule.html":{"id":"DialogueSchedule.html","title":"Class: DialogueSchedule","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: DialogueSchedule DialogueSchedule This class takes care of the dialogues that appear during the game. Dialogues inside this structure are displayed after each other to prevent dialogues from appearing at the same time. The dialogues that are added to the scheduler are organized as a list, that will be worked off item per item. new DialogueSchedule(scenePlugin) Parameters: Name Type Description scenePlugin Phaser.Scenes.ScenePlugin the plugin that is needed to launch the dialogues. Source: DialogueSchedule.js, line 3 Members currentDialogue The current dialogue that is opened at the moment. Source: DialogueSchedule.js, line 33 dialogues :Array.&lt;object&gt; An array of dialogues that are scheduled. They will be launched in its order. Type: Array.&lt;object&gt; Source: DialogueSchedule.js, line 28 scenePlugin The scene plugin that is used to run the dialogues. Source: DialogueSchedule.js, line 22 Methods addDialogue(key, data [, addToFront]) Add a dialogue to the scheduler. The dialogue will be added to the end of the list. Parameters: Name Type Argument Default Description key string the key for the sceneManager data object the data that is needed to create the scene. See DialogueScene. addToFront boolean &lt;optional&gt; false if set to true, the dialogue will be added to the front of the list instead of the end. Source: DialogueSchedule.js, line 44 run() Runs all scheduled dialogues until the dialogues list is empty. Source: DialogueSchedule.js, line 81 startNextDialogue() Starts the the next dialogue from the list and removes the element. Source: DialogueSchedule.js, line 65 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"EventDispatcher.html":{"id":"EventDispatcher.html","title":"Class: EventDispatcher","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: EventDispatcher EventDispatcher This class implements a global event emitter to track the behavior of a player by recording the clicks that are made along with timestamps. new EventDispatcher() Source: EventDispatcher.js, line 10 Members actions A list of actions that have been taken. The index is the same as for timestamps, action as index i has been performed at timestamp i. Source: EventDispatcher.js, line 30 months Allows to keep track of the month in which action have been performed Source: EventDispatcher.js, line 35 timestamps :Array.&lt;number&gt; A list of times where an event happened the function activateListeners listens to. The format is in seconds and should be stored together with the corresponding actions. Type: Array.&lt;number&gt; Source: EventDispatcher.js, line 23 Methods &lt;static&gt; getInstance() Returns the instance of the EventDispatcher if any. If not, a new instance will be created. If the EventDispatcher should be used, make sure to call this method like shown in the example. Source: EventDispatcher.js, line 128 Returns: the event dispatcher that handels global events. Type EventDispatcher Example // at an arbitrary point in the game this.emitter = EventDispatcher.getInstance(); // Then use it, for example by emitting an event: this.emitter.emit(\"myEvent\", data); activateListeners() Initiate listeners for the click events that should be recorded. Source: EventDispatcher.js, line 49 getActions() Returns the actions performed by a player along with the timestamps as a list of tuples. (As a String). It can be parsed in python via the ast.literal_eval function. Source: EventDispatcher.js, line 142 Returns: a string in the following fashion '[(action, timestamp), (acton,timestamp),...]'. Type string getShortForm(value) Returns the key corresponding to the given value of the action map. Parameters: Name Type Description value String the value that is used to get the corresponding key. Source: EventDispatcher.js, line 176 Returns: the key, representing the short form of the value. Type String logAction(action) Log an action. This function will add the message that describes the action that has been recorded to the actions list. If ON_LOCAL_MACHINE is false, the timestamp will also be added. Parameters: Name Type Description action string the text that describes what action the player has done. Source: EventDispatcher.js, line 98 logCurrentTime() Get the current time and append it to timestamps. Source: EventDispatcher.js, line 111 setMainScene(mainScene) Add the MainScene to the event dispatcher in order to access the current month. Parameters: Name Type Description mainScene MainScene Source: EventDispatcher.js, line 166 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"FinalSummary.html":{"id":"FinalSummary.html","title":"Class: FinalSummary","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: FinalSummary FinalSummary This Scene acts as a final summary for the player after he or she finishes the last month. It will start a summary similar to a MarketDialogue with the exception that the values are summed up for the entire year. Furthermore this scene cannot be closed but it ends the game and goes to the next page after ten seconds if the game runs on Soscisurvey and ON_LOCAL_MACHINE is set to false. new FinalSummary() Source: FeedbackDialogue.js, line 10 Extends DialogueScene Members background :Phaser.GameObjects.Sprite The background sprite. It is a black, slightly transparent rectangle, that is used to darken the background. Type: Phaser.GameObjects.Sprite Source: FinalSummary.js, line 35 See: Phaser.GameObjects.Sprite data :object Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way the scene can be used more flexible. As an example: the WorkshopDialogue maintains an instance of the workshop, to read the status and schedule building orders. The workshop can be passed as an entry in this data object. Type: object Inherited From: DialogueScene#data Overrides: DialogueScene#data Source: DialogueScene.js, line 59 emitter The EventDispatcher to monitor that a dialogue has been closed by the player Inherited From: DialogueScene#emitter Overrides: DialogueScene#emitter Source: DialogueScene.js, line 65 height :number The height of the dialogue. Type: number Inherited From: DialogueScene#height Overrides: DialogueScene#height Source: DialogueScene.js, line 45 mainScene :MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. Type: MainScene Inherited From: DialogueScene#mainScene Overrides: DialogueScene#mainScene Source: DialogueScene.js, line 39 panel :Panel The panel which renders the frame and the headline. Type: Panel Inherited From: DialogueScene#panel Overrides: DialogueScene#panel Source: DialogueScene.js, line 112 summary :ProfitSummary The a summary container that is used to display the profits of the player and the optimal solution in a clear manner. The setFinalValues function is used to obtain the values for the entire year. Type: ProfitSummary Source: FinalSummary.js, line 57 width :number The width of the dialogue. Type: number Inherited From: DialogueScene#width Overrides: DialogueScene#width Source: DialogueScene.js, line 51 Methods close() This function creates a closing effect, animating the scale of the panel to zero within 150 milliseconds. This function also stops the scene that is calling the function and enables the inputs of the main scene. Inherited From: DialogueScene#close Overrides: DialogueScene#close Source: DialogueScene.js, line 74 create() Creates the dialogues and all related game objects that are required in this scene. This function runs automatically after the scene has been started. Source: FinalSummary.js, line 27 createDialogue(header) Creates a panel that can be filled with content by every class inheriting from this class. Note that the panel initially has a scale of zero causing the object to be invisible. The function fadeIn can be used to make it appear. Alternatively the scale of the panel can be set to 1 manually. This function also disables every input for the main scene, which means that the player cannot open new buildings or navigate through the map as long as a dialogue is opened. The close function re-enables the inputs of the main scene. Parameters: Name Type Default Description header string Header the headline which will be displayed on top of the panel. Inherited From: DialogueScene#createDialogue Overrides: DialogueScene#createDialogue Source: DialogueScene.js, line 103 fadeIn( [completeCallback]) This function is used to animate the appearance of the panel, by animating its scale to 100% within 150 milliseconds. Parameters: Name Type Argument Description completeCallback function &lt;optional&gt; a function that is executed once the animation has finished. Inherited From: DialogueScene#fadeIn Overrides: DialogueScene#fadeIn Source: DialogueScene.js, line 128 init(data) The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. launch start). In this case the additional data is used to build a basic panel that can be adopted by every class that is extending this class. Parameters: Name Type Description data object the data object contains relevant data for this scene as well as additional data that can be used by the child scenes of this DialogueScene. See {@DialogueScene#data}. Properties Name Type Description mainScene MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. height number The height of the dialogue. width number The width of the dialogue. Inherited From: DialogueScene#init Overrides: DialogueScene#init Source: DialogueScene.js, line 34 update() This function is an infinite loop that updates the seconds that are left until the values are sent to Soscisurvey. Source: FinalSummary.js, line 103 Class: FinalSummary FinalSummary This Scene acts as a final summary for the player after he or she finishes the last month. It will start a summary similar to a MarketDialogue with the exception that the values are summed up for the entire year. Furthermore this scene cannot be closed but it ends the game and goes to the next page after ten seconds if the game runs on Soscisurvey and ON_LOCAL_MACHINE is set to false. new FinalSummary() Source: FinalSummary.js, line 6 Extends DialogueScene Members background :Phaser.GameObjects.Sprite The background sprite. It is a black, slightly transparent rectangle, that is used to darken the background. Type: Phaser.GameObjects.Sprite Source: FinalSummary.js, line 35 See: Phaser.GameObjects.Sprite data :object Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way the scene can be used more flexible. As an example: the WorkshopDialogue maintains an instance of the workshop, to read the status and schedule building orders. The workshop can be passed as an entry in this data object. Type: object Inherited From: DialogueScene#data Overrides: DialogueScene#data Source: DialogueScene.js, line 59 emitter The EventDispatcher to monitor that a dialogue has been closed by the player Inherited From: DialogueScene#emitter Overrides: DialogueScene#emitter Source: DialogueScene.js, line 65 height :number The height of the dialogue. Type: number Inherited From: DialogueScene#height Overrides: DialogueScene#height Source: DialogueScene.js, line 45 mainScene :MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. Type: MainScene Inherited From: DialogueScene#mainScene Overrides: DialogueScene#mainScene Source: DialogueScene.js, line 39 panel :Panel The panel which renders the frame and the headline. Type: Panel Inherited From: DialogueScene#panel Overrides: DialogueScene#panel Source: DialogueScene.js, line 112 summary :ProfitSummary The a summary container that is used to display the profits of the player and the optimal solution in a clear manner. The setFinalValues function is used to obtain the values for the entire year. Type: ProfitSummary Source: FinalSummary.js, line 57 width :number The width of the dialogue. Type: number Inherited From: DialogueScene#width Overrides: DialogueScene#width Source: DialogueScene.js, line 51 Methods close() This function creates a closing effect, animating the scale of the panel to zero within 150 milliseconds. This function also stops the scene that is calling the function and enables the inputs of the main scene. Inherited From: DialogueScene#close Overrides: DialogueScene#close Source: DialogueScene.js, line 74 create() Creates the dialogues and all related game objects that are required in this scene. This function runs automatically after the scene has been started. Source: FinalSummary.js, line 27 createDialogue(header) Creates a panel that can be filled with content by every class inheriting from this class. Note that the panel initially has a scale of zero causing the object to be invisible. The function fadeIn can be used to make it appear. Alternatively the scale of the panel can be set to 1 manually. This function also disables every input for the main scene, which means that the player cannot open new buildings or navigate through the map as long as a dialogue is opened. The close function re-enables the inputs of the main scene. Parameters: Name Type Default Description header string Header the headline which will be displayed on top of the panel. Inherited From: DialogueScene#createDialogue Overrides: DialogueScene#createDialogue Source: DialogueScene.js, line 103 fadeIn( [completeCallback]) This function is used to animate the appearance of the panel, by animating its scale to 100% within 150 milliseconds. Parameters: Name Type Argument Description completeCallback function &lt;optional&gt; a function that is executed once the animation has finished. Inherited From: DialogueScene#fadeIn Overrides: DialogueScene#fadeIn Source: DialogueScene.js, line 128 init(data) The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. launch start). In this case the additional data is used to build a basic panel that can be adopted by every class that is extending this class. Parameters: Name Type Description data object the data object contains relevant data for this scene as well as additional data that can be used by the child scenes of this DialogueScene. See {@DialogueScene#data}. Properties Name Type Description mainScene MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. height number The height of the dialogue. width number The width of the dialogue. Inherited From: DialogueScene#init Overrides: DialogueScene#init Source: DialogueScene.js, line 34 update() This function is an infinite loop that updates the seconds that are left until the values are sent to Soscisurvey. Source: FinalSummary.js, line 103 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"FormUtil.html":{"id":"FormUtil.html","title":"Class: FormUtil","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: FormUtil FormUtil A class to nest html form elements into the game. new FormUtil() Author: William Clarkson (https://williamclarkson.net/) Source: formUtil.js, line 7 Methods disableResize(elName) Prevent the text area from being resized. Parameters: Name Type Description elName String the id of the textarea. Author: Eric Frodl Source: formUtil.js, line 87 hideTextArea(elName) Hides the text area. Parameters: Name Type Description elName String the id of the textarea to hide. Author: Eric Frodl Source: formUtil.js, line 109 showTextArea(elName) Sets the provided textarea to visible Parameters: Name Type Description elName String the id of the textarea. Author: Eric Frodl Source: formUtil.js, line 98 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"InformerBanner.html":{"id":"InformerBanner.html","title":"Class: InformerBanner","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: InformerBanner InformerBanner A message that fades into the screen and guides the player through the tutorial new InformerBanner() Source: InformerBanner.js, line 6 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"InteractionScene.html":{"id":"InteractionScene.html","title":"Class: InteractionScene","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: InteractionScene InteractionScene This class extends the classical DialogueScene to an interaction scene that can be used for the story of the game. It is designed for questions or notifications of the experiment. If an InteractionScene is started, the game time will be stopped and also the inputs of the Ui-scene will be blocked. new InteractionScene(sceneName) Parameters: Name Type Description sceneName String The scene name is defined at creation of the scene and is used to find, launch or close the scene by the SceneManager. Source: InteractionScene.js, line 2 Extends DialogueScene Members data :object Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way the scene can be used more flexible. As an example: the WorkshopDialogue maintains an instance of the workshop, to read the status and schedule building orders. The workshop can be passed as an entry in this data object. Type: object Inherited From: DialogueScene#data Source: DialogueScene.js, line 59 emitter The EventDispatcher to monitor that a dialogue has been closed by the player Inherited From: DialogueScene#emitter Source: DialogueScene.js, line 65 height :number The height of the dialogue. Type: number Inherited From: DialogueScene#height Source: DialogueScene.js, line 45 mainScene :MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. Type: MainScene Inherited From: DialogueScene#mainScene Source: DialogueScene.js, line 39 panel :Panel The panel which renders the frame and the headline. Type: Panel Inherited From: DialogueScene#panel Source: DialogueScene.js, line 112 width :number The width of the dialogue. Type: number Inherited From: DialogueScene#width Source: DialogueScene.js, line 51 Methods close() Override the close function from the DialogueScene to resume the game time Overrides: DialogueScene#close Source: InteractionScene.js, line 40 createDialogue(header) Creates the dialogue like and behaves like a normal DialogueScene but additionally stops the gametime and disables the input of the Ui. Parameters: Name Type Default Description header String Header the headline of the scene. Overrides: DialogueScene#createDialogue Source: InteractionScene.js, line 27 fadeIn( [completeCallback]) This function is used to animate the appearance of the panel, by animating its scale to 100% within 150 milliseconds. Parameters: Name Type Argument Description completeCallback function &lt;optional&gt; a function that is executed once the animation has finished. Inherited From: DialogueScene#fadeIn Source: DialogueScene.js, line 128 init(data) The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. launch start). In this case the additional data is used to build a basic panel that can be adopted by every class that is extending this class. Parameters: Name Type Description data object the data object contains relevant data for this scene as well as additional data that can be used by the child scenes of this DialogueScene. See {@DialogueScene#data}. Properties Name Type Description mainScene MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. height number The height of the dialogue. width number The width of the dialogue. Inherited From: DialogueScene#init Source: DialogueScene.js, line 34 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"LikertScale.html":{"id":"LikertScale.html","title":"Class: LikertScale","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: LikertScale LikertScale This class implements a labeled Likert scale, displaying radio buttons that can be checked. Depending on the checked button the scales returns a different score. new LikertScale() Source: LikertScale.js, line 1 Methods addCheckedListeners() Adds a checked listener for each radio button. This helps to identify which button has been clicked. This information is used to unceck the other buttons that might be active. With this method it is ensured, that only one radio button at a time is checked. Source: LikertScale.js, line 55 getValue() Return the value of the active RadioButton which corresponds to the response of the subject. Source: LikertScale.js, line 67 Returns: the value of the subject's response. Type number uncheckButtons(exception) Uncheck the other buttons to ensure that only one radioButton is checked at the same time. Parameters: Name Type Description exception RadioButton the button that should not be unchecked (which is the button that was recently clicked). Source: LikertScale.js, line 39 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"MainScene.html":{"id":"MainScene.html","title":"Class: MainScene","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: MainScene MainScene This is the main scene of the game. Here every game object is displayed as well as the map, the buildings, the Player. This scene also handels the timing, the camera to enable movement and it stores the profits of the player inside a Soci survey variable if activated. new MainScene() Source: MainScene.js, line 16 See: Phaser.Scene Extends Phaser.Scene Members buildSound The sound that is played when an Item has been sold. Source: MainScene.js, line 89 lpSolution The solution of the underlying linear programming problem. It is generated by loadSolution and has the following structure: Properties: Name Type Description numberOfBeds list the number of beds built to work optimal for every month. numberOfBookCases list the number of bookcases built every month. numberOfChairs list the number of chairs built to work optimal for every month. numberOfTables list the number of tables built to work optimal for every month. objective number the total optimal profit for the year. Source: MainScene.js, line 76 management_one :Management The first management, responsible for chairs and tables. Type: Management Source: MainScene.js, line 124 management_two :Management The second management, responsible for bed frames and bookcases. Type: Management Source: MainScene.js, line 142 market :Market The market, that is used to summarize the profits of the player. Type: Market Source: MainScene.js, line 166 monthIterator :iterator This is an iterator that is called if a new month is started, usually after the player skips to the next month or the time is up. Type: iterator Source: MainScene.js, line 52 newMonthSound The sound that is played when a new month is started. Source: MainScene.js, line 84 player :Player The player instance representing the player that is currently playing the game Type: Player Source: MainScene.js, line 58 tutorialPhase Indicates that the tutorial is currently active. Source: MainScene.js, line 45 Methods configureCamera() This function configures the camera to show a specific part of the map. it also enables navigation options for dragging the camera with the mouse. Source: MainScene.js, line 361 create() This function is called if a scene is created hence, made visible. It should be used to render the gameObjects that should be visible inside the scene. The map and all buildings as well as the ui at the top are rendered here. Source: MainScene.js, line 97 createItems() This function is used to create the items that are needed in the game. That is, the Item chair, table, bed and bookcase. Source: MainScene.js, line 188 &lt;generator&gt; createMonthIterator( [start] [, end]) The iterator that is used to simulate the year. Parameters: Name Type Argument Default Description start number &lt;optional&gt; 0 the number where the year should start end number &lt;optional&gt; 12 the number where the iterator should spot. Source: MainScene.js, line 382 createWorkshops() This function creates the four workshops that are used in the game. Source: MainScene.js, line 277 See: Workshop getProductionStatus() Get information whether one or more workshops are currently producing. Source: MainScene.js, line 572 Returns: 0 if none of the workshops are currently producing, 1 else. Type number init() The init function is run before the scene itself is created. This is useful to initialize variables that are needed at the beginning of the scene. Source: MainScene.js, line 40 nextMonth() This function is triggered if the month should be switched. it steps the monthIterator to the next month, maintains the profits of the player, resets the available time of the workshops and starts a new timer for the new month that expires to start a new month. If the last month is over, this function also triggers a final summary that informs the player that the game is over. Source: MainScene.js, line 398 renderTilemap() This function renders all layers of the map, resulting in the final game map. If you want to edit the map you can load the map file into tiled. Source: MainScene.js, line 334 Tutorials: Tutorial: map_editing resetProduction() This function stops all workshops and deletes available parts inside the storage. It also writes a flag indicating if a workshop was active during the month change. This helps to see if a player had not enough time to finish all parts. Source: MainScene.js, line 591 See: Workshop SosciWriter#writeProducingStatus showPriceChanges() This function renders a new Price table, that informs the player of the price changes. It is only be used if the option MONTHLY_PAUSE is set to `false`. Source: MainScene.js, line 543 See: ItemPriceTable startTimer() Starts the timer for the month. The duration of the timer is specified by the option MONTH_SECONDS. Source: MainScene.js, line 624 storeValues(month) This function stores the profit and produced items from player and model from the past month to SosciSurvey variables. Parameters: Name Type Description month number the month for which the profits should be stored. Source: MainScene.js, line 517 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Management.html":{"id":"Management.html","title":"Class: Management","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Management Management This Class is responsible for rendering a management building. In a management Building the player can see the Items that can be produced along with its costs and profit. This should serve as information source for planning which items should be produced in the actual month. Each management represents one production branch. new Management(data) Parameters: Name Type Description data object an object that stores the information needed to build this class. Properties Name Type Description scene Phaser.Scene the scene where the management building should be built in. See Phaser.Scene x Number the x coordinate where the building should be placed. y Number the y coordinate for the building. image String the image key of the building. name String the name of the building. items Array the items that should be described by the management. storage Storage the storage building, where the management should store produced items. player Player the player instance. branch Number the branch of the management. Source: Management.js, line 5 Extends Building Members branch :Number The Branch helps applying branch specific properties like duration and responsible workshops. There are two possible values for the branch: + `0` - The branch including `chairs` and `tables`. + `1` - The branch includin `beds` and `bookcases`. Type: Number Source: Management.js, line 75 buildingSprite :Phaser.GameObjects.Sprite The sprite that renders the building. See Phaser.GameObjects.Sprite. Type: Phaser.GameObjects.Sprite Inherited From: Building#buildingSprite Source: Building.js, line 53 emitter :EventDispatcher The Emitter is an instance of the EventDispatcher and is used to record the actions performed by the user. In the case of buildings, we always want to record which building has been opened by the player. Type: EventDispatcher Inherited From: Building#emitter Source: Building.js, line 84 image :Phaser.GameObjects.Sprite The image sprite of the building Type: Phaser.GameObjects.Sprite Inherited From: Building#image Source: Building.js, line 92 items :Array This is a list of items that should be managed in this building. This list corresponds to the branch of this management. Type: Array Source: Management.js, line 39 name :String The name of the Building. This is also the name that is displayed in the tooltip. Type: String Inherited From: Building#name Source: Building.js, line 41 player :Player The player. This is needed to add the profit and applying the costs. Type: Player Source: Management.js, line 63 scene :Phaser.Scene The Scene where the building should be rendered in. In this case this is usually the MainScene. Type: Phaser.Scene Inherited From: Building#scene Source: Building.js, line 61 See: Phaser.Scene sign A sign that can be placed beneath a building Inherited From: Building#sign Source: Building.js, line 46 storage :Storage This is the storage. If the option PRODUCE_PARTS is activated, this storage is called after the production is finished causing the produced part to be stored. Type: Storage Source: Management.js, line 56 tooltip :Phaser.GameObjects.Sprite This is the tooltip object that is triggered if the cursor is on the building. Type: Phaser.GameObjects.Sprite Inherited From: Building#tooltip Source: Building.js, line 68 tooltipText :Phaser.GameObjects.BitmapText The text that should be inside the tooltip. It contains the name of the building. Type: Phaser.GameObjects.BitmapText Inherited From: Building#tooltipText Source: Building.js, line 76 workshops :Array This is the list of workshops the management is responsible for. This list is used to schedule production processes. If something is produced, the management calls the workshops in this list. Type: Array Source: Management.js, line 48 Methods addClickListener(func) Adds a listener that reacts on a click on the object. This is used for triggering a dialogue if a specific building is clicked. The function to initiate the individual dialogue must be passed by the instance. Parameters: Name Type Description func function the function that should be triggered, after the object as been clicked. Inherited From: Building#addClickListener Source: Building.js, line 111 addFlashEffect() Add a flash effect to the building to highlight it for the tutorial. Inherited From: Building#addFlashEffect Source: Building.js, line 157 addPointerListeners() Adds pointer events to toggle the display of the tooltip if the pointer is hovering over a building. It will fade in the tooltip if the cursor is above and fade it out if the cursor leaves the building. Inherited From: Building#addPointerListeners Source: Building.js, line 129 canAfford(item) Checks if the player has the required resources and if the workshops have enough time to produce the requested item. Parameters: Name Type Description item Item the item that should be produced. Source: Management.js, line 213 Returns: if the item can be afforded it just returns `status: true`. If not, the status is set to `false` and the `reason` corresponds to the reason of why the item could not be produced. Type Object createDialogue() This function is used as the callback function of the clicklistener. If the building is clicked, a new ManagementDialogue will be launched. Source: Management.js, line 99 See: Building#addClickListener produce(item) Produces an item, by consuming its costs and invoking a process. Parameters: Name Type Description item Item The item that should be produced. Source: Management.js, line 120 See: Process Returns: an object holding true inside its status attribute if the item can be produced, else the dictionary status is false and it has an accessable reason. Example return if the item cannot be produced: {status: false, reason: 'not enough wood!'} These values come from the canAfford method. Type object sell() Sells an item in the given context and add its profit to the players money. After that, the produced item is added to the players statistics. Source: Management.js, line 158 stopFlashEffect() Stop the flash effect. Inherited From: Building#stopFlashEffect Source: Building.js, line 174 store() Stores the last produced part inside the storage. If the GameProperty AUTOMATIC_SELLING is activated, it invokes the combineAvailable function of storage, producting every item that can be afforded. Source: Management.js, line 197 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"ManagementDialogue.html":{"id":"ManagementDialogue.html","title":"Class: ManagementDialogue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: ManagementDialogue ManagementDialogue This is the Dialogue that appears if a Management Building has been clicked by the player. Its main task is to render a Panel, that informs about buildable Items, its costs and profits. To display the Items it initiaties an ItemPanel. If the options PRODUCE_PARTS and PRODUCE_IN_MANAGEMENT are active, the panel gets pushed to the left in order to display additional building opions. new ManagementDialogue() Source: ManagementDialogue.js, line 5 Extends DialogueScene Members clickSound :Phaser.Sound.BaseSound Adds the clicksound, which was loaded by the Preloader to the scene. The sound is added using phasers BaseSoundManager Type: Phaser.Sound.BaseSound Source: ManagementDialogue.js, line 36 data :object Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way the scene can be used more flexible. As an example: the WorkshopDialogue maintains an instance of the workshop, to read the status and schedule building orders. The workshop can be passed as an entry in this data object. Type: object Inherited From: DialogueScene#data Source: DialogueScene.js, line 59 emitter The EventDispatcher to monitor that a dialogue has been closed by the player Inherited From: DialogueScene#emitter Source: DialogueScene.js, line 65 errorSound :Phaser.Sound.BaseSound Adds the errorsound, which was loaded by the Preloader to the scene. The sound is added using phasers BaseSoundManager Type: Phaser.Sound.BaseSound Source: ManagementDialogue.js, line 43 height :number The height of the dialogue. Type: number Inherited From: DialogueScene#height Source: DialogueScene.js, line 45 itemPanel :ItemPanel The ItemPanel here organizes the items that should be displayed in this management. Type: ItemPanel Source: ManagementDialogue.js, line 70 mainScene :MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. Type: MainScene Inherited From: DialogueScene#mainScene Source: DialogueScene.js, line 39 management :Management A management instance, which is the management that has been clicked. This makes sure, that all actions taken in this scene affect the right management building. Type: Management Source: ManagementDialogue.js, line 57 panel :Panel The panel which renders the frame and the headline. Type: Panel Inherited From: DialogueScene#panel Source: DialogueScene.js, line 112 width :number The width of the dialogue. Type: number Inherited From: DialogueScene#width Source: DialogueScene.js, line 51 Methods close() This function creates a closing effect, animating the scale of the panel to zero within 150 milliseconds. This function also stops the scene that is calling the function and enables the inputs of the main scene. Inherited From: DialogueScene#close Source: DialogueScene.js, line 74 create() This function is always run after a scene is started. It creates the resources that are needed to display and handel the dialogue. Source: ManagementDialogue.js, line 26 createDialogue(header) Creates a panel that can be filled with content by every class inheriting from this class. Note that the panel initially has a scale of zero causing the object to be invisible. The function fadeIn can be used to make it appear. Alternatively the scale of the panel can be set to 1 manually. This function also disables every input for the main scene, which means that the player cannot open new buildings or navigate through the map as long as a dialogue is opened. The close function re-enables the inputs of the main scene. Parameters: Name Type Default Description header string Header the headline which will be displayed on top of the panel. Inherited From: DialogueScene#createDialogue Source: DialogueScene.js, line 103 fadeIn( [completeCallback]) This function is used to animate the appearance of the panel, by animating its scale to 100% within 150 milliseconds. Parameters: Name Type Argument Description completeCallback function &lt;optional&gt; a function that is executed once the animation has finished. Inherited From: DialogueScene#fadeIn Source: DialogueScene.js, line 128 init(data) The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. launch start). In this case the additional data is used to build a basic panel that can be adopted by every class that is extending this class. Parameters: Name Type Description data object the data object contains relevant data for this scene as well as additional data that can be used by the child scenes of this DialogueScene. See {@DialogueScene#data}. Properties Name Type Description mainScene MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. height number The height of the dialogue. width number The width of the dialogue. Inherited From: DialogueScene#init Source: DialogueScene.js, line 34 update() This function is called after every frame, updating the queue status of the workshop and the progressbars Source: ManagementDialogue.js, line 84 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Market.html":{"id":"Market.html","title":"Class: Market","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Market Market This class renders a market building with that can be used to compare the profits of the player with the optimal solution. new Market(data) Parameters: Name Type Description data object the object that is used to provide the required information. See Building for more information. Source: Market.js, line 3 Extends Building Members buildingSprite :Phaser.GameObjects.Sprite The sprite that renders the building. See Phaser.GameObjects.Sprite. Type: Phaser.GameObjects.Sprite Inherited From: Building#buildingSprite Source: Building.js, line 53 emitter :EventDispatcher The Emitter is an instance of the EventDispatcher and is used to record the actions performed by the user. In the case of buildings, we always want to record which building has been opened by the player. Type: EventDispatcher Inherited From: Building#emitter Source: Building.js, line 84 image :Phaser.GameObjects.Sprite The image sprite of the building Type: Phaser.GameObjects.Sprite Inherited From: Building#image Source: Building.js, line 92 lp The linear programming problem solution that is used to be compared to the player's performance. Source: Market.js, line 29 name :String The name of the Building. This is also the name that is displayed in the tooltip. Type: String Inherited From: Building#name Source: Building.js, line 41 player :Player The player instance to retrieve the profits. Type: Player Source: Market.js, line 24 scene :Phaser.Scene The Scene where the building should be rendered in. In this case this is usually the MainScene. Type: Phaser.Scene Inherited From: Building#scene Source: Building.js, line 61 See: Phaser.Scene sign A sign that can be placed beneath a building Inherited From: Building#sign Source: Building.js, line 46 tooltip :Phaser.GameObjects.Sprite This is the tooltip object that is triggered if the cursor is on the building. Type: Phaser.GameObjects.Sprite Inherited From: Building#tooltip Source: Building.js, line 68 tooltipText :Phaser.GameObjects.BitmapText The text that should be inside the tooltip. It contains the name of the building. Type: Phaser.GameObjects.BitmapText Inherited From: Building#tooltipText Source: Building.js, line 76 Methods addClickListener(func) Adds a listener that reacts on a click on the object. This is used for triggering a dialogue if a specific building is clicked. The function to initiate the individual dialogue must be passed by the instance. Parameters: Name Type Description func function the function that should be triggered, after the object as been clicked. Inherited From: Building#addClickListener Source: Building.js, line 111 addFlashEffect() Add a flash effect to the building to highlight it for the tutorial. Inherited From: Building#addFlashEffect Source: Building.js, line 157 addPointerListeners() Adds pointer events to toggle the display of the tooltip if the pointer is hovering over a building. It will fade in the tooltip if the cursor is above and fade it out if the cursor leaves the building. Inherited From: Building#addPointerListeners Source: Building.js, line 129 createDialogue() This function launches the market Dialogue scene where the information is actually rendered. Source: Market.js, line 40 See: MarketDialogue stopFlashEffect() Stop the flash effect. Inherited From: Building#stopFlashEffect Source: Building.js, line 174 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"MarketDialogue.html":{"id":"MarketDialogue.html","title":"Class: MarketDialogue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: MarketDialogue MarketDialogue The dialogue that is displayed after the player clicks on the market building. It renders a summary consisting of the player's profits and optimal values. new MarketDialogue() Source: MarketDialogue.js, line 5 See: Market ProfitSummary Extends DialogueScene Members data :object Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way the scene can be used more flexible. As an example: the WorkshopDialogue maintains an instance of the workshop, to read the status and schedule building orders. The workshop can be passed as an entry in this data object. Type: object Inherited From: DialogueScene#data Source: DialogueScene.js, line 59 emitter The EventDispatcher to monitor that a dialogue has been closed by the player Inherited From: DialogueScene#emitter Source: DialogueScene.js, line 65 height :number The height of the dialogue. Type: number Inherited From: DialogueScene#height Source: DialogueScene.js, line 45 mainScene :MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. Type: MainScene Inherited From: DialogueScene#mainScene Source: DialogueScene.js, line 39 panel :Panel The panel which renders the frame and the headline. Type: Panel Inherited From: DialogueScene#panel Source: DialogueScene.js, line 112 width :number The width of the dialogue. Type: number Inherited From: DialogueScene#width Source: DialogueScene.js, line 51 Methods close() This function creates a closing effect, animating the scale of the panel to zero within 150 milliseconds. This function also stops the scene that is calling the function and enables the inputs of the main scene. Inherited From: DialogueScene#close Source: DialogueScene.js, line 74 create() This function is responsible for rendering the ProfitSummary Source: MarketDialogue.js, line 24 createDialogue(header) Creates a panel that can be filled with content by every class inheriting from this class. Note that the panel initially has a scale of zero causing the object to be invisible. The function fadeIn can be used to make it appear. Alternatively the scale of the panel can be set to 1 manually. This function also disables every input for the main scene, which means that the player cannot open new buildings or navigate through the map as long as a dialogue is opened. The close function re-enables the inputs of the main scene. Parameters: Name Type Default Description header string Header the headline which will be displayed on top of the panel. Inherited From: DialogueScene#createDialogue Source: DialogueScene.js, line 103 fadeIn( [completeCallback]) This function is used to animate the appearance of the panel, by animating its scale to 100% within 150 milliseconds. Parameters: Name Type Argument Description completeCallback function &lt;optional&gt; a function that is executed once the animation has finished. Inherited From: DialogueScene#fadeIn Source: DialogueScene.js, line 128 init(data) The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. launch start). In this case the additional data is used to build a basic panel that can be adopted by every class that is extending this class. Parameters: Name Type Description data object the data object contains relevant data for this scene as well as additional data that can be used by the child scenes of this DialogueScene. See {@DialogueScene#data}. Properties Name Type Description mainScene MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. height number The height of the dialogue. width number The width of the dialogue. Inherited From: DialogueScene#init Source: DialogueScene.js, line 34 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"MessageDialogue.html":{"id":"MessageDialogue.html","title":"Class: MessageDialogue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: MessageDialogue MessageDialogue This class provides dialogue scene to get a user text input. In order to create this dialogue the values required by the DialogueScene must be provided on creation. Therefore, see DialogueScene#init. new MessageDialogue() Source: MessageDialogue.js, line 24 Example // go to the place, where the scene should be started and insert the following line this.scene.launch('textDialogue', {mainScene: this, title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION questionNumber: NUMBER}); // \"this\" must be a scene, because this.scene points at the scene manager of the specific scene. Members background :Phaser.GameObjects.Sprite The background sprite. It is a black, slightly transparent rectangle, that is used to darken the background. Type: Phaser.GameObjects.Sprite Source: MessageDialogue.js, line 42 See: Phaser.GameObjects.Sprite question :String The question that is displayed to the user above the input field, where the player can type in the answer. Type: String Source: MessageDialogue.js, line 61 title :String This is the title of the dialogue. Type: String Source: MessageDialogue.js, line 53 Methods create() Creates the dialogues and all related game objects that are required in this scene. This function runs automatically after the scene has been started. Source: MessageDialogue.js, line 34 renderQuestion() Displays the quesiton on the dialogue. Source: MessageDialogue.js, line 92 setQuestionFontSize(size) Adjust the size of the question text. Parameters: Name Type Description size number the desired fontsize for the question Source: MessageDialogue.js, line 103 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-Constants.html":{"id":"module-Constants.html","title":"Module: Constants","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: Constants This module contains settings concerning the games functionality. To change the behavior of the game, see module:GameProperties. Source: Constants.js, line 1 Members ACTION_MAP A Json file mapping the action keys to the fulltext action. Source: Constants.js, line 40 BED The values for a bed item. This variable stores the costs and profit of the bed. Source: Constants.js, line 94 BOOKCASE Values for the bookcase. It contains information about the costs and profits. Source: Constants.js, line 108 CHAIR The values for the chair item. These values consist of the costs of the item and the profit. Source: Constants.js, line 87 DIAGRAM_HEIGHT Define the height of the diagram inside the market dialogue. Source: Constants.js, line 124 DIAGRAM_WIDTH Define the width of the diagram inside the market dialogue. Source: Constants.js, line 116 HOURS_A The hours available for workshop A. Source: Constants.js, line 63 HOURS_B The hours available for workshop B. Source: Constants.js, line 69 HOURS_C The hours available in workshop C Source: Constants.js, line 75 HOURS_D The hours available in workshop D Source: Constants.js, line 81 METAL The metal available for the player. Source: Constants.js, line 57 MODEL Provide the path to the linear programming problem in cplex format. Source: Constants.js, line 19 ON_LOCAL_MACHINE Disables the SosciSurvey functions, to enable testing on local machines. If you want to run the project on SosciSurvey, in order to obtain data, this option must be set to 'false'. Source: Constants.js, line 31 SOLUTION The path to the optimal solution in JSON format. Source: Constants.js, line 25 TABLE The values for a table item. Stores information about the costs and profit of the table. Source: Constants.js, line 101 TEXTDIALOGUE_HEIGHT The height of the dialogue for text input. Source: Constants.js, line 138 TEXTDIALOGUE_WIDTH The Width of a Text input dialogue. This is used to ask questions to the player. Source: Constants.js, line 131 WOOD The available wood for every month. Source: Constants.js, line 51 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-FeedbackSummary.html":{"id":"module-FeedbackSummary.html","title":"Module: FeedbackSummary","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: FeedbackSummary Source: FeedbackSummary.js, line 1 Classes ProfitSummary Methods &lt;inner&gt; getAllOptimalProfits(the) Retrieves the optimal profit for every month and stores returns that list. Parameters: Name Type Description the object optimal solution that usually has been generated by the function loadSolution. Source: FeedbackSummary.js, line 332 &lt;inner&gt; getMonthOptimalProfit(the, month) Multiplies every item with its price at the given month and adds them up to generate an optimal profit for a month. Parameters: Name Type Description the Object linear problem solution to get the values from. month Number the actual month starting at zero. Source: FeedbackSummary.js, line 319 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-FeedbackSummary-ProfitSummary.html":{"id":"module-FeedbackSummary-ProfitSummary.html","title":"Class: ProfitSummary","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: ProfitSummary FeedbackSummary~ ProfitSummary This class is used to compare the profit of the player with the optimal solution. Therefore several text elements as well as a diagram and feedback are generated. It should be placed inside a Panel to ensure it is displayed properly. new ProfitSummary(data) Parameters: Name Type Description data object the object that contains values required to buld the summary of the profit: Properties Name Type Description scene Phaser.Scene the Phaser scene where the summary should be displayed. This is usually a MarketDialogue. x number the x coordinate for the object. y number the y coordinate for the object. player Player an instance of the player to retrieve the profits. month number the current month of the game. Source: FeedbackSummary.js, line 8 See: Phaser.GameObjects.Container Extends Phaser.GameObjects.Container × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-Game.html":{"id":"module-Game.html","title":"Module: Game","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: Game This module starts the game by applying the configuration of the game and launching the preloader scene. To run the game, this module has to be embedded in an html page, like shown in the example. After that the html document can be hosted on a webserver and launched, if the page is loaded. Source: Game.js, line 16 Example How to add the game to an HTML-document: &lt;html&gt; &lt;head&gt; &lt;script type=\"module\" src=\"Game.js\"&gt;&lt;/script&gt; &lt;!-- loads the game into the web page --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- inside this div the game is rendered. Hence, the id must match the parent field inside the config object. --&gt; &lt;div id=\"can\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Members &lt;inner, constant&gt; config The configuration that defines how the game is started. Properties: Name Type Description type number defines if WebGL should be used. The AUTO setting detects if the browser is capable of WebGL and runs it, if possible. See AUTO width number the width of the game canvas. height number the height of the game canvas. backgroundColor string the standard background color of the canvas. pixelArt boolean automatically applies a linear filter to the game to prevent blurry scaling effects. See pixelArt parent string the canvas where the game should be rendered. It can be the id of an HTML div as shown in the example above. physics object sets the physics for the game. These values are not critical in this context. scene array in this field all scenes are stored. As the game runs, all scenes are initialized and the key of the scenes gets stored inside the global SceneManager. The first element in this list is the Preloader scene that loads all required assets for the game. Source: Game.js, line 52 &lt;inner&gt; game The game instance. We do not need to do much with it since the constructor takes care of starting the game. Source: Game.js, line 71 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-GameProperties.html":{"id":"module-GameProperties.html","title":"Module: GameProperties","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: GameProperties This module specifies changes in the behavior of the game. Source: GameProperties.js, line 1 Members &lt;static, constant&gt; ENABLE_MARKET Specify whether a market building should be created, where the player can compare the own performance with the optimal solution. Source: GameProperties.js, line 43 &lt;static, constant&gt; WARNINGS_AT_SKIP Set this to true to display Warnings if the player wants to skip a month without having produced something or with active workshops. Source: GameProperties.js, line 51 AUTOMATIC_SELLING Decide if items should be sold automatically if all the required material is available (true) or if the player has to combine the parts to items inside the storage (false). This Property only has an effect, if PRODUCE_PARTS is set to 'true'. Source: GameProperties.js, line 70 DISPLAY_FEEDBACK Shows a feedback text inside the market. depending on the distance of the profit towards the optimal profit. Source: GameProperties.js, line 164 DISPLAY_OPTIMAL_SOLUTION Specify when the optimal solution should be displayed. possible values: 'always' : The optimal solution is displayed every month on the summary page. 'end' : Displays the optimal solution in the end of the last month. 'never' : The player gets never informed about the optimal solution. Uncomment the statement that you want to use. export const DISPLAY_OPTIMAL_SOLUTION = 'always'; export const DISPLAY_OPTIMAL_SOLUTION = 'end'; export const DISPLAY_OPTIMAL_SOLUTION = 'never'; Source: GameProperties.js, line 172 FEEDBACK_GOOD The Text for a good solution Source: GameProperties.js, line 247 FEEDBACK_LOW The feedback text for a low profit, compared to the optimal solution Source: GameProperties.js, line 262 FEEDBACK_PERFECT The text to be displayed if the user has achieved the optimal solution in terms of profit for one month Source: GameProperties.js, line 224 FEEDBACK_VERY_GOOD The text for a very good solution Source: GameProperties.js, line 232 ITEM_NAME_BED Set the name for the bed Source: GameProperties.js, line 109 ITEM_NAME_BOOKCASE Set the name for the bookcase Source: GameProperties.js, line 114 ITEM_NAME_CHAIR Set the name for the chair Source: GameProperties.js, line 99 ITEM_NAME_TABLE Set the name for the table Source: GameProperties.js, line 104 MINIMUM_TEXT_SIZE The minimum text length, the user needs to provide in order to answer the question. Source: GameProperties.js, line 361 MONTH_SECONDS Specify how many seconds a month should have. Source: GameProperties.js, line 21 MONTHLY_PAUSE If set to true, the player gets a summary after a month is done. The time of the next month starts if the player closes the summary. Source: GameProperties.js, line 208 MONTHLY_RESET Reset working workshops and - if PRODUCE_PARTS is true - the available part on month change to prevent workshops carry the work over to the next month. Source: GameProperties.js, line 92 MONTHS Specify how many months the simulation should last Source: GameProperties.js, line 6 PART_NAME_BED_FRAME Set the name for the bedframe Source: GameProperties.js, line 142 PART_NAME_BED_TOP Set the name for the bed-top Source: GameProperties.js, line 147 PART_NAME_BOOKCASE_LEG Set the name for the bookcase leg Source: GameProperties.js, line 152 PART_NAME_BOOKCASE_TOP Set the name for the bookcase top Source: GameProperties.js, line 157 PART_NAME_CHAIR_ Set the name for the chair leg Source: GameProperties.js, line 120 PART_NAME_CHAIR_BACK Set the name for the chair back Source: GameProperties.js, line 126 PART_NAME_TABLE_LEG Set the name for the table leg Source: GameProperties.js, line 132 PART_NAME_TABLE_TOP Set the name for the table top Source: GameProperties.js, line 137 PERCENTAGE_GOOD Specify at which percentage of the score depending on the optimal solution the player should recieve a 'good' message. Everything below that value will trigger the 'low' feedback, values above the 'PRECENTAGE_VERY_GOOD' will trigger the 'very good' message. Source: GameProperties.js, line 252 PERCENTAGE_VERY_GOOD Specify what proportion of the own solution regarding the optimal solution will count as 'very good' if set to 0.9, everything from 90% of the optimal solution and above will count as 'very good', until 1 is reached, which will trigger the perfect feedback. Source: GameProperties.js, line 237 PRODUCE_IN_MANAGEMENT Specify if the itemparts should be produced inside the management. If this value is set to false, the player has to open the corresponding workshop in order to produce the parts. Source: GameProperties.js, line 81 PRODUCE_ONE_CLICK Define if the required amount of parts is queued with one click. If set to false, one click will initiate the production of just one item. If set to true, one click will produce the required amount of the item Source: GameProperties.js, line 53 PRODUCE_PARTS Decide wheter the player has to build the parts of the furniture or if he/she just needs one click in order to produce an item. true - the parts need to be produced individually false - the piece of furniture will be produced with one click, without splitting it into its components Source: GameProperties.js, line 28 PRODUCTION_TIME_SCALING This value defines how the production time should be scaled. If the value is 1, one working hour corresponds to one second, a value of 2 - two seconds etc. Source: GameProperties.js, line 62 SHOW_DIAGRAM Define if the diagram should be displayed. Source: GameProperties.js, line 217 SHOW_SOLUTION_ASPECTS Specify what is displayed if an optimal solution is shown. Possible values: 'all': displays the profit and each produced product. 'profit': only displays the profit. 'products': only displays the products that need to be produced to achieve the optimal profit. NOTE: if DISPLAY_OPTIMAL_SOLUTION is set to 'never', none of these values are displayed. uncomment the statement that you want to use. export const SHOW_SOLUTION_ASPECTS = 'all'; export const SHOW_SOLUTION_ASPECTS = 'profit'; export const SHOW_SOLUTION_ASPECTS = 'products'; Source: GameProperties.js, line 189 SOCI_BEDS Specify the name of the variable for produced Beds Source: GameProperties.js, line 304 SOCI_BOOKCASES Specify the name of the variable for produced Bookcases Source: GameProperties.js, line 310 SOCI_CHAIRS Specify the name of the variable for produced Chairs Source: GameProperties.js, line 322 SOCI_MODEL_VAR Specify the variable name of the Model section Source: GameProperties.js, line 284 SOCI_PLAYER_TIME_VAR Specify the variable name of the Player Time Source: GameProperties.js, line 291 SOCI_PLAYER_VAR Specify the variable name of the Player section Source: GameProperties.js, line 278 SOCI_PROFIT Specify the variable name for player profit Source: GameProperties.js, line 298 SOCI_TABLES Specify the name of the variable for produced Tables Source: GameProperties.js, line 316 SOCI_WAS_PRODUCING The variable that should indicated if the player had producing workshops as the month has changed Source: GameProperties.js, line 328 SOSCI_ANSWER The variable that represents the free-text answers of the user. Source: GameProperties.js, line 336 SOSCI_ASSESSMENT The variable represents the assessment answers of the user. Source: GameProperties.js, line 342 SOUND_VOLUME Set the volume of the game sound effect. This value can be between 0 and 1. Source: GameProperties.js, line 13 &lt;inner&gt; module:GameProperties_SOSCI_FEEDBACK The feeback that the player gives to mike Source: GameProperties.js, line 349 &lt;inner&gt; module:GameProperties_SOSCI_LOG The variable where the log is saved Source: GameProperties.js, line 355 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-glpkUtility.html":{"id":"module-glpkUtility.html","title":"Module: glpkUtility","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: glpkUtility This module is used to parse linear problems and its solution. It also provides tools to solve linear problems. In this case the glpk.js file must be loaded before the game inside the website. Source: glpkUtility.js, line 3 See: glpk.js Methods &lt;static&gt; parseLP() This function reads a linear problem and extracts the relevant data to run the game. It contains the value for every month for every item, available resources, and costs. The structure of the linear problem object is the following: Properties: Name Type Description workshopAAvailable number available hours in workshop A. workshopBAvailable number available hours in workshop B. workshopCAvailable number available hours in workshop C. workshopDAvailable number available hours in workshop D. metalAvailable array available metal for every month. woodAvailable array available wood for every month. items object information about the available items of the game. The keys are the names of the different items 'bed', 'bookcase', 'chair', and 'table'. Each of these keys yields another object with the fields: Properties Name Type Description profit array the profit of the item for every month. costs object the costs of the specific item. See costs Source: glpkUtility.js, line 123 &lt;static&gt; readTextFile(file, callback) Read a textfile and process it with a callback function. Parameters: Name Type Description file String the path to the file containing the linear problem callback function a function that should be executed, if the file has been read. A callback function usually writes the contents inside a variable as seen in getLP. Source: glpkUtility.js, line 12 &lt;inner&gt; convertResult(lp) Converts the result of the lp to enable the reading of the optimal solution and the amount of built items for every month. Parameters: Name Type Description lp * Source: glpkUtility.js, line 248 &lt;inner&gt; cplex(file) Solves the linear problem and converts the result. Taken from https://github.com/hgourvest/glpk.js/blob/master/test/test.js and modified. Parameters: Name Type Description file * a file in cplex format. Author: Henri Gourvest License: GNU General Public License v2.0 Source: glpkUtility.js, line 61 Returns: the results that are converted by convertResult. Type string &lt;inner&gt; getLP() Reads a text file and returns a linear Problem as string. It reads the model that is specified under MODEL. Source: glpkUtility.js, line 83 &lt;inner&gt; loadSolution() This function loads a solution from file specified by the SOLUTION field. Source: glpkUtility.js, line 107 Returns: the solution of the linear problem. Type object &lt;inner&gt; readCplexFromFile(lp, filename) Reads a linear problem from a file. Taken from https://github.com/hgourvest/glpk.js/blob/master/test/test.js and modified. Parameters: Name Type Description lp object the linear problem filename string the name of the Author: Henri Gourvest License: GNU General Public License v2.0 Source: glpkUtility.js, line 39 &lt;inner&gt; solveLP() This function loads the underlying linear problem and uses the cplex function to solve it. Source: glpkUtility.js, line 97 Returns: the solution of the linear problem. Type object × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-Item.html":{"id":"module-Item.html","title":"Module: Item","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: Item Source: Item.js, line 1 Classes Item Methods &lt;static&gt; getScaling(code) This function is used to get the proper scaling for each item. This is necessary because the images of the items have different sizes. By using this function, the images are scaled to the same size. Parameters: Name Type Description code string the image code for which the scaling should be retreived. Source: Item.js, line 92 Returns: the scaling of the requested image, that can be used for the setScale function on a sprite. Type number &lt;static&gt; scalePartsCosts(itemPart) This function calculates the costs of producing a given itemPart so many times until its quantity is sufficient to create an item. Parameters: Name Type Description itemPart object an item part with the structure described in parts. Source: Item.js, line 119 Returns: the new total costs, scaled by its demand value. Type number × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-ItemPriceTable.html":{"id":"module-ItemPriceTable.html","title":"Module: ItemPriceTable","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: ItemPriceTable Source: ItemPriceTable.js, line 2 Classes ItemPriceTable Methods &lt;inner&gt; createArrow(scene, oldPrice, newPrice, x, y) Decides which arrow should be displayed and where the arrow should be displayed. If oldPrice is higher than newPrice, the arrow will be red and downwards, vice versa the arrow will be green and upwards. If they are the same, a whit line will indicate that no change has happened. Parameters: Name Type Description scene * the scene, to render the symbols oldPrice * the old price for example the price of an item one month before. newPrice * the new price to be compared to the old price. x * the x position where the arrow should be rendered. y * the y position where the arrow should be rendered. Source: ItemPriceTable.js, line 18 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-ItemPriceTable-ItemPriceTable.html":{"id":"module-ItemPriceTable-ItemPriceTable.html","title":"Class: ItemPriceTable","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: ItemPriceTable ItemPriceTable~ ItemPriceTable This class informs the player about the price changes in the new month, by animating a table with the pictures of the items, their old prices and new prices. Additionally, arrows will indicate the movement of the price changes. new ItemPriceTable(data) Parameters: Name Type Description data object the data that is used to create the price table. Properties Name Type Description scene Phaser.Scene the scene where this table is rendered. x number the x position where the table is rendered. y number the y position where the table is rendered. pricesOld Array.&lt;number&gt; the old prices of the items. The first element is the old price of chair, followed by table, bed and bookcase. pricesOld Array.&lt;number&gt; the new prices of the items. The first element is the old price of chair, followed by table, bed and bookcase. Source: ItemPriceTable.js, line 29 Methods run() This function animates the price table to appear at the right side, stay for 4 seconds and slide out of the screen. Source: ItemPriceTable.js, line 102 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-Item-Item.html":{"id":"module-Item-Item.html","title":"Class: Item","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Item Item~ Item This class implements an item, that can be built by workshops. new Item(data) Parameters: Name Type Description data object the data object contains the values the class needs to be created. Properties Name Type Argument Description name string name of the item, that will be displayed to the player. costs object the costs of the item (see costs). profit array an array holding the price of the item for every month. image Phaser.GameObjects.Sprite &lt;optional&gt; an image object of the item. This can be added to the item if an already scaled image is present. branch number a number that is 0 or 1. This value is used to define to which branch the item belongs. Depending on the branch different workshops are assigned to the item. imageCode string the image code that is used to display the image of the item. parts array the parts the item consists of. This is necessary, if the option PRODUCE_PARTS is activated. see parts. Source: Item.js, line 5 Members branch :number The branch of the item, that defines which workshops are associated to the item. A 0 stands for the first branch (Workshop A and B) and 1 stands for the second branch (Workshop C and D). Type: number Source: Item.js, line 69 costs :object The costs of the item. It consists of several parts: Type: object Properties: Name Type Description wood number the costs of wood metal number the costs of metal hoursA number the time needed in workshop A hoursB number the time needed in workshop B hoursC number the time needed in workshop C hoursD number the time needed in workshop D Source: Item.js, line 48 image :Phaser.GameObjects.Sprite The Image object of the item. It can be set if there is already an image to show. Otherwise the image can created using the imageCode. Type: Phaser.GameObjects.Sprite Source: Item.js, line 62 See: Phaser.GameObjects.Sprite imageCode The image code for the item. This is a string that maches the string given by the corresponding load function of the Preloader. Source: Item.js, line 76 See: Phaser.Loader.LoaderPlugin name :string The name of the item that is displayed to the player. Type: string Source: Item.js, line 34 parts The parts define what needs to be built if the item should be created. A parts is a list containing two part object. A parts object is defined as follows: Properties: Name Type Description name string the name of the part that will be displayed. imageCode string the string defining the key of the image that should be shown. demand number defines which quantity of this part is required to build an item. costs object defines how much a part costs. The structure is the same as the costs of an item. Source: Item.js, line 86 profit :Array The profit this item yields for every month. Type: Array Source: Item.js, line 54 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-ProfitSummary.html":{"id":"module-ProfitSummary.html","title":"Module: ProfitSummary","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: ProfitSummary Source: ProfitSummary.js, line 1 Classes ProfitSummary Methods &lt;inner&gt; getAllOptimalProfits(the) Retrieves the optimal profit for every month and stores returns that list. Parameters: Name Type Description the object optimal solution that usually has been generated by the function loadSolution. Source: ProfitSummary.js, line 399 &lt;inner&gt; getMonthOptimalProfit(the, month) Multiplies every item with its price at the given month and adds them up to generate an optimal profit for a month. Parameters: Name Type Description the Object linear problem solution to get the values from. month Number the actual month starting at zero. Source: ProfitSummary.js, line 386 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-ProfitSummary-ProfitSummary.html":{"id":"module-ProfitSummary-ProfitSummary.html","title":"Class: ProfitSummary","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: ProfitSummary ProfitSummary~ ProfitSummary This class is used to compare the profit of the player with the optimal solution. Therefore several text elements as well as a diagram and feedback are generated. It should be placed inside a Panel to ensure it is displayed properly. new ProfitSummary(data) Parameters: Name Type Description data object the object that contains values required to buld the summary of the profit: Properties Name Type Description scene Phaser.Scene the Phaser scene where the summary should be displayed. This is usually a MarketDialogue. x number the x coordinate for the object. y number the y coordinate for the object. player Player an instance of the player to retrieve the profits. month number the current month of the game. Source: ProfitSummary.js, line 8 See: Phaser.GameObjects.Container Extends Phaser.GameObjects.Container Members feedbackFrame :Phaser.GameObjects.Sprite The frame around the feedback section. Type: Phaser.GameObjects.Sprite Source: ProfitSummary.js, line 167 See: The Phaser Documentation feedbackText :Phaser.GameObjects.BitmapText The textfield that displays the feedback. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 160 See: BitmapText linearProfitText :Phaser.GameObjects.BitmapText The display of the optimal solution. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 103 See: BitmapText lpSolution The solution of the linear problem. This is used to display the optimal solution. Properties: Name Type Description numberOfBeds list the number of beds built to work optimal for every month. numberOfBookCases list the number of bookcases built every month. numberOfChairs list the number of chairs built to work optimal for every month. numberOfTables list the number of tables built to work optimal for every month. objective number the total optimal profit for the year. Source: ProfitSummary.js, line 67 medal :Phaser.GameObjects.Sprite The Graphic that is displaying the medal, the player sees as feedback. Type: Phaser.GameObjects.Sprite Source: ProfitSummary.js, line 153 See: The Phaser Documentation month :number The month from which the results should be displayed. In this case the last month is used to display the recent profit. Type: number Source: ProfitSummary.js, line 82 optimalBeds :Phaser.GameObjects.BitmapText The text placeholder that displays the number of optimal beds. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 110 See: BitmapText optimalBookcases :Phaser.GameObjects.BitmapText The text placeholder that displays the number of optimal bookcases. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 117 See: BitmapText optimalChairs :Phaser.GameObjects.BitmapText The text placeholder that displays the number of optimal chairs. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 131 See: BitmapText optimalTables :Phaser.GameObjects.BitmapText The text placeholder that displays the number of optimal tables. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 124 See: BitmapText optimalText :Phaser.GameObjects.BitmapText The text element for the headline of the optimal solution. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 138 See: BitmapText ownProfitText :Phaser.GameObjects.BitmapText A text field that displays the player's profit of the given month. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 202 See: BitmapText ownProfitText Sets the textfield to display the given profit. Source: ProfitSummary.js, line 274 player :Player The player instance. This is used to retrieve the profit of the player. Type: Player Source: ProfitSummary.js, line 90 possibleOptimum :Phaser.GameObjects.BitmapText The headline for the possible optimal number of furniture built. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 145 See: BitmapText producedBeds :Phaser.GameObjects.BitmapText The text element that displays the produced beds by the player. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 174 See: BitmapText producedBeds Sets the textfield for the player's produced beds to the given value with a preceeding name. Source: ProfitSummary.js, line 238 producedBookcases :Phaser.GameObjects.BitmapText The text element that displays the produced bookcases by the player. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 181 See: BitmapText producedBookcases Sets the textfield for the player's produced bookcases to the given value with a preceeding name. Source: ProfitSummary.js, line 247 producedChairs :Phaser.GameObjects.BitmapText The text element that displays the produced chairs by the player. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 195 See: BitmapText producedChairs Sets the textfield for the player's produced chairs to the given value with a preceeding name. Source: ProfitSummary.js, line 265 producedTables :Phaser.GameObjects.BitmapText The text element that displays the produced tables by the player. Type: Phaser.GameObjects.BitmapText Source: ProfitSummary.js, line 188 See: BitmapText producedTables Sets the textfield for the player's produced tables to the given value with a preceeding name. Source: ProfitSummary.js, line 256 scene :Phaser.Scene This is the scene that defines where this object is rendered. Type: Phaser.Scene Source: ProfitSummary.js, line 74 Methods addDiagram() Adds a diagram object to bottom of the Dialogue. Source: ProfitSummary.js, line 281 makeFeedback(isFinal) Initiates the feedback towards the player. The threshold values can be defined in GameProperties. Parameters: Name Type Default Description isFinal bool false defines if this is the feedback for the final solution at the end of the year. Source: ProfitSummary.js, line 300 Returns: nothing, but the objects inside this dialogue responsible for the feedback (medal, feedbackText and feedbackFrame) are made visible and filled with the feedback. setFinalValues() This method is used for the summary after the whole year. instead of drawing just the profit of the last month, all values are summed up. Source: ProfitSummary.js, line 343 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"module-SosciWriter.html":{"id":"module-SosciWriter.html","title":"Module: SosciWriter","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Module: SosciWriter This module provides function that are used to write variables to SosciSurvey. Source: SosciWriter.js, line 3 Methods &lt;static&gt; disableNextButton() Disables the 'next' button. Source: SosciWriter.js, line 166 &lt;static&gt; submit() Submits the recorded values to SosciSurvey. Source: SosciWriter.js, line 173 &lt;static&gt; writeAnswer(questionNumber, answer) This function is used to write the answers of a user to the corresponding SosciSurvey variable. The Variable specified at SOSCI_ANSWER is used as the variable where the answers are stored. To assign the answers, question numbers are used, corresponding to the items at SosciSurvey. Parameters: Name Type Description questionNumber number the question number to specify to which item the user's text should be written. answer String the answer of the user. Source: SosciWriter.js, line 30 &lt;static&gt; writeAssessment(assessmentNumber, option, answer, mike) Writes the assessment value to soscisurvey question. The assesment number stands for a question. The likert-scaled answer of the player will be represented by item 01 and the freetext answer will be represented as item 02. Thus an assessment answer has always 2 items. In sosci survey it can look like: AS01_01 for the likert answer of the first assessment question and AS01_02 for the freetext answer of the same assessment dialogue accordingly. Parameters: Name Type Description assessmentNumber number the number of the assesment question at soscisurvey. option number the likert answer of the user. answer string the fee-text answer of the user. mike boolean defines whether this answer is the own assessment or feedback to mike (thus, comes from an AiDialogue) Source: SosciWriter.js, line 47 &lt;static&gt; writeLog(log) Write the final log to the corresponding SoSci Variable. Parameters: Name Type Description log string the log string containing the actions of the Player. Source: SosciWriter.js, line 155 See: EventDispatcher &lt;static&gt; writeProducedItems(target, month, items) Write the number of produced item for a given month to the corresponding SosciSurvey variable. EXAMPLE: writeProducedItems('player', 0, { beds: 1, bookcases: 30, tables: 20, chairs: 15 }); Writes the given amount of items to the player variable for the month january. Parameters: Name Type Description target string Could be 'player' or 'model' and defines, if the value should be written to a player or to a model variable. month int the number of the month starting from 0. items Object an object containing the item numbers. Must contain the keys 'beds', 'bookcases', 'tables', 'chairs'. Source: SosciWriter.js, line 95 &lt;static&gt; writeProducingStatus(month, status) Write the production status to SosciSurvey. This is helpful to get an idea if the player has been interrupted during the change of a month, which could serve as an indication that the available time per month should be adjusted. Parameters: Name Type Description month int the number of the month starting from 0. status boolean set true, if the player was producing during the month change, false if not. Source: SosciWriter.js, line 72 &lt;static&gt; writeTime(month, time) Writes the elapsed time to the corresponding SosciSurvey variable. Parameters: Name Type Description month int the month to specify the Sosci variable time int the elapsed time to store in milliseconds Source: SosciWriter.js, line 112 &lt;inner&gt; getTarget(target) Get the variable name of a Sosci Survey variable given the intuitive name. Parameters: Name Type Description target sting the target that should be converted to the SosciSurvey variable. Could be 'player' or 'model'. Source: SosciWriter.js, line 142 &lt;inner&gt; getVariable(varName, varNumber) Returns a DOM object of the given variable. EXAMPLE: getVariable('PL01',1) returns the intern SosciSurvey variable 'PL01_01' Parameters: Name Type Description varName string The name of the intern variable. Must be the same as in SosciSurvey. varNumber int The number of the item inside the intern variable. Source: SosciWriter.js, line 133 &lt;inner&gt; writeProfit(target, month, profit) Write the Profit into the corresponding intern variable. Parameters: Name Type Description target string the target. Could be 'player' or 'model' and specifies if the profit should be added to the player or to the model. month int the number of the month starting from 0. profit int the profit of the model or player for the given month. Source: SosciWriter.js, line 16 &lt;inner&gt; writeValue(variable, value) Write a value to a given SosciSurvey variable Parameters: Name Type Description variable object a dom object obtained by getVariable(). value * the value that should be written inside the given variable. Source: SosciWriter.js, line 122 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"NewsScene.html":{"id":"NewsScene.html","title":"Class: NewsScene","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: NewsScene NewsScene This Class servs as a summary of the last month while providing information about the coming month. After closing this dialogue, the new month will start. new NewsScene() Source: NewsScene.js, line 15 Members background :Phaser.GameObjects.Sprite The background sprite. It is a black, slightly transparent rectangle, that is used to darken the background. Type: Phaser.GameObjects.Sprite Source: NewsScene.js, line 33 See: Phaser.GameObjects.Sprite priceTable :ItemPriceTable The price table that is used to display the price changes on the newspaper. Type: ItemPriceTable Source: NewsScene.js, line 88 Methods addButtonSection() Adds the button to continue with the next month. Source: NewsScene.js, line 107 addDiagram() Add the diagram to the dialogue Source: NewsScene.js, line 150 create() Create all the gameObjects necessary to create the scene. Source: NewsScene.js, line 25 displayNewResouces() Display the new resources available in the next month. Source: NewsScene.js, line 134 displayPriceChanges() This function displays the price changes on the newspaper. It just creates a new PriceTable object and changes it to fit inside the newspaper displayed in this scene. Source: NewsScene.js, line 74 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Panel.html":{"id":"Panel.html","title":"Class: Panel","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Panel Panel This class implements a basic panel that acts as a frame for every dialogue. It is use by the DialogueScene which gives the functionality to its child classes. These classes then add their elements to this panel, which ensures that all the elements are located relatively to the panel. new Panel(data) Parameters: Name Type Description data object the data that is used by the constructor to create the panel. Properties Name Type Description scene Phaser.Scene the scene where the panel should be placed. See Phaser.Scene x Number the x coordinate where the panel should be displayed. y Number the y coordinate for the panel. width Number the width of the panel. header String defines the headline of the dialogue. Source: Panel.js, line 18 Members buttonRound :Phaser.GameObjects.Sprite This is a round button that can be used to close the panel. Type: Phaser.GameObjects.Sprite Source: Panel.js, line 54 See: Phaser.GameObjects.Sprite contents :Phaser.GameObjects.Sprite The contents sprite is on top of the panel and looks like paper. Type: Phaser.GameObjects.Sprite Source: Panel.js, line 68 See: Phaser.GameObjects.Sprite cross :Phaser.GameObjects.Sprite The cross is inside the buttonRound and helps the button to look like a typical close button. Type: Phaser.GameObjects.Sprite Source: Panel.js, line 61 See: Phaser.GameObjects.Sprite headerSize Adjust the font size of the header Source: Panel.js, line 90 headerText :Phaser.GameObjects.BitmapText The text container that displays the headline on top of the dialogue panel. Type: Phaser.GameObjects.BitmapText Source: Panel.js, line 83 See: BitmapText panel :Phaser.GameObjects.Sprite This is the main frame of the panel, realized as a brown window. This is later be filled by a contents object, acting as a paper on top of the brown frame. Type: Phaser.GameObjects.Sprite Source: Panel.js, line 47 See: Phaser.GameObjects.Sprite scale :number The scale of the panel. This value is used to animate its appearance. Initially the scale is 0 hence, the panel is not visible. With the fadeIn function the value is used to create an opening animation. Type: number Source: Panel.js, line 76 Methods disableCloseButton() Hides the close button to prevent the player from closing the panel. Source: Panel.js, line 98 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"PartDisplay.html":{"id":"PartDisplay.html","title":"Class: PartDisplay","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: PartDisplay PartDisplay This class displays the parts of an item and has buttons to initiate its production. new PartDisplay(data) Parameters: Name Type Description data object the object that contains the values required to build the part display. Properties Name Type Description scene Phaser.Scene A phaser scene that defines where the Display is rendered. x number the x coordinate for the object. y number the y coordinate for the object. item Item the item. This item provides the parts that will be displayed inside the part display. Source: PartDisplay.js, line 5 See: Phaser.GameObjects.Container Extends Phaser.GameObjects.Container Members active :boolean Defines if the display is currently active, which means that it is visible. Type: boolean Source: PartDisplay.js, line 119 active The setter for the activity status of this display. If it is set to true, it will animate its appearance. If set to false it will deactivate itself with an anmation. Source: PartDisplay.js, line 162 active Requests the active value. Source: PartDisplay.js, line 196 buttonOne :Button The button for the first item. If it is clicked, the first part will be produced. This button is created if PRODUCE_IN_MANAGEMENT is set to `true`. Type: Button Source: PartDisplay.js, line 214 buttonTwo :Button This is the second button, representing the second part of the item. Type: Button Source: PartDisplay.js, line 244 costsOne The costs of the first part of the item. It is used to display the costs of the part in the user interface. If the option PRODUCE_ONE_CLICK is activated, the costs are scaled to represent the total costs of producing the amount of parts to built the final item. As an example: If the part costs 1 metal but the part is required 4 time to produce the item, its costs will be displayed as 4 metal. Properties: Name Type Description wood number the costs of wood metal number the costs of metal hoursA number the time needed in workshop A hoursB number the time needed in workshop B hoursC number the time needed in workshop C hoursD number the time needed in workshop D Source: PartDisplay.js, line 96 costsTwo The same as for costsOne but for the second item. Source: PartDisplay.js, line 100 item :Item This is the item that should be produced. From this property the parts are read and displayed. Type: Item Source: PartDisplay.js, line 108 scene :Phaser.Scene This is the scene that defines where this object is rendered. Type: Phaser.Scene Source: PartDisplay.js, line 79 Methods callbackFunction() This function will be delivered to the two buttons that are created in this class. It initiates the building process of the part after checking if it can be produced. Source: PartDisplay.js, line 128 See: Button createProduceButtons() This function creates two buttons to produce the parts. It is only invoked, if PRODUCE_IN_MANAGEMENT is set to `true` is true. Source: PartDisplay.js, line 205 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Player.html":{"id":"Player.html","title":"Class: Player","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Player Player This class implements the data of the player. It also keeps track of the profit, available material and produced items. new Player(data) Parameters: Name Type Description data Object a data object containing the required information. Properties Name Type Description scene Phaser.Scene the scene the player belongs to. This is usually the MainScene. availableWood Array.&lt;number&gt; the wood the player has availlable each month. availableMetal Array.&lt;number&gt; the metal the player has availlable each month. Source: Player.js, line 13 Members availableMetal The available metal the player has at each month. Source: Player.js, line 41 availableWood The available wood of the player for each month Source: Player.js, line 35 Example player.availableWood[3]; // --&gt; Gives the wood available in the fourth month. initialMetal The initial metal the player has at the beginning of a given month. Source: Player.js, line 54 initialWood The initial wood. This value will not be changed. This helps to look up what the player has at the beginning of a given month. Source: Player.js, line 48 money The money the player has throughout the game. Source: Player.js, line 21 monthlyProfit This field keeps track of the profit that is made each month. Source: Player.js, line 27 producedItems The items that the player has produced each month. Properties: Name Type Description chairs Array.&lt;number&gt; The number of chairs built throughout the year. tables Array.&lt;number&gt; The number of tables for each month. beds Array.&lt;number&gt; The number of beds. bookcases Array.&lt;number&gt; The number of bookcases for each month. Source: Player.js, line 63 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Preloader.html":{"id":"Preloader.html","title":"Class: Preloader","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Preloader Preloader This class is used to load all resources of the game while showing a loading screeen. new Preloader() Source: Preloader.js, line 8 Methods create() This function is called after all resources have been loaded. It closes this scene while starting the MainScene, which takes care of the game itself. Source: Preloader.js, line 173 init() This function is called to hide the next button on soscisurvey. Source: Preloader.js, line 27 preload() In this function all resources should be loaded to make sure it happens once before the game starts. This increases performance. Source: Preloader.js, line 39 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Process.html":{"id":"Process.html","title":"Class: Process","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Process Process This class implements a process that organizes the production of an item. It distributes the work over the workshops and handels their status using callbacks. If ever workshop has finished the work it signals to the Management that the process is done. new Process(data) Parameters: Name Type Description data object the data that is passed to start a process. Properties Name Type Description management Management the management building that starts the process. item module:Item~Item the item that is to be produced. Source: Process.js, line 1 See: Phaser.Events.EventEmitter Extends Phaser.Events.EventEmitter Members item :module:Item~Item The item that is produced in this process. Type: module:Item~Item Source: Process.js, line 40 management :Management The associated management building that starts the process. This management instance listens to the progress of this process class. Type: Management Source: Process.js, line 27 stillWorking :number The number of workshops that are still working. This value gets decremented if a workshop has finised its work. If all workshops have finished their work, the product is done. Type: number Source: Process.js, line 47 workshops :Array.&lt;Workshop&gt; The workshops that will be involved in this production process. During production these workshops will be instructed to build the item that is produced in this process. Type: Array.&lt;Workshop&gt; Source: Process.js, line 34 Methods handelFinished() If a workshop is finished, the stillWorking value is decremented by 1. If all the workshops are done, emit the event that the process is done to the Management. Source: Process.js, line 81 start() Starts the production of the item. This method calls every involved workshop in workshops and listens if they're finished. If a workshop has finished, the function handelFinished is called. Source: Process.js, line 56 Returns: return an object with a status that is true if everything is done. Type object × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"ProgressBar.html":{"id":"ProgressBar.html","title":"Class: ProgressBar","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: ProgressBar ProgressBar This class implements an horizontal progress bar that can be used to show item usage or time left. new ProgressBar(data) Parameters: Name Type Description data object the data which is required to represent a progressbar. Properties Name Type Description scene Phaser.Scene the scene where the progressbar should be rendered. x number the x coordinate of the progress bar. y number the y coordinate of the progress bar. width number the width of the progress bar. Source: ProgressBar.js, line 1 Members bar :object The progressbar consisting of three parts. The different parts are used for the animation. Type: object Properties: Name Type Description leftCap Phaser.GameObjects.Sprite the left part of the bar middle Phaser.GameObjects.Sprite the middle part of the bar rightCap Phaser.GameObjects.Sprite the right part of the bar Source: ProgressBar.js, line 32 maxWidth :number The maximum width of the progressbar Type: number Source: ProgressBar.js, line 44 value Use this function to set a new text value for the progress bar. It will automatically change the text object valueText Source: ProgressBar.js, line 54 Example // set the text inside the progressbar to the string below: progressbar.value = \"Time left: 6\" valueText :Phaser.GameObjects.BitmapText It is possible to have a text inside the progressbar, which can be useful to display seconds that are left until the process has been finished for example. Type: Phaser.GameObjects.BitmapText Source: ProgressBar.js, line 38 Methods setMeterPercentage(percent) Animates the progressbar to a desired percent value. Parameters: Name Type Default Description percent * 1 the percent value to fill the bar. The value can be between 0 and 1. Source: ProgressBar.js, line 64 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"ProgressBarVertical.html":{"id":"ProgressBarVertical.html","title":"Class: ProgressBarVertical","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: ProgressBarVertical ProgressBarVertical This class implements a vertical progress bar. new ProgressBarVertical(data) Parameters: Name Type Description data object the object that contains the information required to build the progress bar. Properties Name Type Description scene Phaser.Scene the scene where the container should be rendered. x number the x coordinate of the Progressbar. y number the y coordinate of the Progressbar. height number the height of the Progressbar. Source: ProgressBarVertical.js, line 1 Members bar This is an object that contains the top, middle and bottom element of the progress bar. This is used to animate the progress bar. Properties: Name Type Description top Phaser.GameObjects.Sprite the top element of the bar. mid Phaser.GameObjects.Sprite the middle element of the bar. bottom Phaser.GameObjects.Sprite the bottom of the bar. Source: ProgressBarVertical.js, line 36 Methods setMeterPercentage(percent) Animates the progressbar to a desired percent value. Parameters: Name Type Default Description percent * 1 the percent value to fill the bar. The value can be between 0 and 1. Source: ProgressBarVertical.js, line 42 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"RadioButton.html":{"id":"RadioButton.html","title":"Class: RadioButton","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: RadioButton RadioButton A radio button that behaves like a html radio button: it can be checked or unchecked. If a radio button is checked it cannot be unchecked again. new RadioButton() Source: LikertScale.js, line 82 Members isChecked The setter for the isChecked value. Setting this value to the desired state also changes the texture. Source: LikertScale.js, line 108 isChecked Return the state of the button. Source: LikertScale.js, line 122 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Storage.html":{"id":"Storage.html","title":"Class: Storage","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Storage Storage This class implements a storage building, that can hold the parts of the items. new Storage(data) Parameters: Name Type Description data object this object is needed to render the workshop building. It contains the same parameters as the constructor of Building. Source: Storage.js, line 4 Extends Building Members buildingSprite :Phaser.GameObjects.Sprite The sprite that renders the building. See Phaser.GameObjects.Sprite. Type: Phaser.GameObjects.Sprite Inherited From: Building#buildingSprite Source: Building.js, line 53 emitter :EventDispatcher The Emitter is an instance of the EventDispatcher and is used to record the actions performed by the user. In the case of buildings, we always want to record which building has been opened by the player. Type: EventDispatcher Inherited From: Building#emitter Source: Building.js, line 84 image :Phaser.GameObjects.Sprite The image sprite of the building Type: Phaser.GameObjects.Sprite Inherited From: Building#image Source: Building.js, line 92 name :String The name of the Building. This is also the name that is displayed in the tooltip. Type: String Inherited From: Building#name Source: Building.js, line 41 parts :object This object keeps track of the parts that have been produced to indicate how many parts are available to produce an item. Type: object Source: Storage.js, line 27 scene :Phaser.Scene The Scene where the building should be rendered in. In this case this is usually the MainScene. Type: Phaser.Scene Inherited From: Building#scene Source: Building.js, line 61 See: Phaser.Scene sign A sign that can be placed beneath a building Inherited From: Building#sign Source: Building.js, line 46 tooltip :Phaser.GameObjects.Sprite This is the tooltip object that is triggered if the cursor is on the building. Type: Phaser.GameObjects.Sprite Inherited From: Building#tooltip Source: Building.js, line 68 tooltipText :Phaser.GameObjects.BitmapText The text that should be inside the tooltip. It contains the name of the building. Type: Phaser.GameObjects.BitmapText Inherited From: Building#tooltipText Source: Building.js, line 76 Methods addClickListener(func) Adds a listener that reacts on a click on the object. This is used for triggering a dialogue if a specific building is clicked. The function to initiate the individual dialogue must be passed by the instance. Parameters: Name Type Description func function the function that should be triggered, after the object as been clicked. Inherited From: Building#addClickListener Source: Building.js, line 111 addFlashEffect() Add a flash effect to the building to highlight it for the tutorial. Inherited From: Building#addFlashEffect Source: Building.js, line 157 addPointerListeners() Adds pointer events to toggle the display of the tooltip if the pointer is hovering over a building. It will fade in the tooltip if the cursor is above and fade it out if the cursor leaves the building. Inherited From: Building#addPointerListeners Source: Building.js, line 129 combineAvailable() This function checks if the available amount of parts inside the storage is sufficient to build an item and builds it. Source: Storage.js, line 54 stopFlashEffect() Stop the flash effect. Inherited From: Building#stopFlashEffect Source: Building.js, line 174 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"StorageEntry.html":{"id":"StorageEntry.html","title":"Class: StorageEntry","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: StorageEntry StorageEntry This class serves as an entry for each item, listing its components. new StorageEntry() Source: StoragePanel.js, line 34 Methods addButtonListener() This function implements a click listener for the merging button. If it is clicked, it will be checked if all required parts for that item are available and a corresponding event is triggered. Source: StoragePanel.js, line 167 canMerge() This function signals whether there are enough parts available to combine them into an item. Source: StoragePanel.js, line 113 Returns: true, if the conditions for both parts are satisfied, false, if not. drawTree(scene,, topPos, bottomPos, frameMidY) Used to draw the line, indicating that two parts can be combined to create an item. Parameters: Name Type Description scene, Phaser.Scene the scene to draw in, should be the scene that implements the drawing. topPos Phaser.Math.Vector2 the position of the top text to connect with the line. bottomPos Phaser.Math.Vector2 the position of the bottom text to connect with the line. frameMidY Number the middle of the frame to enable drawing in the middle of that frame. Source: StoragePanel.js, line 144 failAnimation() If it is not possible to build an item, this animation is triggered and nothing more happens. Source: StoragePanel.js, line 207 successAnimation() This animation is triggered, if an item can be built successfully. Source: StoragePanel.js, line 186 updateItemDisplay() This function is used to set the text color of the available parts display. If all need parts are available the text turns black, otherwise it remains red, setting the cond boolean to false to disable the merging into an item. Source: StoragePanel.js, line 79 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"TextDialogue.html":{"id":"TextDialogue.html","title":"Class: TextDialogue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: TextDialogue TextDialogue This class provides dialogue scene to get a user text input. In order to create this dialogue the values required by the DialogueScene must be provided on creation. Therefore, see DialogueScene#init. new TextDialogue() Source: TextDialogue.js, line 24 Example // go to the place, where the scene should be started and insert the following line this.scene.launch('textDialogue', {mainScene: this, title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION questionNumber: NUMBER}); // \"this\" must be a scene, because this.scene points at the scene manager of the specific scene. Members formUtil :FormUtil The form util takes care of the setup of the text area. Type: FormUtil Source: TextDialogue.js, line 68 question :String The question that is displayed to the user above the input field, where the player can type in the answer. Type: String Source: TextDialogue.js, line 52 questionNumber :number The question number specifies in what sosci survey item the value is stored. This is important, if there are multiple text dialogues to keep track of the different questions. Type: number Source: TextDialogue.js, line 44 title :String This is the title of the dialogue. Type: String Source: TextDialogue.js, line 37 Methods renderQuestion() Displays the quesiton on the dialogue. Source: TextDialogue.js, line 88 sendText() This function sends the text that has been typed in by the player via the Sosci Writer. If ON_LOCAL_MACHINE is set to true, the value is just being printed. Source: TextDialogue.js, line 100 setQuestionFontSize(size) Adjust the size of the question text. Parameters: Name Type Description size number the desired fontsize for the question Source: TextDialogue.js, line 119 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Tutorial.html":{"id":"Tutorial.html","title":"Class: Tutorial","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Tutorial Tutorial This class handels the infrastructure of the tutorial at the beginning of the game. new Tutorial(mainScene) Parameters: Name Type Description mainScene MainScene the mainscene of the game, used to manipulate the game flow during the tutorial. Source: Tutorial.js, line 19 Members active :boolean A flag that indicates that the tutorial is still active. This should be set to false if the month is skipped from the tutorial Type: boolean Source: Tutorial.js, line 44 banner :InformerBanner The banner, that is used to place the tutorial text. Type: InformerBanner Source: Tutorial.js, line 180 emitter :EventDispatcher The eventDispatcher instance. It is used to catch when a dialogue is ready. We need this information to control buttons or other elements but this is only possible when they're loaded properly. Type: EventDispatcher Source: Tutorial.js, line 51 initMetal :array Used for resetting the resources afte the tutorial has ended. Type: array Source: Tutorial.js, line 31 initWood :array Used for resetting the resources afte the tutorial has ended. Type: array Source: Tutorial.js, line 37 MESSAGES :Array.&lt;object&gt; Provide the tutorial timeline. Choose text and the condition that needs to be met in order to continue to the next step of the tutorial. Type: Array.&lt;object&gt; Source: Tutorial.js, line 58 Methods countProduction(element, position, quantity) Invoked if the buttons are successfully loaded and takes care of the productionbutton clicks to count the right amount of parts built. Parameters: Name Type Description element * this is usually from the class WorkshopDialogue, where the buttons are located. We will listen to them and count the clicks. position number In the workshop dialogue there is a left and a right produciton button. Provide a 0 to listen to the left button and 1 for the right button. quantity number the quatntity of the item to be built. After the item is built in the provided quantity we will step to the next dialogue point. Source: Tutorial.js, line 246 deactivateGameflow() Turns off the controls of the ui scene and deactivates the timer. Source: Tutorial.js, line 205 enableInteraction() Enables all functionlaity of the game and get rid of the tutorial dialogue. This allows the player to look around and try the new learned features and controls of the game. Furthermore, the button for skipping the month officially ends the tutorial. Source: Tutorial.js, line 355 endTutorial() Ends the tutorial, reactivating the timer and resetting the values. Source: Tutorial.js, line 328 startTutorial() Initiates the tutorial. It also changes the settings of the game to separate the actual experiment from the tutorial story Source: Tutorial.js, line 172 step() Steps to the next position of the messages field, reloading the text and invoking a new listener. Source: Tutorial.js, line 193 waitForClick(element) Implements the functionality to change the text if the element is clicked. This allows to make multiple messages where the subject can click through. If it is clicked once, the next text message is loaded, invoking a different listener. Parameters: Name Type Description element * the element that should be clicked to continue. Source: Tutorial.js, line 291 waitForClose(element) Waits for a dialogue to be closed. Parameters: Name Type Description element DialogueScene the element containing the close button Source: Tutorial.js, line 277 waitForProduction(element, position, quantity) Waits until the player has clicked a production button several times. This corresponds to a desired quantity that needs to be produced. a WorkshopDialogue emits 'workshopReady' when opened. We use this event to make sure the elements inside this dialogue are loaded. Parameters: Name Type Description element WorkshopDialogue the dialogue scene to locate the production button in position number 0 for the left button 1 for the right button of the workshop. quantity number define how often the button must be clicked in order to continue. Source: Tutorial.js, line 224 See: WorkshopDialogue × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Ui.html":{"id":"Ui.html","title":"Class: Ui","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Ui Ui new Ui() This class implements a UI scene as a top bar, that shows available material, the actual month and the time until the next month. Source: Ui.js, line 6 Extends Phaser.Scene Members emitter An event dispatcher which is used to record when the player skips a month. Source: Ui.js, line 43 mainScene :MainScene The main scene to get infromation from. Type: MainScene Source: Ui.js, line 38 player :Player The player instance. Type: Player Source: Ui.js, line 32 Methods create() This function renders the information inside the scene. Source: Ui.js, line 50 init(data) The function is called if the scene is launched. The data is passed with the function that starts this scene. Parameters: Name Type Description data object the data that is passed to the scene. Properties Name Type Description player Player the player instance that is used to display the available material and money. mainScene MainScene the mainScene. This instance is used to display the time that is left. Source: Ui.js, line 26 See: Launching a Scene proceed() If the player has agreed on the skip month dialogue or everything is set to skip the month, it will executed, ending the tutorial - if any - and proceeding to the next month. Source: Ui.js, line 174 setupSkipButton() This function initiates the button that is used to skip the month. Source: Ui.js, line 132 skipMonth() This function is invoked, when the skip button is pressed. Source: Ui.js, line 146 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"WarningDialogue.html":{"id":"WarningDialogue.html","title":"Class: WarningDialogue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: WarningDialogue WarningDialogue This class asks the player if he or she is sure to proceed. It can be used if the player skips a month without having produced anything of if it is tryed to skip the month while workshops are still producing. In order to make this dialogue work, the data dictionary must contain the field \"text\", filled with the text, the player recieves. Also the fields mentioned in DialogueScene must be filled in. new WarningDialogue() Source: WarningDialogue.js, line 4 Example // Starts a warningDialogue asking the player if he or she is sure to proceed. this.scene.launch('warningDialogue', {mainScene: this, title: \"Warning\", text: \"Are you sure you want to proceed?\"}); Extends InteractionScene Members data :object Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way the scene can be used more flexible. As an example: the WorkshopDialogue maintains an instance of the workshop, to read the status and schedule building orders. The workshop can be passed as an entry in this data object. Type: object Inherited From: DialogueScene#data Source: DialogueScene.js, line 59 emitter The EventDispatcher to monitor that a dialogue has been closed by the player Inherited From: DialogueScene#emitter Source: DialogueScene.js, line 65 height :number The height of the dialogue. Type: number Inherited From: DialogueScene#height Overrides: InteractionScene#height Source: DialogueScene.js, line 45 mainScene :MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. Type: MainScene Inherited From: DialogueScene#mainScene Source: DialogueScene.js, line 39 panel :Panel The panel which renders the frame and the headline. Type: Panel Inherited From: DialogueScene#panel Source: DialogueScene.js, line 112 text :String The text message that should be displayed to the player. It should be a question that can be answered with \"yes\" or \"no\", since the player gets two buttons to answer. Type: String Source: WarningDialogue.js, line 41 title :String The title of the dialogue Type: String Source: WarningDialogue.js, line 33 width :number The width of the dialogue. Type: number Inherited From: DialogueScene#width Overrides: InteractionScene#width Source: DialogueScene.js, line 51 Methods close() Override the close function from the DialogueScene to resume the game time Inherited From: InteractionScene#close Source: InteractionScene.js, line 40 createDialogue(header) Creates the dialogue like and behaves like a normal DialogueScene but additionally stops the gametime and disables the input of the Ui. Parameters: Name Type Default Description header String Header the headline of the scene. Inherited From: InteractionScene#createDialogue Source: InteractionScene.js, line 27 fadeIn( [completeCallback]) This function is used to animate the appearance of the panel, by animating its scale to 100% within 150 milliseconds. Parameters: Name Type Argument Description completeCallback function &lt;optional&gt; a function that is executed once the animation has finished. Inherited From: DialogueScene#fadeIn Source: DialogueScene.js, line 128 handelResponse(response) Act according to the decision of the player. Used as a callback function from the buttons. Parameters: Name Type Description response boolean the response of the player, if set to false, the dialoge closes without any further actions. If set to true, the dialogue closes and emits a callback called \"clickedYes\". Source: WarningDialogue.js, line 69 init(data) The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. launch start). In this case the additional data is used to build a basic panel that can be adopted by every class that is extending this class. Parameters: Name Type Description data object the data object contains relevant data for this scene as well as additional data that can be used by the child scenes of this DialogueScene. See {@DialogueScene#data}. Properties Name Type Description mainScene MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. height number The height of the dialogue. width number The width of the dialogue. Inherited From: DialogueScene#init Source: DialogueScene.js, line 34 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"Workshop.html":{"id":"Workshop.html","title":"Class: Workshop","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: Workshop Workshop This class implements a workshop that can produce items. new Workshop(data) Parameters: Name Type Description data object the data object that is used to create a workshop. Properties Name Type Description scene Phaser.Scene the scene where the building should be built in. See Phaser.Scene x Number the x coordinate where the building should be placed. y Number the y coordinate for the building. image String the image key of the building. name String the name of the building. availableHours number the time that is available per month on this workshop. items Array.&lt;module:Item~Item&gt; the items this workshop can produce. management Management the management building associated to this workshop. This is used to plan a production of an item. Source: Workshop.js, line 6 Extends Building Members availableHours :number The hours available in this workshop. For every item built this value is decreased. Type: number Source: Workshop.js, line 61 availableHours Sets the availalbe hours of this workshop while manipulating the ProgressBar that indicates the time available in the workshop. Source: Workshop.js, line 78 availableHours Returns the time available inside the workshop Source: Workshop.js, line 87 buildingSprite :Phaser.GameObjects.Sprite The sprite that renders the building. See Phaser.GameObjects.Sprite. Type: Phaser.GameObjects.Sprite Inherited From: Building#buildingSprite Source: Building.js, line 53 busy Defines if the workhsop is producing right now. If this is set to true, all following work commands will be added to the queue and the produce animation of this workshop is activated. Source: Workshop.js, line 97 busy Returns the status of the workshop. Source: Workshop.js, line 106 emitter :EventDispatcher The Emitter is an instance of the EventDispatcher and is used to record the actions performed by the user. In the case of buildings, we always want to record which building has been opened by the player. Type: EventDispatcher Inherited From: Building#emitter Source: Building.js, line 84 image :Phaser.GameObjects.Sprite The image sprite of the building Type: Phaser.GameObjects.Sprite Inherited From: Building#image Source: Building.js, line 92 initialHours :number The initial amount of hours available in this workshop. This value is used to reset the available hours on month change. Type: number Source: Workshop.js, line 55 items :Array.&lt;module:Item~Item&gt; The items this workshop can produce. Type: Array.&lt;module:Item~Item&gt; Source: Workshop.js, line 35 management :Management The management that organizes this workshop. Type: Management Source: Workshop.js, line 40 name :String The name of the Building. This is also the name that is displayed in the tooltip. Type: String Inherited From: Building#name Source: Building.js, line 41 queue :Array The queue that indicates which item should be produced if the actual item is done producing. Type: Array Source: Workshop.js, line 46 scene :Phaser.Scene The Scene where the building should be rendered in. In this case this is usually the MainScene. Type: Phaser.Scene Inherited From: Building#scene Source: Building.js, line 61 See: Phaser.Scene sign A sign that can be placed beneath a building Inherited From: Building#sign Source: Building.js, line 46 tooltip :Phaser.GameObjects.Sprite This is the tooltip object that is triggered if the cursor is on the building. Type: Phaser.GameObjects.Sprite Inherited From: Building#tooltip Source: Building.js, line 68 tooltipText :Phaser.GameObjects.BitmapText The text that should be inside the tooltip. It contains the name of the building. Type: Phaser.GameObjects.BitmapText Inherited From: Building#tooltipText Source: Building.js, line 76 Methods addBars() Add the bars for available time and producing time, that are visible on the map. Source: Workshop.js, line 243 addClickListener(func) Adds a listener that reacts on a click on the object. This is used for triggering a dialogue if a specific building is clicked. The function to initiate the individual dialogue must be passed by the instance. Parameters: Name Type Description func function the function that should be triggered, after the object as been clicked. Inherited From: Building#addClickListener Source: Building.js, line 111 addFlashEffect() Add a flash effect to the building to highlight it for the tutorial. Inherited From: Building#addFlashEffect Source: Building.js, line 157 addPointerListeners() Adds pointer events to toggle the display of the tooltip if the pointer is hovering over a building. It will fade in the tooltip if the cursor is above and fade it out if the cursor leaves the building. Inherited From: Building#addPointerListeners Source: Building.js, line 129 createDialogue() Creates the WorkshopDialogue. Source: Workshop.js, line 114 done() This function is triggered after the working timer has expired. It emits a 'finished' event to the process, that can handel the result. After that, the queue is checked to produce the next item. Source: Workshop.js, line 229 interrupt() Stops the current production and detatching its process and clearing the queue. Source: Workshop.js, line 212 resetHours() Reset the available working hours back to the initial values to refill the capacity. Usually done at the change of month. Source: Workshop.js, line 269 setProduceAnimation(on) Initiates the animation of the building to signal that it is busy. Parameters: Name Type Description on boolean defining if the animation should be started or stopped. Source: Workshop.js, line 128 stopFlashEffect() Stop the flash effect. Inherited From: Building#stopFlashEffect Source: Building.js, line 174 work(data) Initiate the working animation and the timer in order to finish a process. If the time is over, the done function of this workshop is called, signaling the process that this workshop is done. If the workshop is already producing, the process will be queued. Parameters: Name Type Description data Object an object holding the process and the amount of time that will be needed to finish the process. Properties Name Type Description process Process the process that provides the data needed to produce the item. time number the time that is needed inside this workshop. Source: Workshop.js, line 190 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"WorkshopDialogue.html":{"id":"WorkshopDialogue.html","title":"Class: WorkshopDialogue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: WorkshopDialogue WorkshopDialogue This class is the Dialogue that appears if a Workshop has been clicked. The main Responsibility lies in providing information about the production status as well as the production queue. It also provides production functionality if the option PRODUCE_IN_MANAGEMENT is set to `false`. new WorkshopDialogue() Source: WorkshopDialogue.js, line 9 Extends DialogueScene Members availableBar :ProgressBar The Progressbar that shows how much time is available in the actual month. Type: ProgressBar Source: WorkshopDialogue.js, line 114 availableTimeText Text that describers the AvailableTimeBar. Source: WorkshopDialogue.js, line 83 buttonLeft :Button If the option PRODUCE_IN_MANAGEMEN is set to `false`, a button is created to initiatie the production of one part of furniture. This button is located on the left. Type: Button Source: WorkshopDialogue.js, line 235 buttonRight :Button If the option PRODUCE_IN_MANAGEMENT is set to `false`, a button is created to initiatie the production of one part of furniture. Type: Button Source: WorkshopDialogue.js, line 276 clickSound :Phaser.Sound.BaseSound Adds the clicksound, which was loaded by the Preloader to the scene. The sound is added using phasers BaseSoundManager Type: Phaser.Sound.BaseSound Source: WorkshopDialogue.js, line 45 data :object Additional data that can be used by child scenes. Some dialogueScenes my need more than just the main scene. This way the scene can be used more flexible. As an example: the WorkshopDialogue maintains an instance of the workshop, to read the status and schedule building orders. The workshop can be passed as an entry in this data object. Type: object Inherited From: DialogueScene#data Source: DialogueScene.js, line 59 emitter The EventDispatcher to monitor that a dialogue has been closed by the player Inherited From: DialogueScene#emitter Overrides: DialogueScene#emitter Source: DialogueScene.js, line 65 errorSound :Phaser.Sound.BaseSound Adds the errorsound, which was loaded by the Preloader to the scene. The sound is added using phasers BaseSoundManager Type: Phaser.Sound.BaseSound Source: WorkshopDialogue.js, line 52 height :number The height of the dialogue. Type: number Inherited From: DialogueScene#height Source: DialogueScene.js, line 45 itemImage :Phaser.GameObjects.Sprite The image that indicates the item that is currently produced. See The Phaser Documentation for informations about sprites. Type: Phaser.GameObjects.Sprite Source: WorkshopDialogue.js, line 93 mainScene :MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. Type: MainScene Inherited From: DialogueScene#mainScene Source: DialogueScene.js, line 39 nextText Text that describes the Queue. Source: WorkshopDialogue.js, line 87 panel :Panel The panel which renders the frame and the headline. Type: Panel Inherited From: DialogueScene#panel Source: DialogueScene.js, line 112 producingText The text indicating that something is being produced. See BitmapText for more information. Source: WorkshopDialogue.js, line 74 progressText Text that describes the ProgressBar. Source: WorkshopDialogue.js, line 79 width :number The width of the dialogue. Type: number Inherited From: DialogueScene#width Source: DialogueScene.js, line 51 workProgress :ProgressBar The Progressbar that informs about the time that is left to finish production of the item that is currently produced. Type: ProgressBar Source: WorkshopDialogue.js, line 101 workshop :Workshop A workshop instance, which is the workshop that has been clicked. This makes sure, that all actions taken in this scene affect the right workshop. Type: Workshop Source: WorkshopDialogue.js, line 60 workshopQueue :WorkshopQueue The queue that displays the items that will be produced after the actual item is finished. Type: WorkshopQueue Source: WorkshopDialogue.js, line 130 Methods addCostsContainer() Creates a container that adds the required resources for the particular part. It has textfields to indicate the costs of the item (wood, metal and time). See the Phaser Docs. Source: WorkshopDialogue.js, line 324 Returns: the container that has been created. Type Phaser.GameObjects.Container addProduceButtons() This function adds the produce buttons inside the workshop dialogue on top of the progess display and the queue. Therefore it changes the size of the dialogue and the position of the progress display and queue. Source: WorkshopDialogue.js, line 205 Returns: The new offset for the following objects, that appear in the dialogue. Type Number close() This function creates a closing effect, animating the scale of the panel to zero within 150 milliseconds. This function also stops the scene that is calling the function and enables the inputs of the main scene. Inherited From: DialogueScene#close Source: DialogueScene.js, line 74 create() This function is always run after a scene is started. It creates the resources that are needed to display and handel the dialogue. Source: WorkshopDialogue.js, line 34 createDialogue(header) Creates a panel that can be filled with content by every class inheriting from this class. Note that the panel initially has a scale of zero causing the object to be invisible. The function fadeIn can be used to make it appear. Alternatively the scale of the panel can be set to 1 manually. This function also disables every input for the main scene, which means that the player cannot open new buildings or navigate through the map as long as a dialogue is opened. The close function re-enables the inputs of the main scene. Parameters: Name Type Default Description header string Header the headline which will be displayed on top of the panel. Inherited From: DialogueScene#createDialogue Source: DialogueScene.js, line 103 fadeIn( [completeCallback]) This function is used to animate the appearance of the panel, by animating its scale to 100% within 150 milliseconds. Parameters: Name Type Argument Description completeCallback function &lt;optional&gt; a function that is executed once the animation has finished. Inherited From: DialogueScene#fadeIn Source: DialogueScene.js, line 128 init(data) The init function is as the scene is initialized. It is possible to pass additional data to the function that starts a scene (e.g. launch start). In this case the additional data is used to build a basic panel that can be adopted by every class that is extending this class. Parameters: Name Type Description data object the data object contains relevant data for this scene as well as additional data that can be used by the child scenes of this DialogueScene. See {@DialogueScene#data}. Properties Name Type Description mainScene MainScene The main scene of the game. This is useful, because this way a dialogue scene can read game related data directly form the scene. height number The height of the dialogue. width number The width of the dialogue. Inherited From: DialogueScene#init Source: DialogueScene.js, line 34 update() This function is called after every frame, updating the queue status of the workshop and the progressbars Source: WorkshopDialogue.js, line 160 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"WorkshopQueue.html":{"id":"WorkshopQueue.html","title":"Class: WorkshopQueue","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Class: WorkshopQueue WorkshopQueue This class is responsible for displaying the items that will be produced next for one workshop. It displays the five next items. If the queue is longer than five, these items are invisible until they belong to the indices 0-4. new WorkshopQueue(data) Parameters: Name Type Description data object the data object that contains the required information to build the queue. Properties Name Type Description scene Phaser.Scene the scene where the queue should be rendered in. This is usually a WorkshopDialogue. x number the x coordinate where the queue is displayed in. y number the y coordinate where the queue is displayed in. Source: WorkshopQueue.js, line 3 See: Phaser.GameObjects.Container Extends Phaser.GameObjects.Container Members queue :Array.&lt;object&gt; The queue is obtained from the Workshop#queue. It is a list of objects that are structured the following way: Type: Array.&lt;object&gt; Properties: Name Type Description process Process the production process of the item time number the production duration that is reserved for the process. Source: WorkshopQueue.js, line 54 scene The scene where this object is rendered. Source: WorkshopQueue.js, line 61 See: Phaser.Scene sprites :Array.&lt;Phaser.Sprite&gt; This is a list of sprites. Its size is always 5 corresponding to the maximum of visible values in this queue. If the queue is smaller than 5, the rest of the items inside the sprite list will be set to invisible, but they still use space. This ensures the stack-like behavior. Type: Array.&lt;Phaser.Sprite&gt; Source: WorkshopQueue.js, line 45 Methods update() Refresh the status of the queue. This function iterates over the images and if there are items inside the queue, it displays them by getting the imageCode and making them visible by setting alpha to 1. If an item does not exist in the queue, it is set to transparent (= invisible). Source: WorkshopQueue.js, line 70 × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"tutorial-How To Create Question Dialogues.html":{"id":"tutorial-How To Create Question Dialogues.html","title":"Tutorial: How To Create Question Dialogues","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey How To Create Question Dialogues This tutorial shows how to use different dialogue classes to interact with the participants. Each class serves a different purpose as you will see in the following. AssessmentDialogue - What Do You Feel About Your Answer? Using the AssessmentDialogue we can obtain data on what the participant thinks on his or her performance. It consists of a likert-scale to evaluate the own performance as well as a text field to provide a reason. Adding a question to SoSciSurvey In order to store the answers of the participant, a placeholder needs to be created in the SoSciSurvey instance. If you uploaded the project like shown in [this tutorial](./tutorial-Uploading Project to SosciSurvey.html), you will already have a few Placeholders. The field we are looking for is AS Assessment. The Questions you add under the AS Assessment field will correspond to one AssessmentDialogue. Thus, in this example there are already 2 Assessments. To add another placeholder for a third assessment, click Add Question, choose a name, set the type to internal Variables and save your changes: After that, the question you have created appears on the left bar. Click it and add two variables inside the question. the variable with id $01$ corresponds to the Likert-scaled answer and the variable with id $02$ is the free-text answer. Now your question can be linked to the game! Create an AssessmentDialogue in the Game To make the question appear in the game, it must be created. Therefore you can use two approaches Using the ScenePlugin A way to directly instantiate an AssessmentDialogue is using the ScenePlugin from Phaser. Basically you can start a dialogue from wherever you want. Suppose you are in the MainScene and you want to start a Dialogue, when the third month is reached. Inside the nextMonth function you can write something like: if (this.month.value === 2) // months count from zero { this.scene.launch('assesmentDialogue', {mainScene: this, title: \"\", question: \"\", questionNumber: 3 }); } This way, the AssessmentDialogue starts. Note That the Title and question are already filled in by default. The questionNumberis very important since it allows to fill the values to the corresponding variable in SoSciSurvey. An AssessmentDialogue with questionNumber: 3 will write its values inside the variable \"AS03\". Make sure you have created one as described above. Things to note in this case thiscorresponds to a MainSceneinstance. It is recommended to run dialogues off the MainScene, because it takes care of the camera position a placement of dialogues. If you want to run a dialogue from a different class, simply pass an instance of the MainScene. Drawbacks using this approach Using scene.launchhas the drawback to launch the scene immediately, so it can happen that multiple dialogues are launched at the same time, causing multiple windows at once. To overcome that, you can use the DialogueSchedule Class. Using the DialogueScheduler With this class you can add multiple dialogues and decide when to run them. By default, the first dialogue you add, is the first that will be launched. After it is closed, the second dialogue is launched until each dialogue has been launched and closed. For more information see DialogueSchedule. Example Use if (this.month.value === 2){ this.schedule.addDialogue('assesmentDialogue', {mainScene: this, title: \"\", question: \"\", questionNumber: 1}); } Because this runs inside the nextMonthfunction, we do not need to do more because schedule.run()will already be called in this function. However for your individual schedules you will need to run the schedule to start them. aiDialogue - How Well is Mike Doing? An AiDialogue can be used to let the participant evaluate a specific solution. It is very similar to an AssessmentDialogue, because it has a Likert-scaled answer and a free-text answer. Additionally it proposes mikes solution to a certain problem. Adding a question to SoSciSurvey On SosciSurvey it is quite similar to the creation of a new AssessmentDialogue question. In this case, the question you are looking for is FB Feedback to Mike. Add a new question and add the a variable with Id $01$ for the Likert answer and $02$ for the free-text answer. Thats it! Create an AiDialogue in the Game The creation without the DialogueSheduleis analogous, only with a different keyword at the start. Thus it is left out. See the previous section on the AssessmentDialogue if you want to use that approach. To create an AiDialogue we need to provide a bit more information: if (this.month.value === 11) { this.schedule.addDialogue('aiDialogue', {mainScene: this, title: \"\", question: \"\", questionNumber: 1, aiData: { chair: { profit: this.chair.profit[this.month.value-1], solution: 6 }, bed: { profit: this.bed.profit[this.month.value-1], solution: 1 }, bookcase: { profit: this.bookcase.profit[this.month.value-1], solution: 4 }, table: { profit: this.table.profit[this.month.value-1], solution: 0 }, material: { wood: this.player.initialWood[this.month.value-1], metal: this.player.initialMetal[this.month.value-1] } } The class will use this data in order to display custom settings for mike's solution. Note that here you start again with questionNumber 1, if this is the first aiDialogue, regardless of already heaving dialogues of other classes. This is because the variables are different ones in SoSciSurvey. Make sure the number always corresponds to the question number in SoSciSurvey. TextDialogue - Is there anything you want to say? Use the TextDialogue to retrieve free-text answers from the participants. Adding a question to SoSciSurvey Like for every value from the participant we want to save, it is necessary, to create a corresponding variable that stores the answers. For the TextDialogue, use the AN AnswersQuestion. Unlike the other versions, the placeholder for the answers are one level below, because we do not have Likert- and text answers: In order to add placeholders for the answers, provide a description for each variable. The number in the ID column corresponds to the question number you want to use in the implementation. Create a TextDialogue in the Game Like for the other dialogues, you can feel free to launch the scene directly this.scene.launch('textDialogue', {mainScene: this, avatar: 'mike', title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION, questionNumber: NUMBER}); Or to use the dialogueSchedule this.schedule.addDialogue('textDialogue', {mainScene: this, avatar: 'mike', title: PROVIDE_A_TITLE, question: PROVIDE_A_QUESTION, questionNumber: NUMBER}); this - in this example the dialogue is launched from the MainScene but you can provide any active scene instance instead of this For example: ManagementDialogue, MarketDialogue etc. schedule - the DialogueSchedule instance that has already been created in this class. textDialogue - The key of the Textfield dialogue scene. mainScene - This is the instance of MainScene and is used for positioning. Every Scene that extends the DialogueScene needs to have a mainScene instance that can be accessed. title - Provide a text that should be displayed at the top of the dialogue like shown in the picture at the top. question - Here you can provide the text, that should be displayed below the title. Use \\n for a line break. questionNumber - This is the variable ID discussed above. If I choose 1 as number, the value of this Answer will be written inside first question. avatar: Tells the scene that it should place the avatar from mike in the scene. Note: The textfield is an HTML element. The positioning will be wrong if viewed on the local machine. On SosciSurvey the position should be correct. × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"tutorial-Set up SociSurvey.html":{"id":"tutorial-Set up SociSurvey.html","title":"Tutorial: Set up SociSurvey","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Set up SociSurvey How to Run the Game on the Local Machine The game needs to run on a (virtual) webserver. To start a local webserver using python 2, the command $ python -m SimpleHTTPServer [port] can be used inside the game folder. After that the game can be started by opening localholst:PORTinside the browser. Make sure the constant ON_LOCAL_MACHINE in the file Constants.js is set to true. How to Host the Game on SosciSurvey Note: This tutorial is intended to lead through a custom setup. There is an easier way to setup the project with all resources, variables and pages. Search for the tutorial \"Uploading Project to SosciSurvey.\" Create a new Project on the platform. Create a new text element, set the formatting filed to HTML code and fill in the contents of the index.htmlfile without the surrounding tags. It should look like the picture below: Create a new questionnaire at the Menu point Compose Questionnnaire and add the created text element by dragging it into the page placeholder. Make sure the constant ON_LOCAL_MACHINE is set to false. Upload all files except for the index.html file to SosciSurvey, under Image and Medial Files. Test the game by clicking the green button inside the Compose Questionnaire menu as shown above. Adding Variables to SosciSurvey At the menu List of Questions add three new sections for the player, model and time. The IDs must match with the value of the constants SOSCI_PLAYER_VAR, SOSCI_MODEL_VAR and SOSCI_PLAYER_TIME_VAR inside the GameProperties.js file. In the section Player add a new Question for the Profit of the type Internal Variables Use the Tab 'Import items directly', check the box 'Delete current items before inserting new ones' and copy the corresponding 12 values for player_profit from the following list into the text field. Click the save button. # For every question copy these 12 values into the textfield to add them to SosciSurvey. # Player Profit player_profit_month 1 player_profit_month 2 player_profit_month 3 player_profit_month 4 player_profit_month 5 player_profit_month 6 player_profit_month 7 player_profit_month 8 player_profit_month 9 player_profit_month 10 player_profit_month 11 player_profit_month 12 # Suggestion for GameProperties if the order of variable cration is followed. Make sure the variable number in GameProperties is the Same as the variable number of SosciSurvey In the GameProperties this variable should have the number: 01 # Player Produced Beds player_beds_month 1 player_beds_month 2 player_beds_month 3 player_beds_month 4 player_beds_month 5 player_beds_month 6 player_beds_month 7 player_beds_month 8 player_beds_month 9 player_beds_month 10 player_beds_month 11 player_beds_month 12 In the GameProperties this variable should have the number: 02 # Player Produced Bookcases player_bookcases_month 1 player_bookcases_month 2 player_bookcases_month 3 player_bookcases_month 4 player_bookcases_month 5 player_bookcases_month 6 player_bookcases_month 7 player_bookcases_month 8 player_bookcases_month 9 player_bookcases_month 10 player_bookcases_month 11 player_bookcases_month 12 In the GameProperties this variable should have the number: 03 # Player Produced Tables player_tables_month 1 player_tables_month 2 player_tables_month 3 player_tables_month 4 player_tables_month 5 player_tables_month 6 player_tables_month 7 player_tables_month 8 player_tables_month 9 player_tables_month 10 player_tables_month 11 player_tables_month 12 In the GameProperties this variable should have the number: 04 # Player Produced Chairs player_chairs_month 1 player_chairs_month 2 player_chairs_month 3 player_chairs_month 4 player_chairs_month 5 player_chairs_month 6 player_chairs_month 7 player_chairs_month 8 player_chairs_month 9 player_chairs_month 10 player_chairs_month 11 player_chairs_month 12 In the GameProperties this variable should have the number: 05 # Model Profit model_profit_month 1 model_profit_month 2 model_profit_month 3 model_profit_month 4 model_profit_month 5 model_profit_month 6 model_profit_month 7 model_profit_month 8 model_profit_month 9 model_profit_month 10 model_profit_month 11 model_profit_month 12 In the GameProperties this variable should have the number: 01 # Model Produced Beds model_beds_month 1 model_beds_month 2 model_beds_month 3 model_beds_month 4 model_beds_month 5 model_beds_month 6 model_beds_month 7 model_beds_month 8 model_beds_month 9 model_beds_month 10 model_beds_month 11 model_beds_month 12 In the GameProperties this variable should have the number: 02 # Model Produced Bookcases model_bookcases_month 1 model_bookcases_month 2 model_bookcases_month 3 model_bookcases_month 4 model_bookcases_month 5 model_bookcases_month 6 model_bookcases_month 7 model_bookcases_month 8 model_bookcases_month 9 model_bookcases_month 10 model_bookcases_month 11 model_bookcases_month 12 In the GameProperties this variable should have the number: 03 # Model Produced Tables model_tables_month 1 model_tables_month 2 model_tables_month 3 model_tables_month 4 model_tables_month 5 model_tables_month 6 model_tables_month 7 model_tables_month 8 model_tables_month 9 model_tables_month 10 model_tables_month 11 model_tables_month 12 In the GameProperties this variable should have the number: 04 # Model Produced Chairs model_chairs_month 1 model_chairs_month 2 model_chairs_month 3 model_chairs_month 4 model_chairs_month 5 model_chairs_month 6 model_chairs_month 7 model_chairs_month 8 model_chairs_month 9 model_chairs_month 10 model_chairs_month 11 model_chairs_month 12 In the GameProperties this variable should have the number: 05 # Indicates if a player had running workshops by the time the months has changed. interrupted_in_month 1 interrupted_in_month 2 interrupted_in_month 3 interrupted_in_month 4 interrupted_in_month 5 interrupted_in_month 6 interrupted_in_month 7 interrupted_in_month 8 interrupted_in_month 9 interrupted_in_month 10 interrupted_in_month 11 interrupted_in_month 12 In the GameProperties this variable should have the number: 06 Repeat for every question using the list above Repeat the same in the section for the model. Note: Maintain the same order for the player and model variables and make sure to fit the numbers of the questions with the values of the SOSCI constants inside the GameProperties.js file. Example: If the variable Produced Beds has the name PL02, then the model must have its Produced Bedsvariable at MD02aswell. Inside the GameProperties.js the corresponding constant SOSCI_BEDS will have the value '02'. Add a question to measure the time of the player and add a variable for each month like done above. Match the name of the question with the SOSCI_PLAYER_TIME_VAR constant inside the file GameProperties.js. Now these variables are visible inside the Compose Questionnaire menu. Drag them above the text element which contains the previously added HTML. The values will be stored if a game has been finished. Configure the Game To make adjustments to the games behavior, the files GameProperties.js and Constants.js can be used. Constants.js Contains technical settings like: Size of several game objects Durations of animations values related to the linear model. GameProperties.js Contains game/experiment relevant settings such as: Decide which information the player should receive during the game Feedback texts and thresholds for the different feedbacks The SosciSurvey variable names. × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "},"tutorial-Uploading Project to SosciSurvey.html":{"id":"tutorial-Uploading Project to SosciSurvey.html","title":"Tutorial: Uploading Project to SosciSurvey","body":" FurnitureCompany - Strategy Game Modules ConstantsFeedbackSummaryGameGamePropertiesglpkUtilityItemItemPriceTableProfitSummarySosciWriter Classes AiDialogueAssesmentDialogueBuildingButtonDiagramDialogueSceneDialogueScheduleEventDispatcherFinalSummaryFormUtilInformerBannerInteractionSceneLikertScaleMainSceneManagementManagementDialogueMarketMarketDialogueMessageDialogueFeedbackSummary~ProfitSummaryItemPriceTable~ItemPriceTableItem~ItemProfitSummary~ProfitSummaryNewsScenePanelPartDisplayPlayerPreloaderProcessProgressBarProgressBarVerticalRadioButtonStorageStorageEntryTextDialogueTutorialUiWarningDialogueWorkshopWorkshopDialogueWorkshopQueue Tutorials How To Create Question DialoguesSet up SociSurveyUploading Project to SosciSurvey Uploading Project to SosciSurvey How to Upload the Project to SosciSurvey This tutorial shows the recommended way to setup the project in SosciSurvey. Inside the repository, there is a folder called experiment where the folders strategy_game and ui are located. Each folder contains the corresponding game as a SosciSurvey project file in XML format. This file can be uploaded directly with all required resources, questionnaire pages and variables. Even if you have made changes it is recommended to first upload the project and then overwrite the changed files. This way it is ensured that every other resource is uploaded correctly. Create SosciSurvey Project First, create a new Project in SosciSurvey (If you need help with that, consider the official tutorial) In the left sidebar navigate to Controls → Survey Project → Project Settings Scroll to the bottom of the page and look in section Export Project for the option Import Project or Questions Upload the XML file for the desired project. Done. × Search results Close Documentation generated by JSDoc 3.6.6 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
